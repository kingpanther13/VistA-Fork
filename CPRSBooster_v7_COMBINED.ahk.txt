	;-----------by Adam Bock 

	
#SingleInstance force


/* ; testing 

;  Blank area for testing auto execute code

*/ ; testing 


; --------------INITIALIZE VARIABLES
CurVersion = 90 ; this doesn't really need to match current version. BUT if you want pop up: this value has to change vs
						; last time booster wrote to user's file (ie launch)
				; what really drives current version is (a) launcher and 
				; (b) comparison version num in AUTO directory ver file AND looking for that version #
				; INSIDE of the user's active script name

IncludeToolboxLogic := false  ; false = disable hotkeys when consult toolbox is open
paintedToolbarsyet := 0 ; gosub to gui 14,7 and quick order first time; then hide/show
; BoosterRoot = \\v23.med.va.gov\apps\GUI\MIN\MIN_GUI\Auto\     ; OLD change this during exe location move


EnvGet, onedrive, ONEDRIVE
EnvGet, userprofile, USERPROFILE

BoosterRoot  = \\v23.med.va.gov\apps\GUI\Local_Site_GUI\MIN\CPRSBOOSTER\   ; NEW ROOT; ALSO CHANGE txt files IN new dir

onedriveRoot := onedrive
onedrivelocal := onedrive . "\CPRSBooster"  ; This will be created first time through even w/o CTRLH
onedriveBoosterFilename := onedrive . "\CPRSBooster\CPRSData.txt"
onedrivelocalDot := onedrive . "\CPRSBooster\DotPhrases\"  ; This will be created first time through even w/o CTRLH
qopath := onedrive . "\CPRSBooster\QuickOrders\"
Global lastprompttype := "" ; for ambient dictation last note type tracking
dragonpath := "C:\Program Files (x86)\Nuance\Dragon Medical One 2023\SoD.exe"
dragonNotInstalled := 0 ; set to 1 if dragon not installed
handgraphicpath := "\\v23.med.va.gov\apps\GUI\Local_Site_GUI\MIN\CPRSBOOSTER\Pictures\Hand.png"
ListSITESBetaTesting :=  BoosterRoot . "CPRS_BoosterCVBETASites.txt"
Sta3nMapDir := BoosterRoot . "SharedDocs\sitecode.csv"
SiteCode := SubStr(A_UserName, 4, 3)

; --- Amb Scribe Pilot Participation Logic ---
AmbScribePilotParticipant := 0  ; Default to not participating

; Correct root path for config files
pilotConfigRoot := "\\v23.med.va.gov\apps\GUI\Local_Site_GUI\MIN\CPRSBOOSTER\ApplicationFiles\PilotSitesConfig\AmbientDictation\"
pilotUserFile := pilotConfigRoot . "AmbScribePilotUsers.txt"
pilotSiteFile := pilotConfigRoot . "AmbScribePilotSites.txt"

; Check if user is in pilot user file
FileRead, pilotUsers, %pilotUserFile%
if (InStr(pilotUsers,  A_UserName )) {
	AmbScribePilotParticipant := 1
}

; Check if site is in pilot site file (independent of user check)
FileRead, pilotSites, %pilotSiteFile%
if (InStr(pilotSites, SiteCode)) {
	AmbScribePilotParticipant := 1
}

; MsgBox, 262144, CPRS Booster, Pilot Participation: %AmbScribePilotParticipant%
gui56FirstOpen := 0 
RecordAfterEdit := false ; start with qoEditmode off
lastActiveCPRS := "" ; Global variable to store the last active CPRS window title
NationalShareAB := "https://dvagov-my.sharepoint.com/:t:/g/personal/adam_bock_va_gov/EUg81UPMAqNPnXOpOUicAAgBNoRak6zpq725vhR2mT_FEw?e=PzDiFB"



VoogleVideo :="https://dvagov-my.sharepoint.com/:v:/g/personal/adam_bock_va_gov/EfNi7PXdQNtPvutpsfkv10sBle9kNpX40rht_6ALjGpoBw?nav=eyJyZWZlcnJhbEluZm8iOnsicmVmZXJyYWxBcHAiOiJTdHJlYW1XZWJBcHAiLCJyZWZlcnJhbFZpZXciOiJTaGFyZURpYWxvZy1MaW5rIiwicmVmZXJyYWxBcHBQbGF0Zm9ybSI6IldlYiIsInJlZmVycmFsTW9kZSI6InZpZXcifX0%3D&e=ecx2ce"

; Vooglehelpdoc := "https://dvagov.sharepoint.com/:w:/s/CPRSBooster950/ESdN0yYDfZBApMdl7cGEQdwBlqRdXgcIoUW_gKATucfoYQ?e=wr0BYe"
Vooglehelpdoc := "\\v23.med.va.gov\apps\GUI\Local_Site_GUI\MIN\CPRSBOOSTER\SharedDocs\How to Use Voogle & Booster Together.docx"
;#######################################################################"#####################
;#########################paths for shortcut updater###############################################
;############################################################################################
desktopPath := A_Desktop "\CPRSBooster.lnk" 
oldPath := "\\v23.med.va.gov\apps\GUI\MIN\MIN_GUI\Auto\CPRSBooster.exe"
newPath := "\\v23.med.va.gov\apps\GUI\Local_Site_GUI\MIN\CPRSBOOSTER\CPRSBooster.exe"
newIconPath := "\\v23.med.va.gov\apps\GUI\Local_Site_GUI\MIN\CPRSBOOSTER\RocketIcon.ico"
gui55Hide := 0 ; default to 0 = not hidden = rx quick orders
OneTimeVoogleEducation := 0 ; start with assumption that Voogle education screens not seen. Loading data will change this prn.
OneTimeAddPCPEducation := 0 ; start with assumption that education screens not seen. Loading data will change this prn.
SiteSpecificDownKeysToMedOrderMenu := 0 ; start with assumption that we don't know # of down keys to med order menu
GotRxQOInstructions := 0 ; start with assumption that they haven't gotten instructions
;############################################################################################
;############################################################################################
;############################################################################################

; Add a global variable for toggling debugging
global debugging := false
qodebug := false   ; quick order debugging (Do NOT change: programmatically controlled)
Global Listening := false
Global hAnchorEdit
Global ADPrompts := {}  ; ambient dictation

;############################################################################################
;################### NURSING BOOSTER VARIABLES ##############################################
;############################################################################################
global NB_AppTitle := "Nursing Booster"
global NB_TemplateDir := onedrivelocal . "\NursingTemplates"
global NB_LogDir := onedrivelocal . "\NursingTemplates\Logs"
global NB_MacroDir := onedrivelocal . "\NursingTemplates\KeyMacros"
global NB_BoosterGuiVisible := 0
global NB_ApplySpeed := 300  ; ms delay after parent toggle (slider range 50-1000)
global NB_CPRSDetected := 0
global NB_HotkeyConfigPath := onedrivelocal . "\NursingTemplates\hotkey_buttons.json"
global NB_HK1_Label := "Quick 1"
global NB_HK1_Action := ""
global NB_HK2_Label := "Quick 2"
global NB_HK2_Action := ""
global NB_HK3_Label := "Quick 3"
global NB_HK3_Action := ""
global NB_HK4_Label := "Quick 4"
global NB_HK4_Action := ""
global NB_HK5_Label := "Quick 5"
global NB_HK5_Action := ""
global NB_MacroSteps := []
global NB_MacroBuilderOpen := 0
global NB_MacroKeepSteps := 0
global NB_Recording := 0
global NB_RecordedSteps := []
global NB_RecordLastKey := ""
global NB_RecordLastTime := 0
global NB_EditStepRow := 0

;################### CP FLOWSHEETS BOOSTER VARIABLES #########################################
;############################################################################################
global CF_AppTitle := "CP Flowsheets Booster"
global CF_TemplateDir := onedrivelocal . "\CPFSTemplates"
global CF_Detected := 0
global CF_SpyResults := []
global CF_AutoSave := 0

;****************AI Folder**************
AIPath := onedrivelocal . "\AI\"

	IfNotExist, %AIPath%
	{
		FileCreateDir, %AIPath%
		if ErrorLevel
		{
			MsgBox, 262144, CPRS Booster, Failed to create the 'AI' folder at: %AIPath%.
			Return
		}
	}

;------------------ Sync and Clean Up AI Prompts ------------------
MasterPromptFolder := "\\v23.med.va.gov\apps\GUI\Local_Site_GUI\MIN\CPRSBOOSTER\AIPrompts\"
DeletePromptFolder := MasterPromptFolder . "BoosterPromptsToDeleteFromUsers\"
UserPromptFolder := AIPath

; 1. Remove prompts marked for deletion
Loop, Files, %DeletePromptFolder%*.*, F
{
	fileName := A_LoopFileName
	userFile := UserPromptFolder . fileName
	if FileExist(userFile)
		FileDelete, %userFile%
}

; 2. Update user prompts from master folder
Loop, Files, %MasterPromptFolder%*.bstrAD, F
{
	fileName := A_LoopFileName
	masterFile := MasterPromptFolder . fileName
	userFile := UserPromptFolder . fileName

	; If user file doesn't exist, copy it
	if !FileExist(userFile)
	{
		FileCopy, %masterFile%, %userFile%, 1
	}
	else
	{
		; Compare file contents (or use FileGetTime for last modified)
		FileRead, masterContent, %masterFile%
		FileRead, userContent, %userFile%
		if (masterContent != userContent)
		{
			FileCopy, %masterFile%, %userFile%, 1
		}
	}
}
;------------------ End AI Prompt Sync/Cleanup ------------------



;************************ Dot phrase library variables *************
; Set the path to the Userprofile.txt file for library
UserFolderPath := OneDriveLocal . "\User\"
UserProfileFile := UserFolderPath . "Userprofile.txt"


NationalDPSharePoint := "https://dvagov.sharepoint.com/sites/vabstrlib/zz%20DO%20NOT%20TOUCH%20FILES%20BELOW/Forms/AllItems.aspx"


; Set the path to the  NATIONAL dotphrase folder:
			
; NationalLibDPFiles = C:\Users\%A_UserName%\Department of Veterans Affairs\BstrLib - zz DO NOT TOUCH FILES BELOW\    ; this is the national DP library
NationalLibDPFiles :=  userprofile . "\Department of Veterans Affairs\BstrLib - zz DO NOT TOUCH FILES BELOW\"    ; this is the national DP library


DPIpath := NationalLibDPFiles . "dotphraselibraryindex.txt"

; Set the path to the dotphraselibraryindex.txt file
IndexFile := DPIpath

;set path to sitelist of contributing sites for dot phrases in nat lib
Librarysitelistpath := NationalLibDPFiles . "SiteList-DoNOTTouch.txt"

; *********** variables regarding job types**************
ICCpath = \\v23.med.va.gov\apps\GUI\Local_Site_GUI\MIN\CPRSBOOSTER\DotPhraseLibrary\NationalRoles\ICCType.txt
emppath= \\v23.med.va.gov\apps\GUI\Local_Site_GUI\MIN\CPRSBOOSTER\DotPhraseLibrary\NationalRoles\EmployeeType.txt
global ExactRolepath := "\\v23.med.va.gov\apps\GUI\Local_Site_GUI\MIN\CPRSBOOSTER\DotPhraseLibrary\NationalRoles\exactroletype.txt"


;**********************************************************************






;QOLibraryRoot = C:\Users\%A_UserName%\OneDrive - Department of Veterans Affairs\Booster National Library - Quick Order Library\
QOLibraryRoot := onedrive . "\Booster National Library - Quick Order Library\"

; copy all config text files to new dir at time of exe tx

linktoNationalQOLib = https://dvagov.sharepoint.com/:f:/s/BoosterNationalLibrary/EnSuj6aTfqVBpqEhZ97MTWMB0DHSkVCqbQ08d7_8lac0jA?e=OGqw4N

LocalNationalQOpath = C:\Users\%A_UserName%\Department of Veterans Affairs\Booster National Library - Quick Order Library





 ;qorderpath = C:\Users\%A_UserName%\OneDrive - Department of Veterans Affairs\CPRSBooster\QuickOrders\*.bstrqo
qorderpath := onedrive . "\CPRSBooster\QuickOrders\*.bstrqo"


global suspenddp := 0 ; start with dotphrases on
global NoteFavsArray:= []


; THIS net loc is drive independent

netloc = %BoosterRoot%CPRSBooster.exe
; --***********these are the local and global log file names**********
; log is first written local and local is copied global


logfilename = U:\CPRSBooster\Log.txt  

globallogfilename = \\v23.med.va.gov\V23\VISN 23\Services\VISN_INFORMATICS\GlobalBoosterLog.txt
loggingon:= "no" ; change to no if you want to stop logging

;--- some of the variables declared here


FileVersion = %BoosterRoot%CPRS_BoosterCV.txt ; the txt file for version autoupdate

ctCprsWinLAST := 0
Deletenationalmsg := 0
newbie:=0
HBH:=0
HBV:=0
FBH:=0
FBV:=0
Global blue:=no
nevershortcut := 0
wemadeitpastStart:=0  ; this will pop up an error box if they try to press CTRL H during the should i start boxes (all drives not checkable then). 
		     ;   and want to launch CRPS (due to launch time delay) before drive check

skipAltN:=1 ; start off so Alt N is mapped by AHK.

global fxn:= []

; ----------------------------END INTIALIZE VARIABLES



SetTitleMatchMode, RegEx



;----------------------------------DETERMINE IF WE HAVE at least one active drive

driveactive := 0 ; set to zero

	IfNotExist, u:\  ; need to try to start U drive first.
			{
				try
				{
				run, u:\    
				winwait,(u:),,5
				sleep 1000
				winclose, (u:)
				}

			}



	IfExist, U:\   ; ********** Looks for U drive****
	{
	driveactive := 1 ; we've got a drive
	}
	
	if (getprocesses() =  1) ; ********looks for OneDrive
	{
	driveactive := 1 ; we've got a drive (actually this means the one drive APP is running: possible it's not registered to this comp)
	}
	


If (driveactive= 0)  ; *************we have NO working drives

{   ; start by trying to activate U drive ;*** WHY U first? (? b/c Citrix will never have OneDrive?)

		try
		{
		run, u:\    
		winwait,(u:),,7
		sleep 200
		winclose, (u:)
		}

			; ************check to see if U started
		
			IfExist, U:\   ; **************** Try U drive again after jump start attempt
			{
			driveactive := 1 ; we've got a drive ; Not sure this variables matters by this point
			}
			else ; ***********failed to start U drive, start working on onedrive
			{
			Gosub LookforOne
			}


} ; ***************end of attempt to activate at least one drive, starting with U drive (if that's active, don't care about OneDrive)



; **************************** end of drive determination


;----- make directory prn: in BOTH locations; what do we need this for now??




 try ; new as of 8-16-21
		
		{
			IfNotExist, u:\CPRSBooster
			{
			FileCreateDir, u:\CPRSBooster
			}
		}


	; Make onedrive dir prn:

	try
	{
		; IfNotExist, C:\Users\%A_UserName%\OneDrive - Department of Veterans Affairs\CPRSBooster
		IfNotExist, %onedrive%\CPRSBooster
		{
			; FileCreateDir, C:\Users\%A_UserName%\OneDrive - Department of Veterans Affairs\CPRSBooster
			FileCreateDir, %onedrive%\CPRSBooster
		}
	}
	
	; Make onedrive quick order
	
	try
	{
		; IfNotExist, C:\Users\%A_UserName%\OneDrive - Department of Veterans Affairs\CPRSBooster\QuickOrders
		IfNotExist, %onedrive%\CPRSBooster\QuickOrders
		{
			; FileCreateDir, C:\Users\%A_UserName%\OneDrive - Department of Veterans Affairs\CPRSBooster\QuickOrders
			FileCreateDir, %onedrive%\CPRSBooster\QuickOrders
		}
	}

	; Make NursingBooster template directory
	try
	{
		IfNotExist, %NB_TemplateDir%
		{
			FileCreateDir, %NB_TemplateDir%
		}
	}

	; Make NursingBooster log directory
	try
	{
		IfNotExist, %NB_LogDir%
		{
			FileCreateDir, %NB_LogDir%
		}
	}

	; Make NursingBooster key macro directory
	try
	{
		IfNotExist, %NB_MacroDir%
		{
			FileCreateDir, %NB_MacroDir%
		}
	}

	; Make CP Flowsheets template directory
	try
	{
		IfNotExist, %CF_TemplateDir%
		{
			FileCreateDir, %CF_TemplateDir%
		}
	}
; ------------------- END make directory prn


gosub refreshdata  ;---- this just reads LOADS ALL DATA at start of program (DRIVE CHECK IS DONE AS PART OF THIS)



;############################################################################################
;###################OneTime Load of Ambient dictation Default Prompts############################
;############################################################################################
; CANNOT put this above o/w will WRITE a blank data file (except for AmbDictationDone = 1) 
    if (AmbDictationDone != 1) && (AmbDictationDone != 2)
	{

		AmbdictationDone := 1
		gosub writeit
	
	}


; -----------------start opening CPRS b/c that takes forever ; had to move this down b/c of need to load dragonload? variable
;############################################################################################
;##########################Start CPRS########################################
;############################################################################################

SetTitleMatchMode, 2



; Main logic to check for CPRS window and text
If WinExist("CPRS")
{
    ; Retrieve the list of all windows with "CPRS" in the title
    WinGet, cprsWindowList, List, CPRS
    found := false
    Loop, %cprsWindowList%
    {
        this_id := cprsWindowList%A_Index%
        WinGetText, windowText, ahk_id %this_id%
        if InStr(windowText, "PDMP Query")
        {
            found := true
            break
        }
    }

    if !found
    {
        ShowCPRSMessageBox()
    }
}
else
{
    ShowCPRSMessageBox()
}



; Function to show the message box and handle the response from ABOVE
ShowCPRSMessageBox()
{
    MsgBox, 4, CPRS Booster Started, SHOULD I START CPRS FOR YOU? `n`n ( Or you can do it later: Alt-C ) `n`n Remember: CTRL-H for HELP and SETUP, 15
    IfMsgBox, Yes
    {
        gosub, !c
    }
}


SplashTextOn ,350 ,150, CPRS Booster Started, You are CPRS Boosted! `n`n Remember: CTRL-H for HELP and SETUP
sleep 1500
SplashTextOff





/*

If !WinExist("CPRS")
{
MsgBox, 4,CPRS Booster Started, SHOULD I START CPRS FOR YOU? `n`n ( Or you can do it later: Alt-C ) `n`n Remember: CTRL-H for HELP and SETUP, 15

	IfMsgBox, Yes

	{
	gosub, !c
	}

}
Else
{
SplashTextOn ,350 ,150, CPRS Booster Started, You are CPRS Boosted! `n`n Remember: CTRL-H for HELP and SETUP
sleep 1500
SplashTextOff

; /*
 gosub dragon  ; THIS starts dragon (IF not running) even if CPRS is running at booster launch
 if westartedDragon = 1
 {
 gosub FindDragonWindow1 ; same as above comments 
 }
 ; */
 
}

*/

;############################################################################################
;#########################Try Closing U drive window (not the drive itself) if open###############
;############################################################################################
; need to do this here b/c if we needed to start U drive we get window open and takes a while to open
; didn't want to hold up execution just for this step so put after other stuff.
		try
		{
		sleep 1000
		winclose, (u:)
		}

;############################################################################################
;############################################################################################
;############################################################################################




wemadeitpastStart:=1

SetTitleMatchMode, RegEx
;-------------------------end CPRS opening



;---------------------************start check to see if this is a newbie

fileexists := 0 ; set to 0

filename = u:\CPRSBooster\CPRSData.txt ; U drive file

if FileExist(filename)
{
fileexists := 1
}


filename := onedriveBoosterFilename

if FileExist(filename)
{
fileexists := 1
}


If (fileexists = 0)
{

newbie:=1

;Gosub, ^H
 MsgBox,0,CPRS Booster: WELCOME!, CPRS Booster needs to be set up. Press Ctrl-H now (yep now) for the help/setup screen. Remember the command Ctrl-H: H for HELP. `n `n ***Recommend Watching Video Tutorial on Ctrl-H screen***
}

gosub BoosterDotPhraser
;############################################################################################
;#####################Start SHORTCUT MAKER/Updater###################################################
;############################################################################################

; Ensure the icon is available locally
localIconPath := onedrivelocal . "\RocketIcon.ico"
if !FileExist(localIconPath) {
    try {
        FileCopy, %newIconPath%, %localIconPath%, 1
    } catch e {
        ; MsgBox, Failed to copy icon locally. Error: %e%
    }
}

shortcutIconPath := localIconPath

; Check if the shortcut exists
if (FileExist(desktopPath)) {
    shortcut := ComObjCreate("WScript.Shell").CreateShortcut(desktopPath)
    needsUpdate := false
    ; Check if target path is old, update to new
    if (shortcut.TargetPath = oldPath) {
        shortcut.TargetPath := newPath
        needsUpdate := true
    }
    ; Check if icon path is not local, update to local
    if (shortcut.IconLocation != shortcutIconPath) {
        shortcut.IconLocation := shortcutIconPath
        needsUpdate := true
    }
    if (needsUpdate) {
        shortcut.Save()
        ; MsgBox, Shortcut updated to new path and/or icon.
    }
    ; else {
    ;   MsgBox, Shortcut already points to the new location and icon.
    ; }
} else {
    ; Create a new shortcut if none exists
    try {
        shortcut := ComObjCreate("WScript.Shell").CreateShortcut(desktopPath)
        shortcut.TargetPath := newPath
        shortcut.IconLocation := shortcutIconPath
        shortcut.Save()
        MsgBox, 262144, CPRS Booster, A Booster shortcut was placed on your desktop
    } catch e {
       ;  MsgBox, Failed to create a new shortcut. Error: %e%
    }
}

;############################################################################################
;######################END SHORTCUT MAKE#############################################
;############################################################################################

;-----------------------------------------*************Version update check
; We actually still need section below after new packaging (disabled at left click section)


if CurVersion = %version%  ;-----Don't display new version info if version same
{
;msgbox, same version
;msgbox, %newbie%
newbie:= 0
}
else

{
;msgbox, %newbie%

if newbie = 0 ;----newbie is set to 1 if user is newbie
	{
	
	gosub getvisn ; ALSO gets site code; what's this for?
	gosub Linkversion ;---- FIRST time users: skip version update screen
 

			if (AutoDragon<> 1) && (AutoDragon <> 0) ; if the autodragon value in file is null: set it at next version change
			{
			WinWaitClose, CPRS BOOSTER New Version,, 30
			MsgBox, 262148, CPRS Booster & Dragon, Should Booster Always Start Dragon with CPRS Starts?`n`n (You can change this in the future via Ctrl-H--->settings)`n`n Click No if you don't know what Dragon is...

			IfMsgBox Yes
			AutoDragon:=1
			else
			AutoDragon:=0
			}
	}
gosub, writeit  ; ---need to refresh version number stored in the file so we don't show this again.
				; ---THIS line can write blank stuff sometimes

}
;--------------------------------------------End version new window pop up

; ----*********************** COPY the local LOG global on setup IF logging on

; msgbox, %loggingon%
 	if (loggingon = "yes") ; ---Varible at top of program can disable logging
	{

	if FileExist(globallogfilename)
	{
	
		Loop, read, %logfilename%, %globallogfilename%
		{
    
      		  FileAppend, %A_LoopReadLine%`n
		  if (errorlevel = 0)
			{
			Deletelocal = yes ; if successful then we will delete the local log (wipe)
			}
		}


		if (Deletelocal:= "yes") ; ---if copy to global was successfull then delete local log
		{   
		Filedelete, %logfilename%
		}
	
	} ; end if global file exists	

	
	} ;---- END of if logginon = yes 

;----------------***********end copy log to global



; gosub BoosterDotPhraser ; duplicate I think

WinGetPos , X0, Y0, Width0, Height0, CPRS ; starting positions of CPRS prior to anything 

;############################################################################################
;############################WINDOW MONITORING TIMER################################################
;############################################################################################

;  deactivate this for now---SetTimer, MonitorForSpecificWindows, 1000

; --- Load hotkey button config ---
gosub NB_LoadHotkeyConfig

; --- NursingBooster: Build floating panel (Gui 67) ---
Gui, 67:Destroy
Gui, 67:Color, 1a1a2e
Gui, 67:Font, s9 cWhite, Segoe UI
Gui, 67:Add, Text, x5 y4 w370 h20 Center BackgroundTrans vNB_PanelTitle gNB_DragPanel, Nursing Booster  |  Ctrl+Shift+B to toggle
Gui, 67:Font, s8 cBlack, Segoe UI
Gui, 67:Add, Button, x5   y28 w75 h26 gNB_PanelSave, Save Tpl
Gui, 67:Add, Button, x83  y28 w75 h26 gNB_PanelLoad, Load Tpl
Gui, 67:Add, Button, x161 y28 w80 h26 gNB_PanelDelete, Delete Tpl
Gui, 67:Add, Button, x244 y28 w70 h26 gNB_PanelDump, Dump
Gui, 67:Add, Button, x317 y28 w63 h26 gNB_PanelSettings, Settings
Gui, 67:Add, Button, x5   y58 w115 h26 gNB_PanelBuildMacro, Build Key Macro
Gui, 67:Add, Button, x125 y58 w115 h26 gNB_PanelPlayMacro, Play Key Macro
Gui, 67:Add, Button, x245 y58 w130 h26 gNB_PanelRecordMacro, Record Macro
Gui, 67:Font, s7 c00BFFF, Segoe UI
Gui, 67:Add, Text, x5 y88 w370 h16 Center BackgroundTrans, --- CP Flowsheets ---
Gui, 67:Font, s8 cBlack, Segoe UI
Gui, 67:Add, Button, x5   y106 w75 h26 gCF_PanelSpy, CPFS Spy
Gui, 67:Add, Button, x83  y106 w75 h26 gCF_PanelSave, CPFS Save
Gui, 67:Add, Button, x161 y106 w75 h26 gCF_PanelLoad, CPFS Load
Gui, 67:Add, Button, x239 y106 w75 h26 gCF_PanelDelete, CPFS Del
Gui, 67:Font, s7 cRed, Segoe UI
Gui, 67:Add, Checkbox, x320 y110 w60 h18 vCF_AutoSaveChk gCF_ToggleAutoSave, AutoSave
Gui, 67:Font, s7 cFFD700, Segoe UI
Gui, 67:Add, Text, x5 y136 w370 h16 Center BackgroundTrans, --- Quick Actions ---
Gui, 67:Font, s7 cBlack, Segoe UI
Gui, 67:Add, Button, x5   y153 w68 h24 gNB_HK1_Run vNB_HK1_Btn, %NB_HK1_Label%
Gui, 67:Add, Button, x76  y153 w68 h24 gNB_HK2_Run vNB_HK2_Btn, %NB_HK2_Label%
Gui, 67:Add, Button, x147 y153 w68 h24 gNB_HK3_Run vNB_HK3_Btn, %NB_HK3_Label%
Gui, 67:Add, Button, x218 y153 w68 h24 gNB_HK4_Run vNB_HK4_Btn, %NB_HK4_Label%
Gui, 67:Add, Button, x289 y153 w68 h24 gNB_HK5_Run vNB_HK5_Btn, %NB_HK5_Label%
Gui, 67:Add, Button, x360 y153 w20 h24 gNB_HK_Setup, ...
Gui, 67:Font, s7 cSilver, Segoe UI
Gui, 67:Add, Text, x5 y181 w370 h16 Center BackgroundTrans vNB_PanelStatus, Ready | CPRS: Not detected | CPFS: Not detected
Gui, 67:+AlwaysOnTop -Caption +ToolWindow +HwndNB_PanelHwnd
Gui, 67:Show, x0 y0 w385 h202 Hide, NursingBoosterPanel
NB_BoosterGuiVisible := 0
NB_SettingsVisible := 0

; --- NursingBooster: Build Settings panel (Gui 73) ---
Gui, 73:Destroy
Gui, 73:Color, 1a1a2e
Gui, 73:Font, s9 cWhite, Segoe UI
Gui, 73:Add, Text, x5 y4 w250 h20 Center BackgroundTrans, Nursing Booster Settings
Gui, 73:Font, s7 c00FF88, Segoe UI
Gui, 73:Add, Text, x10 y30 w80 h16 BackgroundTrans, Apply Speed:
Gui, 73:Add, Slider, x90 y28 w140 h22 vNB_SpeedSlider gNB_SpeedSliderChanged Range50-1000 TickInterval100 ToolTip, %NB_ApplySpeed%
Gui, 73:Add, Text, x235 y30 w50 h16 BackgroundTrans vNB_SpeedLabel, %NB_ApplySpeed% ms
Gui, 73:+AlwaysOnTop +ToolWindow -MinimizeBox
Gui, 73:Show, x400 y0 w290 h58 Hide, NB Settings

; --- NursingBooster: Start CPRS detection timer ---
SetTimer, NB_CheckCPRS, 3000

return



;---------------------ANY INITIALIZING CODE (autoexecute) MUST BE ABOVE HERE


;############################################################################################
;###################DEBUGGER Toggle#############################################
;############################################################################################

^+!R:: ; Ctrl+Alt+Shift+R
{
    if (debugging) {
		SplashTextOn ,150 ,100, CPRS Booster, Debugging is now OFF
		sleep 2500
		SplashTextOff
        ; MsgBox, 64, Debugging Toggled, Debugging is now OFF
        debugging := false
    } else {
		SplashTextOn ,150 ,100, CPRS Booster, Debugging is now ON
		sleep 2500
		SplashTextOff

        debugging := true
    }
    return
}

;############################################################################################
;################start testing area###########################################
;############################################################################################



/*  ; BETA must activate

^t::
	; when done the orders may not show up with flags.
	send !v
	sleep 50
	send C  ; for custom
	sleep 50
	send {pgup 2}
	sleep 50
	send {pgdn}
	sleep 50
	send {tab}
	sleep 50
	send {pgup 2}
	sleep 50
	send {down}
	sleep 50
		send {enter}
	sleep 500
return

*/   ; BETA must activate
;############################################################################################
;##################end testing area###########################################
;############################################################################################


; SetTitleMatchMode, 2 we want regex
^F5::reload
!F5::pause
loopvar = 0

;############################################################################################
;########################Detect Right Mouse Button click for Quick Order edits########################################
;############################################################################################

~RButton Up::

gosub BrillChk  ; pause for Brillians prn


IfWinActive, BstrLib - zz DO NOT TOUCH FILES BELOW
{
sleep 300
send {esc 3}
sleep 100
MsgBox, 262144, CPRS Booster: STOP, STOP!!! DO NOT DELETE OR MODIFY this in any way: you will damage the national dot phrase library for the entire country... Please leave this as is. Thank you!
}

if (rtclicktracker = 1)
{
MouseGetPos, MouseX, MouseY, MouseWin, ButtonNum

; Index := SubStr(ButtonNum, 7) 
qoindex:= SubStr(ButtonNum, 7) 
gosub gui30


}

return


;############################################################################################
;#####################Subroutine to hold last active CPRS window title##############################################
;############################################################################################

SaveLastActiveCPRSWindow:
    IfWinActive, ahk_exe CPRS
    {
        WinGetTitle, lastActiveCPRS, A ; A means the current active window
    }
return

;############################################################################################
;##########################End last active subroutine#######################################
;############################################################################################




;############################################################################################
;##########subroutine to reactivate CPRS but NOT lead to window stacking order problems#########
;############################################################################################


ActivateCPRS:



; Initialize an empty object to store window handles (HWNDs)
idList := Object()
windowCount := 0
windowTitles := "" ; String to store window titles for display

; Loop through all windows
WinGet, windows, List
Loop, %windows%
{
    hwnd := windows%A_Index% ; Get the handle of each window
    WinGet, process, ProcessName, ahk_id %hwnd% ; Get the process name of the window

    ; Exclude the script itself when it's compiled into an executable
    ; Check if the process name is the same as the script's executable name
    if (process = A_ScriptName)
	{
		; MsgBox, 262144, CPRS Booster, Detected Booster: %process%  
        continue ; skip this loop = don't count Booster windows

	}
    ; Check if the process name starts with 'CPRS'
    if (InStr(process, "CPRS"))
    {
        windowCount++
        idList[windowCount] := hwnd ; Store the handle in the object
        WinGetTitle, title, ahk_id %hwnd% ; Get the window title
        windowTitles .= title . "`n" ; Append the title to the string
		; MsgBox, 262144, CPRS Booster, Process: %process%`n Window: %title% ;
    }
}

; Now idList contains all CPRS window handles and windowCount is the total count
; Displaying window count and titles  
; SplashTextOn, 400, 300, CPRS Booster, Win Count: %windowCount%`nWindow Titles:`n%windowTitles%
; Sleep 4000
; SplashTextOff

if (windowCount > 2) ; don't know why it's 2 when only 1 screen open but this works to set to > 2
{
    windowFound := false
    for index, hwnd in idList
    {
        WinGetTitle, title, ahk_id %hwnd%
        if (title = lastActiveCPRS && lastActiveCPRS != "")
        {
            
			/*
			; Displaying the active window 
            SplashTextOn, 150, 100, CPRS Booster, Activating LAST BABY WIN `n %lastActiveCPRS%
            Sleep 1500
            SplashTextOff
			*/

            WinActivate, ahk_id %hwnd%
            windowFound := true
            break
        }
    }
    if (!windowFound) ; If the saved window wasn't found, activate the first non-"Vista Cprs in use by" window
    {
        for index, hwnd in idList
        {
            WinGetTitle, title, ahk_id %hwnd%
            if (!InStr(title, "Vista Cprs in use by"))
            {
                /*
				; Displaying the fallback window 
                SplashTextOn, 150, 100, CPRS Booster, LITTLE WIN ACTIVATE
                Sleep 1500
                SplashTextOff
				*/
                WinActivate, ahk_id %hwnd%
                break
            }
        }
    }
}
else if (windowCount = 2) ; If only one window, activate it
{
    ; WinActivate, ahk_id %idList1%
	Winactivate, VistA CPRS in use by
	
	/*
    ; Displaying single window activation 
    SplashTextOn, 150, 100, CPRS Booster, Activating One WIN: Vista CPRS in use
    Sleep 1500
    SplashTextOff
	*/
}



return
;############################################################################################
;#################################END ACTIVATE CPRS###########################################################
;############################################################################################






;############################################################################################
;################START LOGIC LEFT MOUSE CLICK & CHECK TO SEE IF TOOLBARS SHOULD BE ACTIVE##################
;############################################################################################


; WinGetPos , X0, Y0, Width0, Height0, CPRS ; starting positions of CPRS prior to anything 





;-------v77-------below EXCEPT FOR  FIRST LINE = NEW = need for site location to not freeze


#IfWinNotActive, WELCOME TO THE BOOSTER NATIONAL DOT PHRASE LIBRARY 


~LButton Up::
keywait LButton

gosub BrillChk  ; pause for Brillians prn

;SplashTextOn ,150 ,100, CPRS Booster, Click# %versionLoop%
;sleep 600
;SplashTextOff
;############################################################################################
;#########################Voogle Booster helper: toggle on/off prn###########################################
;############################################################################################

/*



if !(winactive("Voogle and")) && !(winactive("Voogle - Work")) ; HIDE BoosterVoogle Gui unless voog is openwhat if Voogle is active window when Booster is launched?? problem
{

		if (winactive("Booster Helper"))
		{
		return ; we're already using Booster helper when Voogle is active window
		}
		else
		{
		Gui, 45: HIDE  ; this is hiding the Booster helper when you click on it.
		}
}
else
{
Gui, 45: Show
gosub ActivateVoogle ; get focus back on voogle window ; without this, next click on booster -> helper--> voogle ;;; THIS line is interferoing with mouse use on voogle. Can't minimize
return ; stop click check if we are in voogle
}

*/
;############################################################################################
;#################Once per Booster load: BACKUP all Booster data for everyone####################
;############################################################################################



if (versionLoop = 100)   ;  click: RUN THE DATA BACKUP Program for the day; FOR EVERYONE; LOGIC WILL ONLY RUN ONCE A DAY
	{
	 ;; BE CAREFUL OF CHANGING LOOP NUMBERS VS VERSION CHECK LOOP #s and resetting loop counter in logic below
		try{

			;; BETA** Must remove msgbox below
			;;MsgBox, 262144, Booster Troubleshooting, ABOUT TO START DOT PHASE BACKUP

			run, \\v23.med.va.gov\apps\GUI\Local_Site_GUI\MIN\CPRSBOOSTER\BACKUP USER Data\CPRSBooster_BackupRoutine.exe
			}
		versionLoop++  
	}



;############################################################################################
;#############FOR ME ONLY: BACK UP NATIONAL LIBRARY############################################################
;############################################################################################




	if (A_UserName = "VHAMINBOCKA") && (versionLoop = 50)   ; run Nat Libr Backup for me only
	{
	
	
	;run, C:\Users\VHAMINBockA\OneDrive - Department of Veterans Affairs\AHK code\National Dot Phrase Library\BACKupLogic\DP Backup Nat Lib.ahk
	; run, C:\Users\VHAMINBockA\OneDrive - Department of Veterans Affairs\AHK code\National Dot Phrase Library\Cleanup\MASTERNatLibCLeanUpScript.ahk
	; versionLoop++   10-9-24 move this below and outside of IF
	}


;############################################################################################
;#################For anyone <> me AND <> BETA: check version############################################
;############################################################################################

/* Disable Version checking: not needed with new packaging


 IfnotInString, A_ScriptName, beta  ; if we are running a beta script, skip version check b/c that will take beta folks back to production version.

{

	if (versionLoop = 201)   ; Version check q X# of clicks
			{
					if (A_UserName != "VHAMINBOCKA")  ; Don't do a version update for me
					{

					;;BETA** Must remove msgbox below
					;;MsgBox, 262144, Booster Troubleshooting, ABOUT TO START VERSION CHECK



					GoSub, CheckVersion
					
					}
			}
	
}

versionLoop++


if (versionLoop>2500)  ; resert the counter q 2500 clicks
{
	;;BETA** Must remove msgbox below
	;;MsgBox, 262144, Booster Troubleshooting, RESETTING VERSION COUNTER

	versionLoop := 0
}

*/
;############################################################################################
;####################END VERSION CHECK########################################
;############################################################################################
versionLoop++ ; put this outside the commented out stuff above



if winexist("Consult Toolbox")
{

; msgbox here
 return

}

sleep 50

if (winactive("fxnbar") || winactive("hyperdrivebar") || winactive("Booster Quick Orders") || winactive("Ambient Scribe Toolbar") || winactive("Booster Dictation Box") || winactive("NursingBoosterPanel"))  ; if any of these are active, don't do anything
{


; THIS PREVENTS HIDING OF BOOSTER GUIs WHEN YOU CLICK ON BOOSTER GUIs
return
}


; TRACK LAST ACTIVE CPRS WINDOW Before messing w/Booster toolbars

gosub SaveLastActiveCPRSWindow   ; in this case: it will hold last CLICKED on active; ? we want that



if !winactive("ahk_exe CPRS")  ; if mouse is clicked and CPRS no longer the active window: destroy help bar ; WHY doesn't this destroy helpbar when you click on help bar? (b/c of logic immediately above)
{
; COULD check bar on status here b/c often prob repeatedly destroying things not there.
Gui 14: Destroy
gui 7: destroy    ;Destroy
gui 8: destroy
gui 28: destroy  ;Destroy
barOn := 0
lastwin:= "notCPRS"

WinGetPos, X0, Y0, Width0, Height0, CPRS ; store current state as OLD state before return
; timelast:=A_Now ; set time of end of this click processing before return


return
}

; -------------If we're here: CPRS is active and there has been a mouse click




WinGetPos , X2, Y2, Width2, Height2, VistA CPRS
; WinGet, IsMax, MinMax , ahk_exe CPRSChart.exe

sleep 100 ; This delay fixes the problem of line below showing maxed when just minimized

WinGet, IsMax, MinMax , ahk_exe CPRS   ; this version will work for CPRS launched from CPRS launcher ; this will show still maxed if Just minimized


 If (X2=X0 and Y2=Y0 and Width2=Width0) and (lastwin = "isCPRS")

{

	if (IsMax = 1) ; We are here if SAME + last window was CPRS AND it is maxed
	{
	
		If (barOn = 0)
		{
		; SplashTextOn ,300 ,100, CPRS Booster HERE, redrawing  
		;  sleep 400
		;  SplashTextOff

				if (paintedToolbarsyet = 0)
				{
				gosub !+z ; hyperdrive bar ; top nav
				gosub !+h ; floating bar ; function key list
				gosub quickorder ; THis is basically calling the same as GUI 28 (turned off currently)
				paintedToolbarsyet := 1
				}
				else  ; I'm NOT sure these two (above/below) are any different....??
				{
				gosub yellow ; this is GUI 7 (top)which is also called by !+z; yellow just bypasses logic 
								; that if already painted, skip it. Also !+z calls gui 8 as part of it.
				gosub gui8
				gosub !+h ; floating bar ; function key list
				; ; ; GUi 28: show
				}
				
			gosub ActivateCPRS ; hopefully this solves both issue of focus on CPRS but not subscreen
			
 	; 	winactivate, VistA ; need this b/c creating GUI takes focus off CPRS. THIS IS CAUSING PROBS with TEMPLATES  & ? CONSULTS
	; REVERT TO HIDDEN 11-13-23	gosub ActivateCPRS in use by; added above gosub
		
		}	
	barOn := 1 
	}
	else  ; this happens with CPRS minimization(?); Verified to happen with toggle to non-CPRS window
	{
	 ; Gui 14: Destroy ;**this is the problemed area****
	; Gui 7: Destroy
	
	; barOn := 0

	/*
	SplashTextOn ,300 ,100, CPRS Booster, SAME %X2%, %Y2%
	sleep 400
	SplashTextOff
	SplashTextOn ,300 ,100, CPRS Booster, %IsMax%
	sleep 400
	SplashTextOff
	*/


	
	}

	
}
 
else  ; CPRS WINDOW MOVED; OR this seems to come with toggle with another NonCPRS window (?)
 {

	; SplashTextOn ,300 ,100, CPRS Booster, MOVED
	; sleep 400
	; SplashTextOff
	; SplashTextOn ,300 ,100, CPRS Booster, %IsMax%
	; sleep 400
	; SplashTextOff
	; if (IsMax ="")
	; {
	; msgbox, blank
	; 
	; }

	if (IsMax = 0)  ;  CPRS moved ; Get GUI off a non min non max screen
	{
	Gui 14: Destroy
	gui 7: destroy ;Destroy
	gui 8: destroy
	;  gui 28: hide ;Destroy
	
	barOn := 0
	}

	if (IsMax = 1) ; CPRS MOVED and IS MAXED (don't know if this happens: does on change b/t apps)
	{


		If (A_TimeSincePriorHotkey<400) and (A_PriorHotkey="~LButton Up") ; don't think this line ever triggers


		{
		
		; SplashTextOn ,300 ,100, CPRS Booster, You Double clicked
		; sleep 400
		;  SplashTextOff
		}

		else
	 	{
		;  SplashTextOn ,300 ,100, CPRS Booster, redrawing  

		sleep 400
		 SplashTextOff

		Gui 14: Destroy ; destroy old and make new
		gui 7: destroy ;Destroy
		gui 8: destroy
		gui 28: Destroy
		
		
	  if (paintedToolbarsyet = 0)
		{
		gosub !+h ; floating bar
		gosub !+z ; hyperdrive bar
		gosub quickorder
		paintedToolbarsyet := 1
		}
		else
		{                                                              
		
		gosub yellow
		gosub gui8
		gosub !+h 
		; ; GUi 28: show
		}
		
		gosub ActivateCPRS ; hopefully this solves both issue of focus on CPRS but not subscreen
		
		;  11-22-23: d/c this line...gosub ActivateCPRS in use by ; need this b/c creating GUI takes focus off CPRS.
		; LINE ABOVE IS CAUSING PROBLEMS with pulling Big cprs infront; removal causing charles prob with CPRS not active during f1 med renewal red flag
		
		barOn := 1
		}
	}

 }

WinGetPos, X0, Y0, Width0, Height0, VistA CPRS ; store current state as OLD state before return
lastwin:= "isCPRS" ; reset this. We wouldn't have gotten to this point if CPRS not active
; timelast:=A_Now ; set time of end of this click processing before return



return

;############################################################################################
;#############################END OF LEFT CLICK ANALYSIS#######################################
;############################################################################################


;-------------------



;############################################################################################
;###############DESTROYS AND RECREATES TOOLBARS and GUI quick orders############################################################
;############################NOT USING CURRENTLY################################################################
newtoolbars:


		Gui 14: Destroy ; destroy old and make new
		Gui 7: Destroy
		Gui 28: Destroy
		Gui 8: Destroy


		gosub !+h ; floating bar
		gosub !+z ; hyperdrive bar
		gosub quickorder


return

;############################################################################################
;############################################################################################
;############################################################################################




;############################################################################################
;###############FUNCTION Key tool bar (bottom)######################################
;############################################################################################


!+h::


if (FBO = 1)
{
return
}

WinGet, IsMax, MinMax , VistA CPRS

if (IsMax = 1) ; only build the gui on maxed CPRS


{


; Win_Hwnd := WinExist("ahk_exe CPRSChart.exe")

Win_Hwnd := WinExist("ahk_exe CPRS") ; this version should work with launcher

WinGetPos, X0, Y0, Width0, Height0, VistA CPRS


if FBH is not number ; null or text
{
FBH:=0
}

if FBV is not number ; null
{
FBV:=0
}

 newX := X0+(Width0-(.96*Width0))+FBH   ; negative number moves to the left (X gets smaller) ; 0.93
 newY := Y0+Height0-(.03*Height0)-FBV  ; negative number moves down (Y gets bigger)


  but1Len := strlen(notetitle1)
  
			  if (but1Len > 4)
			  {
			  shortnotetitle1 := StrReplace(notetitle1, "note","" )
			  button1label := substr(shortnotetitle1, -12)
			  button1label := "..." . button1label
			  StringLower, button1label, button1label
			  }
			  else
			  {
			  button1label := "Click Me!"
			  }
			  
  but2Len := strlen(notetitle2)
  
			 if (but2Len > 4)
			  {
			  shortnotetitle2 := StrReplace(notetitle2, "note","" )
			  button2label := substr(shortnotetitle2, -12)
			  button2label := "..." . button2label
			  StringLower, button2label, button2label
			  }
			  else
			  {
			  button2label := "Click Me!"
			  }

Gui 14: Destroy
Gui 14: Color, F0F0F0
Gui 14: Font, s9 cblack, Verdana
Gui 14: Margin, 0,0

global sx1 := shorten(fxn.1)
sx2 := shorten(fxn.2)
sx3 := shorten(fxn.3)
sx4 := shorten(fxn.4)
sx5 := shorten(fxn.5)
sx6 := shorten(fxn.6)
sx7 := shorten(fxn.7)
sx8 := shorten(fxn.8)
sx9 := shorten(fxn.9)
sx10 := shorten(fxn.10)
sx11 := shorten(fxn.11)
sx12 := shorten(fxn.12)



Gui, 14: Margin, 8
Gui 14: Font, s8 cblack, Verdana
Gui 14: Add, Text,y4, Booster:  ;   F1(%sx1%)   F2(%sx2%)   F3(%sx3%)   F4(%sx4%)   F5(%sx5%)   F6(%sx6%)   F7(%sx7%)   F8(%sx8%)   F9(%sx9%)   F10(%sx10%)   F11(%sx11%)   F12(%sx12%) 

Gui, 14:Add, Button, gF1 x60 y0  h20 -Tabstop, F1(%sx1%)
Gui, 14:Add, Button, gF2 y0  h20 -Tabstop, F2(%sx2%)
Gui, 14:Add, Button, gF3 y0  h20 -Tabstop, F3(%sx3%)
Gui, 14:Add, Button, gF4 y0  h20 -Tabstop, F4(%sx4%)
Gui, 14:Add, Button, gF5 y0  h20 -Tabstop, F5(%sx5%)
Gui, 14:Add, Button, gF6 y0  h20 -Tabstop, F6(%sx6%)
Gui, 14:Add, Button, gF7 y0  h20 -Tabstop, F7(%sx7%)
Gui, 14:Add, Button, gF8 y0  h20 -Tabstop, F8(%sx8%)
Gui, 14:Add, Button, gF9 y0  h20 -Tabstop, F9(%sx9%)
Gui, 14:Add, Button, gF10 y0  h20 -Tabstop, F10(%sx10%)
Gui, 14:Add, Button, gF11 y0  h20 -Tabstop, F11(%sx11%)
Gui, 14:Add, Button, gF12 y0  h20 -Tabstop, F12(%sx12%)
Gui 14: Font, s7 cblack, Verdana


Gui, 14:Add, Button, gNoteButton1 y0  h20 -Tabstop, %button1label%
Gui, 14:Add, Button, gNoteButton2 y0  h20 -Tabstop, %button2label%

;  if any fields below are null we have a problem

modnotelist := "   New Notes   ||  |EDIT LIST BELOW:|   CLICK HERE|  | "  .  notetitle6  .  "| "  .  notetitle5  .  "| "  .  notetitle4  .  "| "  .  notetitle3  .  "| "  .  notetitle2  . "| "  . notetitle1 .  "| " 




gui, 14: Add, DropdownList, gdropdownbutton y0 w100 -Tabstop altsubmit vnotefornow , %modnotelist%

; --- NursingBooster Dropdown Menu on toolbar ---
NB_MenuList := "Nursing Booster||" . NB_HK1_Label . "|" . NB_HK2_Label . "|" . NB_HK3_Label . "|" . NB_HK4_Label . "|" . NB_HK5_Label . "|Save Template|Load Template|Delete Template|Toggle Panel|Build Key Macro|Play Key Macro|Record Macro|Settings"
gui, 14: Add, DropdownList, gNB_DropdownAction y0 w130 -Tabstop altsubmit vNB_DropdownChoice , %NB_MenuList%

; Gui 14: +AlwaysOnTop -Caption HWNDGui_Hwnd  +ToolWindow ;   +LastFound

 Gui, 14: +AlwaysOnTop -Caption +ToolWindow +Owner

	try 
	{
	Gui 14: Show, %  " h21 x" newX  " y" newY ,fxnbar   ; Position on Gui Parent

	}
	catch e
	{
	;  MsgBox, 262144, CPRS Booster floating bar error,  %newX% %newY%

	Gui 14: Destroy
	}


}


return  ; END of floating bar logic



;############################################################################################
;#################Note button 1 & 2 config#############################################
;############################################################################################

notebutton1:


			  if (strlen(NoteFavsArray[1]) < 4)    ; never been through set 
			  {

			
						SplashTextOn ,150 ,100, CPRS Booster, You've Clicked on QUICK NOTE BUTTON #1
						sleep 3000
						SplashTextOff
						goto notesetupinfo
						
						
							IfMsgBox, Cancel
								{
								return
								}
						
						
								
						
			  }
			  else if (strlen(notetitle1) < 4)  ; been through set up b4 BUT currently unassigned
				  {
				  
				  SplashTextOn ,150 ,100, CPRS Booster, Let's assign a note title to this button (Quick Button #1)!
					sleep 3000
					SplashTextOff
					gosub autonote
				  
				  }
				  
			  else   ; button is mapped
				{  
					  gosub !1 
					  
			   }



return



notebutton2:


			  if (strlen(NoteFavsArray[1]) < 4)    ; never been through set 
			  {

			
						SplashTextOn ,150 ,100, CPRS Booster, You've Clicked on QUICK NOTE BUTTON #2
						sleep 3000
						SplashTextOff
						goto notesetupinfo
						
						
							IfMsgBox, Cancel
								{
								return
								}
						
						
								
						
			  }
			  else if (strlen(notetitle2) < 4)  ; been through set up b4 BUT currently unassigned
				  {
				  
				  SplashTextOn ,150 ,100, CPRS Booster, Let's assign a note title to this button (Quick Button #2)!
					sleep 3000
					SplashTextOff
					gosub autonote
				  
				  }
				  
			  else   ; button is mapped
				{  
					  gosub !2
					  
			   }



return




;############################################################################################
;###################drop down notes config#################################################
;############################################################################################


dropdownbutton:

 ; Use GUIControl command to get the selected position in the dropdown
 
 GuiControlGet, selectedPosition ,, notefornow, Value
 
 if (selectedPosition = 12) ; blank space at bottom
 {
 return
 }
 
 if (selectedPosition = 3 || selectedPosition = 4)
 {
 goto, starttitlemap
 }
 
selectedPosition := 12 - selectedPosition

refreshnotes := "|" . modnotelist
GuiControl,, notefornow , %refreshnotes% ; should replace the dropdown options


if (selectedPosition < 7)
{
goto, !%selectedPosition%
}

return



!+z::  ; ********************************************Start of Hyperdrive bar logic

if (HBO = 1)
{
return
}

Gui 7: Destroy
Gui 8: Destroy

gosub Yellow
gosub gui8
return


;############################### This sets the VISN variable  ###########################
 getvisn:

	UserPrefix := SubStr(A_UserName, 1, 3)
	; If UserPrefix contains vha,VHA
	 {
		
		SiteCode := SubStr(A_UserName, 4, 3)

		try
		{
		Gosub %SiteCode%
		}
	}
	

return
;############################### end of VISN    ###########################

;############################################################################################
;####################START OF QUICK ORDER GUI AND PLAYBACK LOGIC (QO recorder is below)##################################
;############################################################################################

			;############################################################################################
			;#########Start with LOAD and DISPLAY QO GUI######################################
			;############################################################################################


quickorder:  ; TO START QO GUI PRESENT &&&&&&&&& QO DATA LOAD

		troubleshooting := 0  ; turns blow by blow messages on
		;****************THIS BOTH LOADS QUICK ORDERS AND HAS GUI FOR DISPLAY**************************************


		; CPRS BOOSTER is messing this script up. ? The nav bars or something else.

		; Create an empty array to store the imported data
		AllData := []
		dropdowndisplayname := ""
		keystrokes_array := []

		; Loop through all the files in the specified directory that have the extension .bstrqo
		; this logic BOTH inputs the quick order DATA AND creates the Gui order gui buttons and dropdown. 


;############################################################################################
;###############LOAD QUICKORDER DATA: LOOP THROUGH ALL QO FILES IN THE FOLDER#####################################
;############################################################################################

		
		
		 Loop, Files, %qorderpath%   ; I bet this just does it in alphabetical order
		 ; Loop, Files, C:\Users\%A_UserName%\OneDrive - Department of Veterans Affairs\CPRSBooster\QuickOrders\*.bstrqo
		{
			; Read the entire text file into a variable
			FileRead, InputText, % A_LoopFileFullPath
			
			; Find the position of the double pipes delimiter
			DelimPos := InStr(InputText, "||")
			
			; Extract the navigation pathway from the text after the double pipes
			NavigationPathway := SubStr(InputText, DelimPos + 2)
			
				if (troubleshooting = 1)
				{
				
				; msgbox The parsed input: %NavigationPathway%
				 
				 }
			
			
			; Remove the navigation pathway from the input text
			InputText := SubStr(InputText, 1, DelimPos - 1)
			
			; Split the input text into fields by the pipe delimiter
			Fields := StrSplit(InputText, "|")
			
			; Create a new object to store the field data
			QuickOrder := {}
			; HERE READING
			; Assign the fields to variables in the object
			QuickOrder.Site := Fields[1]
			QuickOrder.Author := Fields[2]
			QuickOrder.DisplayName := Fields[3]
			QuickOrder.Description := Fields[4]
			QuickOrder.Notes := Fields[5]
			QuickOrder.FileName := A_LoopFileName
			QuickOrder.OnAButton := 0  ; work on this later
			QuickOrder.NavigationPath := NavigationPathway
		   
		;############################################################################################
;####################TRANSFER THE QUICKORDER SINGLE FILE INFO INTO AN ARRAY (ALLDATA) OF ALL DATA######################
;############################################################################################
   
			
			; Add the object to the array of imported data
			AllData.Push(QuickOrder)
		}


/*
		; Define a function to retrieve the DisplayName property from an object
		GetDisplayName(Obj)
			{
			return Obj.DisplayName
			}

		; Sort Alldata alphabetically by DisplayName
		Alldata.Sort("GetDisplayName")
		
*/		
;############################################################################################
;##############################NOW WE EXTRACT DISTINCT CATEGORIES INTO ANOTHER ARRAY#############################################
;############################################################################################



;############################################################################################
;###############################end distinct categories##########################################
;############################################################################################



;########NOT USING THIS GUI CURRENTLY####################################################################################
;######################################Quick order GUI Build######GUI 28##########################
;#############################################GUI 28###############################################

			button1 := AllData[1].DisplayName
			button2 := AllData[2].DisplayName
			button3 := AllData[3].DisplayName
			button4 := AllData[4].DisplayName
			button5 := AllData[5].DisplayName
			button6 := AllData[6].DisplayName
			button7 := AllData[7].DisplayName


			visible := true
			
			Gui, 28:Font, cBlue underline s8, Verdana
			Gui, 28:Add, Text, x70 y15 w100 h20  vdeltext ggui30, Edit/Delete
			Gui, 28:Font
			Gui, 28:Font, s9 cblack, Verdana
			Gui, 28:Margin, 6
			Gui, 28:+AlwaysOnTop +ToolWindow +Owner 
			Gui  28: Add, Button, x1 y1 h0 w0,  
			Gui, 28:Add, Button, x10 y30 w140 h30 gQobutton1, %button1%
			Gui, 28:Add, Button, x10 y70 w140 h30 gQobutton2, %button2%
			Gui, 28:Add, Button, x10 y110 w140 h30 gQobutton3, %button3%
			Gui, 28:Add, Button, x10 y150 w140 h30 gQobutton4, %button4%
			Gui, 28:Add, Button, x10 y190 w140 h30 gQobutton5, %button5%
			Gui, 28:Add, Button, x10 y230 w140 h30 gQobutton6, %button6%
			Gui, 28:Add, Button, x10 y270 w140 h30 gQobutton7, %button7%
			


				dropdowndisplayname := "     MORE HERE!||"
			for i, QuickOrder in Alldata
			{
				;only add up to 7 displaynames to buttons, add remaining to dropdown
				if (i > 7)
				{
					dropdowndisplayname .= QuickOrder.DisplayName "|"
				}
			}
			
			Gui, 28:Add, DropDownList, x10 y310 w140 h20 r20 gqodropdown vqoDropdValue, %dropdowndisplayname%

			Gui, 28:Font, cBlue underline s10, Verdana

			Gui, 28:Add, Text, x50 y350 w100 h20 vMytext gQolink, Show less

			WinGetPos, CprsX, CprsY, CprsWidth, CprsHeight, VistA CPRS

			qoX := CprsX + CprsWidth - 300
			qoy := CprsY + 200

	try 
	{
	 ;  ****LET's TURN OFF GUI 28 for now***. Gui, 28:Show, x%qox% y%qoy% w170 h370 , Booster Quick Orders

	}
	catch e
	{
	;  MsgBox, 262144, CPRS Booster floating bar error,  %newX% %newY%

	Gui 28: Destroy
	}

	gosub ActivateCPRS 

			Return



;-------------------



			Qolink:
			if (visible)
			{
				visible := false ; changes it to new status
				guicontrol, Hide, deltext
				GuiControl, Hide, Qobutton1
				GuiControl, Hide, Qobutton2
				GuiControl, Hide, Qobutton3
				GuiControl, Hide, Qobutton4
				GuiControl, Hide, Qobutton5
				GuiControl, Hide, Qobutton6
				GuiControl, Hide, Qobutton7
				GuiControl, Hide, qoDropdValue
				 GuiControl, Move, MyText, x50,y0 ; moves the text control up
				GuiControl, Text , MyText, Show More
				Gui, Show, h25

			} 
			else
			{
				visible := true ; resets it to true
				guicontrol, show, deltext
				GuiControl, Show, Qobutton1
				GuiControl, Show, Qobutton2
				GuiControl, Show, Qobutton3
				GuiControl, Show, Qobutton4
				GuiControl, Show, Qobutton5
				GuiControl, Show, Qobutton6
				GuiControl, Show, Qobutton7
				GuiControl, Show, qoDropdValue
				GuiControl, Move, MyText, y+350 ; moves the text control down
				GuiControl, Text , MyText, Show Less
				Gui, Show, h370
				

			}
			Return
		

Return ; ***** THIS IS THE BIG RETURN from way up where data load and GUI display start



		;############################################################################################
		;################END Quickorder data and GUI load#######################################################
		;############################################################################################







;############################################################################################
;################GUI 32: FULL list of QO buttons##########Quick order########################################
;############################################################################################


gui32:
rtclicktracker := 1   ; activate this hotkey beginning of this program
gui 32: destroy
Gui, 32:Font, s9, Verdana
Gui, 32:Margin, 6
Gui, 32:+AlwaysOnTop +ToolWindow +Owner

wid32 := 900  ; Set the desired width of GUI 32

32X := qoX - wid32 - 200  ; Set the X position of GUI 32 to the left of GUI 28
32y := qoY - 150

buttonWidth := 150
buttonHeight := 30
buttonXOffset := 10
buttonYOffset := 10
buttonXSpacing := 10
buttonYSpacing := 10
maxButtonsPerColumn := 15
maxColumns := 5 ; don't think we're using this now.
buttonCount := AllData.Length()
buttonColumnCount := Min(maxButtonsPerColumn, buttonCount)

totalColumns := Ceil(buttonCount / buttonColumnCount)
visibleColumns := Min(maxColumns, totalColumns)

Sleep 200
column := 1
row := 1
totalItemcounter := 1

lastCategory := "" ; Variable to store the category name of the last button
Loop, % buttonCount
{

	

	gosub recalcUpperBound
	gosub updateButtonorTextPosition
 

    buttonName := AllData[A_Index].DisplayName
    category := ""
    if (InStr(AllData[A_Index].filename, "====") > 0)
		{
        category := StrSplit(AllData[A_Index].filename, "====").1  ; Extract the category name from the filename
		}
    if (category <> lastCategory)
    {
		Gui, 32:Font, cBlue s10, Verdana
        Gui, 32:Add, Text, x%buttonX% y%buttonY% w%buttonWidth% h%buttonHeight% center, %category%
		Gui, 32:Font
		Gui, 32:Font, s9, Verdana
        lastCategory := category
        ; buttonY += buttonHeight + buttonYSpacing  ; Increase the Y position for the button
        row++  ; Increment row to skip the blank space
		TotalItemCounter++ ; add b/c of text added
		

		gosub recalcUpperBound
		gosub updateButtonorTextPosition ; update spacing as though we put in a button.	
		
    }

    Gui, 32:Add, Button, x%buttonX% y%buttonY% w%buttonWidth% h%buttonHeight% gButtonListAct altsubmit vButton%A_Index%, %buttonName%
	totalItemcounter++ ; add b/c of button added
    row++
}


Gui, 32:Add, Button, x50 y620 w300 gNewQOButton, CLICK HERE TO MAKE NEW QUICK ORDER
Gui, 32:Add, Button, x375 y620 w380 gQOlib, GET PRE-MADE QUICK ORDERS (BOOSTER LIBRARY)
Gui, 32: Font, cBlue underline s9, Verdana
; Gui, 32:Add, Text, x775 y550  gEdDelQO, EDIT/DELETE BUTTONS
Gui, 32: Font, s9, Verdana


Gui, 32:Show, x5 y5 w1200 h660, Booster Quick Orders
Return

ButtonListAct:

qoindex := SubStr(A_GuiControl, 7)  ; Get the index value from the button control name
Gui 32:Destroy


RecordAfterEdit := false ; start with qoEditmode off
Gosub ButtonAction ; Perform the button action for regular left-click
rtclicktracker := 0   ; DEactivate this hotkey beginning of this program
Return


32GuiClose:
Gui 32:Destroy
Gui 30:Destroy ; right click menu
rtclicktracker := 0   ; DEactivate this hotkey beginning of this program
return


updateButtonorTextPosition:
    buttonX := buttonXOffset + ((column - 1) * (buttonWidth + buttonXSpacing))
    buttonY := buttonYOffset + ((row - 1) * (buttonHeight + buttonYSpacing))

return

NewQOButton:
makenewqo := 1 ; this controls the recorder portion that offers to start from root of another qo
Gui, 30: destroy ; 30 is the little rt click drop down
Gui 32:Destroy
rtclicktracker := 0   ; Deactivate this hotkey beginning of this program
RecordAfterEdit := false
gosub qorecorder

return



QOlib:
rtclicktracker := 0   ; activate this hotkey beginning of this program

return



recalcUpperBound:
    upperbound := column * maxButtonsperColumn ; really a max # ITEMS (buttons+text) per column

    if (TotalItemCounter > upperbound) ; Use of headings will mess this up b/c One loop can add a TEXT block AND a button.
    {
        column++
        row := 1
    }
	
return





EdDelQO:
Gui 32: Destroy


gosub gui30

return
;############################################################################################
;####################end GUI 32#######################################################
;############################################################################################





;############################################################################################
;##################START QUICK ORDER BUTTON CLICK ACTION - PLAYBACK##################################
;############################################################################################



ButtonAction:

; beta must remove line below!!
; qodebug := true
	

if (RecordAfterEdit = false)
		{
			keystrokes := AllData[qoIndex].NavigationPath
		}
		Else
		{
			keystrokes := NavEdit
		}

	
		
		if  !(playingbackroot = 1) ; if we are coming from recorder loop WITH don't start at scratch: don't load these (will cause dups and overwrite free text)
		{
		qoNotes := AllData[qoIndex].Notes ; these are overwritting prewritten text
		qoDesc := AllData[qoIndex].Description ; these are overwritting prewritten text
		}


		; If we are coming from the recorder test loop we would get 'keystrokes' from recorder directly not from 'AllData'.
		testingnewQO:
		

	gosub mousevanish

SetTitleMatchMode, 1
 
gosub ActivateCPRS 
	
		

		if (troubleshooting = 1)
		{
		
		 msgbox navpath %keystrokes%
		 
		 }
		
		keystrokes_array := StrSplit(keystrokes , "|")

		recLen := keystrokes_array.MaxIndex()
		
		if (troubleshooting = 1)
		{
		SplashTextOn, 150, 100, CPRS Booster, %recLen% Record Length
		sleep, 700
		SplashTextOff
		 
		 }


		wereInlabs := 0


				;############################################################################################
				;############THE QUICK ORDER PLAYBACK LOOP ##################################################
				;############################################################################################

thelastItem := "" ; set this for next time; clear this before playback; we need this b/c we don't want to wait on {space} IF item before was 'single'
inmedloop := 0 ; reset this
currentstep := 0

		Loop,  %recLen%
		{


					thinking := 0
					keystroketosend := keystrokes_array[A_Index]

					if (qodebug) ; run the qo debugger
					{
						if (A_Index = 1)
						{
						gosub gui31	; create the QO debug gui ticker
						}
						else
						{
							currentstep := A_Index
						gosub qoNavDisplayPath  ; Update the qo debug gui
						}
					
					}
		 
					;############################################################################################
					;#######################START WITH keystrokes > 1 length (Consult/Order/directional movement)######################################
					;############################################################################################
 
				if (StrLen(keystroketosend) > 2) ; (changed to > 2 b/c capturing shift as '+') either this is a enter, tab, arrow etc OR it's a wait screen; or it's the Consult vs order
				{
			
					
						FoundPos := InStr(keystroketosend, "w:")   ; THIS LOOKS SPECIFICALLY FOR WAIT SCREEN
					
						if (keystroketosend = "Consults")
						{
								gosub ActivateCPRS
										
							gosub GoConsults
						
						}
						else if (keystroketosend = "Toolbox")
							{
									gosub ActivateCPRS
											
								gosub GoToolbox
							
							}
						else if (keystroketosend = "Orders")
						{
							gosub goOrders
						}
						else if (keystroketosend = "Tools")
						{
								gosub ActivateCPRS
										
							gosub GoTools
						}
						else if (foundpos > 0)  ; this is a wait screen (W: WAS FOUND)
						{
						
									
									keystroketosend := StrReplace(keystroketosend, "W:", "", 1, 1)
									
									windowsearch := true ; starting the procedure to wait for new screen
									thinking := 0  ; inside the timer loop; loop counter
									
									SetTimer, CPRSthinking, 2000, On
								
									
							;############################################################################################
							;################################Loop to look for a wait screen#####################################################
							;############################################################################################
		
								loopctr := 0
								;while (Otitile != keystroketosend)
								whilte (Otitle !=keystroketosend)
										{
												WinGetTitle, OTitle, A
												
												If (Otitle = keystroketosend)
												{
													If (Otitle="Outpatient Medications")
													{
														inmedloop := 1 ; qo on meds menu
													
													}
												
												
													
													
												break 
												}
										
											gosub locDelayed

										
											sleep 200
											loopctr++
													If (loopctr > 50) ; 10 seconds
													{
													thinking := 0
								
													playbackerror := 1 ; dont' show yellow screen in playback if error
													windowsearch := false ; stop the 'cprs is thinking' window
													gosub thinktimeroff
													qodebug := false
													goto gui54 ; screen asking to fix now or later

													; MsgBox, 262144, CPRS Booster, There is a problem. ? Try again =`n Was waiting for screen: %keystroketosend%
														; removed from here to gui 54


													endbigloop := 1
													
													break
											}
										}
											
							;############################################################################################
							;####################END OF LOOP TO SEACH FOR WAIT SCREEN#####################################
							;############################################################################################
										
							;############################################################################################
							;#########################Wait screen timed out###############################################################
							;############################################################################################

									if (endbigloop = 1)
											{
											; we timed out
											endbigloop := 0
											break ; break big loop
											
											}
							;############################################################################################
							;########################END TIMED OUT LOGIC####################################################
							;############################################################################################

							;############################################################################################
							;################BELOW HERE MEANS WE FOUND THE WAIT SCREEN####################################
							;############################################################################################
	
								
								Windowsearch := False ; we're done looking and can stop the 'crps thinking splash'
														
										
									if (keystroketosend = "Order a Lab Test") ; once we see this once, we're in the lab world
									{
									; wereInlabs := 1   ; every {**every or just the next one} 'enter' after this needs a delay for CPRS processing.
									; SplashTextOn ,150 ,100, CPRS Booster, Order a lab test
									; sleep 1000 ; need more time for next keys
									; SplashTextOff
									}
										
							thelastItem := "Wait" ; set this for next time.	
							
				}
				;############################################################################################
				;#######################DONE WITH WAIT SCREEN OPTIONS; NOW WE're still Leng > 1 not wait####################################
				;################################WHICH MEANS MUST BE MOVEMENT (MOVEMENT SECTION FOLLOWS###########################
				else  ; it's a movement type of key
				{
						
						
									
										if (troubleshooting = 1)
										{
										SplashTextOn, 150, 100, CPRS Booster, %keystroketosend% sending. Last %thelastItem%
										sleep, 700
										SplashTextOff
										 
										 }
						
										gosub locDelayed


					; keystroketosend := "{" . keystroketosend . "}"
					
					if (SubStr(keystroketosend, 1, 1) = "+") ; shift key scenario (mostly shift+tab)
					{
					keystroketosend := "+" . "{" . SubStr(keystroketosend, 2) . "}"
					} 
					else 
					{
					keystroketosend := "{" . keystroketosend . "}"
					}

					 
					;############################################################################################
					;################SEND THE MOVEMENT COMMAND########################################################
					;############################################################################################
			 
						if (inmedloop = 1) && (keystroketosend = "{Enter}") ; we're about to hit enter after med search
						{
						sleep 1000
						}
			 
			 
						IfWinExist, Order a Lab Test
						{
								if (keystroketosend = "{Enter}")
									{
									
									sleep 300 ; let's take some time on the key to be entered prior to get focus
									}
									
						}
			 
			 
			 
			 
						ControlGetFocus, focusedctrl
			 
					 Send %keystroketosend%  
					 
					     if (inmedloop = 1) && (keystroketosend = "{Enter}") ; we're about to hit enter after med search
						{
						sleep 1100
						inmedloop :=0
						}
					 
					 IfWinExist, Order a Lab Test 
					 {
						
				
					 If (focusedctrl = "TButton2") && (keystroketosend = "{Enter}")
							{ 
							sleep 400 ; think it's gonna take at least this long no matter what
							; we need to loop and wait for opening in lab order window
							
							
							controlGetText, OutputVar, TORComboEdit7, Order a Lab Test
							
	
						
									while (StrLen(outputvar) > 0)
									{
									sleep 200	
									controlGetText, OutputVar, TORComboEdit7, Order a Lab Test
									
									
									; I think what we need to do were is wait UNTIL the text being sent
									; is detected in the input box. maybe. 
									}
									sleep 100
									; MsgBox, 262144, CPRS Booster, Ready!
							}
					 
					 }
					 
					 
					;############################################################################################
					;################ADD EXTRA WAIT TIME FOR CERTAIN SCENARIOS##################################################
					;########################THIS WOULD be wait time AFTER the key is sent###############################################################
					 
					 
						if (keystroketosend = "{Enter}") || (keystroketosend = "{space}")  ; slow down logic
						{
						
							 if (thelastItem != "single") ; don't pause for free text typed in
								{
								
								sleep  300 ; let's take a little more time even if screen title doesn't change
								}
						}
					
					 if (wereInlabs = 1) && (keystroketosend = "{Enter}") && (lastsent = "{tab}") ; we're in an enter in the lab orders
						{
						; msgbox we're sleeping
						; sleep 2000
						; wereinlabs := 0 ; try turning this off after just one enter; do this at end
						}
									
							thelastItem := "Movement" ; set this for next time	
								 
						} 
						
			}
			;############################################################################################
			;###########NOW HAS TO BE A SINGLE LETTER OR NUMBER################################################
			;############################################################################################			
			else ; it's just a letter or number, etc  LENGTH not > 2
			{
			
						if (troubleshooting = 1)
							{
							SplashTextOn, 150, 100, CPRS Booster, %keystroketosend% sending
							sleep, 700
							SplashTextOff
							 
							 }
							 
						gosub locDelayed
						
						

					 if (StrLen(keystroketosend) = 1 && SubStr(keystroketosend, 1, 1) = "+")
					{
						SendRaw +
					}
					else if (SubStr(keystroketosend, 1, 1) = "+")
					{
						keystroketosend := SubStr(keystroketosend, 2) ; Strip plus sign
						Send +%keystroketosend%
					}
					else
					{
						Send %keystroketosend%
					}

					 
					 

			 
			 
			thelastItem := "single"
			
			}
			
			Sleep, 2 ; Add a slight delay between keystrokes 
			lastsent := keystroketosend ; need this in the lab order bundle section
		
		
			if (qodebug)
				{
					; Loop until one of the specified function keys is pressed
					loop
					{

						if (!qodebug)
						{
							goto endofplayback
							; not sure we ever use this but.. if loop is changed externally: kill it
						}


						; Check for F5
						if (GetKeyState("F5", "P"))
						{
							; Wait until F5 is released
							while (GetKeyState("F5", "P"))
								{
									Sleep, 20 ; Small delay to prevent high CPU usage
								}
										
							gui, 31: Destroy ; this is the yellow debugger ticker
							qodebug := false ; reset
							sleep 50
							goto endofplayback
							; Goto F5
							; break; I think the goto will break this whole mini and maxi loop
						}
				

					if (GetKeyState("F11", "P"))
						{
							; Wait until F11 is released
							while (GetKeyState("F11", "P"))
							{
								Sleep, 20 ; Small delay to prevent high CPU usage
							}
							; qodebug := false 
							; Gosub, F11  ; SHOULD THIS BE GOTO?
							; break NO break after editing.

							gui, 31: Destroy ; this is the yellow debugger ticker
							qodebug := false ; reset
							sleep 50
							goto qoedit
						}


						; Check for F12
						if (GetKeyState("F12", "P"))
						{

						; Wait until F12 is released
						while (GetKeyState("F12", "P"))
							{
								Sleep, 20 ; Small delay to prevent high CPU usage
							}
							; Gosub, F12
							break
						}
				
						Sleep, 10 ; Short delay to prevent high CPU usage
					}
				}  ; end of qo debug pause loop


		}     ; *****END OF LOOP to iterate through full navpathline
; BETA ? REOVE THIS IS OK  gui 31:Destroy

if (RunningRxQO = 1) ; if we're running an rx qo, skip yellowscreen
		{
			RunningRxQO := 0
			Return
		}


gosub yellowscreen
wereinlabs := 0	

endofplayback:
return ; We didn't have this until 12-1-24; RETURN after playback loop is done
      ; But unclear how logic stops after playback loop
	;############################################################################################
;##############END OF QUICK ORDER PLAYBACK LOOP#####################################################
;############################################################################################

					;############################################################################################
					;##################Subroutine look for location screen or delayed order##########################################
					;############################################################################################

					locDelayed:

										IfWinExist, Location for Current Activities
											{
											gosub currentlocation
											sleep 500 ; seem to need pause here.
											}
										IfWinExist, Delayed Orders
											{
											Send {enter}
				
											sleep 300
											gosub GoOrders ; reset to orders tab
							
											; return
											}

return ; RETURN FOR ENTIRE RECORD LOOP
;############################################################################################
;################WARNING/NOTES YELLOW DISPLAY SCREEN AFTER QUICKORDER## GUI 29#########################################
;############################################################################################
yellowscreen:
		qodebug := false ; if debugger was on, turn off (during playback)
		notedisp := ""
		
		if (playingbackroot = 1)||(playbackerror =1)		; when this is a subplayback of a import to new recording OR and error during playback: skip yellow
		{
		playingbackroot := 0
		playbackerror := 0
		return
		}

		; ************************* Return the mouse to its original position
		; MouseMove, startX, startY, 0

		
		; notedisp := AllData[qoIndex].Notes
		; msgbox %notedisp%
		notedisp := qonotes
		

		 
		  instru := "
(
        ****YOU ARE RESPONSIBLE FOR THIS ORDER***
        ****YOU ARE RESPONSIBLE FOR THIS ORDER***


  PRESS THE SPACEBAR WHEN YOU'RE FINISHED WITH THIS SCREEN 

 Please review the order and notes (if any) below before submitting.
			 
			 

)"
		notedisp :=  instru . notedisp 


	  
		sleep 1500 ; sometimes this beats Cprs
		Gui, 29: +AlwaysOnTop +ToolWindow
		Gui, 29: Color, FFFF00 
		Gui, 29: Font, s11, Verdana
		Gui, 29: Add, edit, +readonly x10 y10 w540 h550, %notedisp%
		Gui, 29: Add, Edit, x1400 y1400 vInvisible, This won't be visible
		GuiControl, 29: Focus, Invisible
		Gui, 29: Show, x700 y100 w550 h600, Booster Notes

		KeyWait, space, D T20

		Gui, 29: Destroy
		; send ^o  WHY was this here/? 

Return

;############################################################################################
;######################CPRS is thinking timer loop##############################################################
;############################################################################################
	cprsthinking:
	
	If (windowsearch = true) && (thinking = 0 )   ; first time through
		{
		SplashTextOn ,250 ,100, CPRS Booster, CPRS IS THINKING....Please hold
		sleep 20
		thinking++
		winactivate, %keystroketosend% ; unsure why or if we need this
		return
		}
	else if (windowsearch = true) && (thinking > 0 )  ; we already loaded splash
		{
		sleep 20
		thinking++
		winactivate, %keystroketosend% ; unsure why or if we need this
		return ; don't do anything
		}
	else  ; windowsearch must be false = we found window = turn off timer
		{
		thinking = 0
		gosub thinktimeroff
		}
		
	thinking ++
	
	return





;############################################################################################
;##################################THink timer off#######################################################
;############################################################################################
thinktimeroff:

			splashtextOff
			thinking = 0
			SetTimer, CPRSthinking, off
			return


return


;############################################################################################
;##################################For QO Debug: creates dynamic nav path######################################################
;############################################################################################

qoNavDisplayPath:


    ; Update GUI to highlight the current step
    highlightedDisplayPath := ""
    Loop, %recLen%
    {
        stepText := keystrokes_array[A_Index]
        if (A_Index = currentStep)
        {
            highlightedDisplayPath .= "**" . stepText . "**" ; Highlight current step (e.g., bold using **)
        }
        else
        {
            highlightedDisplayPath .= stepText
        }
        if (A_Index < recLen)
        {
            highlightedDisplayPath .= " --> " ; Add arrows between steps
        }
    }

    ; Limit the display path to around 100 characters, ensuring the current step is visible
    maxLength := 100
    if (StrLen(highlightedDisplayPath) > maxLength)
    {
        ; Find the current step position
        currentStepText := "**" . keystrokes_array[currentStep] . "**"
        pos := InStr(highlightedDisplayPath, currentStepText)
        
        ; Calculate start and end indices to keep the current step in view
        start := Max(1, pos - (maxLength // 2)) ; Start halfway before the current step
        visiblePath := SubStr(highlightedDisplayPath, start, maxLength)

        ; Add ellipses if truncated
        if (start > 1)
            visiblePath := "..." . SubStr(visiblePath, 4) ; Replace start with "..." if truncated
        if ((start + maxLength) < StrLen(highlightedDisplayPath))
            visiblePath .= "..."
    }
    else
    {
        visiblePath := highlightedDisplayPath
    }

    ; Update the GUI with the truncated path
    GuiControl, 31:, DisplayPathLine, %visiblePath% ; Update the display path line in the GUI

return


/*


	; Update GUI to highlight the current step
	highlightedDisplayPath := ""
	Loop, %recLen%
	{
		stepText := keystrokes_array[A_Index]
		if (A_Index = currentStep)
		{
			highlightedDisplayPath .= "**" . stepText . "**" ; Highlight current step (e.g., bold using **)
		}
		else
		{
			highlightedDisplayPath .= stepText
		}
		if (A_Index < recLen)
		{
			highlightedDisplayPath .= " --> " ; Add arrows between steps
		}
	}
	
	GuiControl, 31:, DisplayPathLine, %highlightedDisplayPath% ; Update the display path line in the GUI

*/
return	

;############################################################################################
;#############LOGIC TO PROCESS QUICK ORDER DROPDOWN MENU#########################################
;##########################NOT USING GUI##################################################################



qodropdown:
gui 28: submit, nohide


 If InStr(qoDropdValue, "MORE HERE") > 1
		{ 
		return
		}

; Search the array for the target display name and get the index number
index := ""
for key, obj in AllData {
    if (obj.DisplayName = qoDropdValue) {
        index := key
        break
    }
}

qoIndex := index
RecordAfterEdit := false ; start with qoEditmode off
gosub buttonaction ; FUNNEL TO SAME LOGIC THAT BUTTONS USE

return

; *******************end drop down processing


;############################################################################################
;######################LABELS THAT QUICK ORDER BUTTONS DIRECT TO#################################
;############################################################################################


Qobutton1:
qoIndex := 1 

gosub buttonaction
return

Qobutton2:
qoIndex := 2
gosub buttonaction
return

Qobutton3:
qoIndex := 3
gosub buttonaction
return

Qobutton4:
qoIndex := 4
gosub buttonaction
return

Qobutton5:
qoIndex := 5
gosub buttonaction
return

Qobutton6:
qoIndex := 6 
gosub buttonaction
return

Qobutton7:
qoIndex := 7 
gosub buttonaction
return


 /* OLD LOGIC NOT NEEDED
  
				 ; ******************************SECTION TO SEND KEYSTROKES FOR QUICK ORDERS


				KeystrokesToSend(QOFileNum)
				{
						return
				}
				 
				 
				;**********************************END QUICK ORDER KEYSTROKES****************




				; *****************get mouse out of way******************

				mousevanish:
					
						; need to get mouse out of way


						MouseGetPos, startX, startY

						; Move the mouse to the lower left corner of the active window
						WinGetPos, , , winWidth, winHeight, A
						MouseMove, winWidth-1, winHeight-1
						
				return
*/

;############################################################################################
;####################END OF QUICK ORDER PLAYBACK############################################################
;############################################################################################




;############################################################################################
;##############START QUICK ORDER RECORD LOGIC################################################
;############################################################################################
;############################################################################################
;#############################################################
;##########################################################################################

;############################################################################################
;#####################START OF QUICK ORDER RECORD GUI##############################################
;############################################################################################

; +!r:: ; hotlkey to open record GUI 

qorecorder:

gui, 27: Destroy

		; THINGS I NEED TO SOLVE: 1. Encounter pop up (need handled on playback too)   2. Delayed orders pop up 3. special characters in button=filename
		;  4. Hide Booster bars  5. Minmize recording GUI  6. REmove the hotkeys from the quick notes


		; F1 stop; f12 pause   

		; F3 = down 5; f5 = down 10 ; f7 = tab 5; f9 tab 10 


		
		; qopath = C:\Users\%A_UserName%\OneDrive - Department of Veterans Affairs\CPRSBooster\QuickOrders\
		;qopath := onedrive . "\CPRSBooster\QuickOrders\"  ; put at top of program
		recordarray := []
		keystrokes := "" 
		selection := ""
		finalNavPath := ""
		currentstatus := "READY TO RECORD"
		radiogroup :=""


		;############################################################################################
		;#####################THE RECORDER GUI###gui27###############################################
		;############################################################################################


		recordingIsOn := 0 ; ONLY change to 1 when they hit the record button
		 
		CatFile :=  BoosterRoot . "QOcategories.txt"   ; load cateogory lables
		FileRead, QoCategories, %CatFile%   ; 
		
		
		qoCategories := StrReplace(qoCategories, "`n", "|")
	

		rootQuickorder := ""
		gui, 27: +AlwaysOnTop +ToolWindow +Owner

		Gui, 27:Font, s11, Verdana 

		Gui, 27:Add, Edit, x362 y139 w490 h80 vqoNotes,
		
		

		Gui, 27:Add, Text, x29 y4 w300 h30 , Please Fill Out All Fields Below

		Gui, 27:Add, Text, x305 y4 w600 h30 , ***CURRENT STATUS: 
		Gui, 27:Add, Text, x500 y4 w600 h30 vCurStat ,%currentstatus%

		Gui, 27:Add, Button, grecord x22 y39 w130 h40 , Record
		Gui, 27:Add, Text, x170 y44 h30 , F1: Stop Recording    F9: Add notes

		; Gui, 27:Add, Button, gstoprec x162 y39 w130 h40 , Stop Recording
		; Gui, 27:Add, Button, gpauserec x302 y39 w130 h40 , Pause
		; Gui, 27:Add, Button, gresumerec x302 y39 w130 h40 , Resume
		Gui, 27:Add, Button, gtestsave x442 y39 w130 h40 , Test 
	   Gui, 27:Add, Button, gsaveQO x722 y39 w130 h40 , Save it!

		Gui, 27:Add, Text, x32 y115 w260 h40 , Where Should I Start Recording?
		Gui, 27:Add, DropDownList, vSelection  x32 y135 w260, Start on the ORDERS tab|Start on the CONSULTS tab|Start on the CPRS Tools Menu|Consult Tracking (Toolbox)

		Gui, 27:Add, Button, gqodebugger x400 y280 w450 h40, STEP BY STEP DEBUGGER
		if (makenewqo = 1)
				{
					Gui, 27:Add, Text, x362 y230 w450 h40 , Start From the End of a Previous Quick Order?

						rootQuickorder := "  No: Start from Scratch  ||"
					for i, QuickOrder in Alldata
					{
					
							rootQuickorder .= QuickOrder.DisplayName "|"
						
					}

					Gui, 27:Add, DropDownList, vjumptoQo  x362 y260 w350, %rootquickorder%
				makenewqo := 0
				}

		Gui,  27: Add, Radio, x32 y170  voutpt, Outpt
Gui,  27: Add, Radio, x+60 y170  vInpt, Inpt
Gui, 27: Add, Radio,  x+60 y170  vBoth, Both

		Gui, 27:Add, Text, x32 y210 w260 h40 , Name You'd Like on QO Button:
		Gui, 27:Add, Edit, x32 y239 w250 h30 vqoName, 
		
		Gui, 27:Add, Text, x32 y289 w260 h40 , Quick Order Category:
		Gui, 27:Add, DropDownList, vQoCat  x32 y310 w200, %qoCategories%
		
		
		Gui, 27:Add, Text, x32 y340 w290 h40 , Short Description:
		Gui, 27:Add, Edit, x32 y360 w310 h70 vqoDesc, 


		
		
		Gui, 27:Add, Text, x362 y99 w260 h40 , Important Information to Display
		
		Gui, 27:Font, s10, Verdana
		
		if (visiblePath != "")
		{


		; Add a yellow rectangle as the background
		Gui, 27:Add, Picture, x50 y450 w800 h30 BackgroundTrans, *ColorFFFF00

		; Add the text on top of the yellow background
		Gui, 27:Add, Text, x50 y450 w800 h30 BackgroundTrans, ERROR FOUND: %visiblePath%
	
		Gui, 27:Add, Text, x50 y450 w800 h30 , ERROR FOUND: %visiblePath%
		}
		Gui, 27:Font, s11, Verdana
		Gui, 27:Add, Text, x50 y465 w300 h30 , Recorded Navigation Path:
		GUI, 27: Add, Edit, x50 y510 r3 w800 vNavEdit, 
		
		Gui, 27:Show, x448 y195 h600 w874, Booster: Automation Recorder
		
		
Return 

;############################################################################################
;######################GUI 27 CLOSE LOGIC##############################################
;############################################################################################

27GuiClose:

if (HaventSavedYet = 1) 
{

MsgBox, 262145, CPRS Booster, You haven't saved this recording yet `n Click OK to leave recorder (LOSE info) `n Click CANCEL to go back
	IfMsgBox Cancel
    return

}


validationerror := 0 ;we're not saving or recording: don't care if fields were wrong.
recordingIsOn := 0
 Gui, 27: Destroy ; Destroy the GUI to get it out of the way
 Gui 28: Destroy ; Ouick order buttons
  gosub quickorder ; reloads all quickorders including new one and rebuilds gui 28 


HaventSavedYet := 0 ; At this point user either saved it OR is ok to discard and need reset for next


/*
if (inEditSection = 1)
{
inEditSection := 0
gosub gui30

}
*/

return 


;############################################################################################
;################################end gui 27############################################################
;############################################################################################


;############################################################################################
;################START RECORDER HERE################################################
;############################################################################################

; Set the hotkey to start recording


record:  ; use of label (gui) will also start recording
inEditSection := 0
recordingIsOn := 1
HaventSavedYet := 1 ; tracks if user has saved recording; since they are just starting it: they haven't
gosub gui31

; Delete current log file ; we did this at script start ; yeah but what if 
; we hit record again and re-record same thing????: need line below

;FileDelete, %keyfile%
qoNotes := ""
qoDesc := ""
jumpnavpath := ""
recordarray := []
Rindex := 1
keystroke := ""
nokeypressed := 0
; should we clear some other variables here? Prob


; SetTimer, CheckPause, off

loopstopped := False
looppaused := False

gosub RecgetAndvalidate
if (validationerror =1)
{
validationerror := 0
return ; do not continue recording

}

currentstatus := "RECORDING"
GuiControl, Text , CurStat, RECORDING
Gui, 27:Hide


gosub mousevanish  ; get mouse out of way


gosub ActivateCPRS


jumptoQo := trim(jumptoQo)


; *** we need to add ability for previously loaded QO to be START of recording loop
;  use recordAfterEdit

if (RecordAfterEdit = true) ; BETA: need to reset this at some point
{

	rootpath := NavEdit
	playingbackroot := 1
	gosub ButtonAction  ; playback ... but we want to skip yellow screen : THIS IS WHERE DUP NOTES AND DESC is occuring (fixed)
			 
	; FileAppend, %rootpath%, %keyfile% ; stick other qo nav path at start of new one
	gosub youtakeit
	
	goto recorderLoop ; skip the steps to start on consults tab or orders
	inEditSection := 1  ;needs this to delete old file later.
}



if (jumptoQo != "No: Start from Scratch")      ; 	need to load the nav path; execute it and record from there
{
		

			for i, QuickOrder in Alldata
			{
			
			 If (QuickOrder.DisplayName = jumptoQo)  ; this loads the root
			 {
			
			 rootpath := QuickOrder.NavigationPath   ; we'll add ROOTpath to final nav at stoprec
			 rootNotes := QuickOrder.Notes 
			 rootDesc := QuickOrder.Description  
			 qoIndex := i   ; set qoIndex (used in playback loop) to found index
			 playingbackroot := 1 ; ? to avoid yellow during playback of root during record; also tells ButtonAction NOT to get qoDesc and qoNotes from old one
											; we used rootNotes and RootsDesc above to do that.
			 gosub ButtonAction  ; playback ... but we want to skip yellow screen : THIS IS WHERE DUP NOTES AND DESC is occuring (fixed)
			 
			 ; FileAppend, %rootpath%, %keyfile% ; stick other qo nav path at start of new one
			 gosub youtakeit
			 goto recorderLoop ; skip the steps to start on consults tab or orders
			 
			 }
				
			}

}

 ; WILL NEED TO SKIP THIS IF STARTING FROM ANOTHER ROOT FILE.


GuiControlGet, Selection , , Selection 

		if (Selection = "Start on the orders tab")
			{
			selection := "Orders"
			} 
		else if (Selection = "Start on the consults tab")
			{
			selection := "Consults"
			} 
		else if (Selection = "Start on the CPRS Tools Menu")
			{
			selection := "Tools"
			} 
		else if (Selection = "Consult Tracking (Toolbox)")
			{
			selection := "Toolbox"
			} 
			


		if (selection = "Consults")
		{

		Recordarray[Rindex] := "Consults|"
		
			Rindex++
		
		 gosub GoConsults
	
		}

		if (selection = "Tools")
		{

		Recordarray[Rindex] := "Tools|"
		
			Rindex++
		
		 gosub GoTools
	
		}

		if (selection = "Toolbox")
			{
	
			Recordarray[Rindex] := "Toolbox|"
			
				Rindex++
			
			 gosub GoToolbox
		
			}

		if (selection = "Orders") ;
		{
		
		Recordarray[Rindex] := "Orders|"

			Rindex++
		
			gosub goOrders
			
			
		SplashTextOn, 150, 100, CPRS Booster, Start at Top of Orders
		sleep, 500
		SplashTextOff
		}


		;  the recording loop
		loopcounter := 1 ; THIS IS WRONG. WE DO WANT IT.the prior screen and current screen WON'T match on first loop b/c there is NO prior screen: don't want recorded as wait.
		 
		 ; HOWEVER: need to find a way to capture first screen window title to make sure we're headed the right way. Prob after first recorded clicked
		 ;    and the flip the order of the screen name and the first click; whatever screen you are clicking
		 
		 ; **************************ENDLESS LOOP START*************
		 
recorderLoop:

	Loop
		{
		
				if (LoopStopped = True)
				{

				LoopPaused := False 
				GuiControl, Text , CurStat, READY TO RECORD
				break
				
				}
			
	
				gosub locDelayed
				
			
			;If (LoopPaused = false) && (LoopStopped = false) 

			; only record when NOT paused
			if (looppaused = false)
				{ 
				
					; Get the current keystroke
					key := GetKey()

					if (Key != "") 
					{
					
						If (nokeypressed = 1) ; if there was a key lift between this time and last
						{
						nokeypressed := 0 
									; Check if the keystroke has already been recorded
									; if (InStr(keystrokes, key) = 0)  ; it's a new key after a NO key ; AAA problem
									; {
									
					
							gosub checkforchange  ; write new screen fingerprint if there was a change = will change %key% to window name
						
							; Write the keystroke to the log array
							
							Recordarray[Rindex] := key . "|"
								
							Rindex++
							
						}
					}
					else ; IF the key is NOTHING, wipe it.
					{
					NoKeypressed := 1

					
							; Clear the list of recorded keystrokes when no key is pressed
						keystrokes := ""		
							
					}
							
				} 
		}

		; Add a message to the log file indicating the end of the recording

return  ; I think this is end of record promp

;############################################################################################
;####################END RECORDER LABEL##############################
;############################################################################################


;############################################################################################
;################Check data from recorder Gui##############################################
;############################################################################################

RecgetAndvalidate:

gosub recGuiData ; GUI FIELDS FROM RECORDER GUI (basically submits gui 27) ; we cleared qoDesc just above. Should reload it here tho


; check to make sure fields in form are complete (except notes)

if (radiogroup = "missing")
	{
	MsgBox, 262144, CPRS Booster, You must indicate what setting your `n quick order will work in (outpt, inpt, both)
	validationerror := 1
	return
	} 

if (qoname = "")
	{
	MsgBox, 262144, CPRS Booster, You must fill in the button name field.
	validationerror := 1
	return

	}

if (selection = "")
		{
		MsgBox, 262144, CPRS Booster, Please Choose an Option under 'Where should I start'
		validationerror := 1
		return

		}
		
if (qoCat = "")
	{
	MsgBox, 262144, CPRS Booster, You must choose a quick order category
	validationerror := 1
	return

	}

return

;############################################################################################
;############################################################################################
;############################################################################################


;############################################################################################
;###################Get to CPRS TOOLBOX subroutine##################################################
;############################################################################################

GoToolbox:
sleep 300
send ^t ; consult tab
sleep 400
send !A
sleep 50
send c 
return




;############################################################################################
;###################Get to CPRS TOOLS MENU tab subroutine##################################################
;############################################################################################

GoTools:
		 sleep 300
		 send !t ; 
		 sleep 50

return





;############################################################################################
;###################Get to consults tab subroutine##################################################
;############################################################################################

GoConsults:
		 sleep 300
		 send ^t ; consult tab
		 sleep 400
		 send {enter}
		 sleep 400
		 send {pgup 4}
return

;############################################################################################
;###########################Get to ORDERs tab subroutine##########################################
;############################################################################################

GoOrders:
							gosub ActivateCPRS						
							send ^o
							 sleep 400
							 send +{tab 2}
							sleep 100
							send {pgup 3}
							sleep 50


return



;############################################################################################
;####################The great function that RECORDS Keystrokes###############################################
;############################################################################################

; Function to get the current keystroke

/*  ;; older version which didn't handle shift+key
GetKey()
	{


		if getkeystate("Down", "P")
		{
		 return "Down"
		}
		
		if getkeystate("enter", "P")
		{
		 return "Enter"
		}
		
		if getkeystate("space", "P")
		{
		 return "space"
		}
		
		if getkeystate("tab", "P")
		{
		 return "tab"
		}
		
		if getkeystate("up", "P")
		{
		 return "up"
		}
		
		if getkeystate("right", "P")
		{
		 return "right"
		
		}
	
		if getkeystate("left", "P")
		{
		 return "left"
		
		}
		
		if getkeystate("F1", "P")
		{
		SplashTextOn ,150 ,100, CPRS Booster, F1
		sleep 3000
		SplashTextOff
		 gosub F1
		 
		}
	
		if getkeystate("F9", "P")
		{
		
		SplashTextOn ,150 ,100, CPRS Booster, F9
		sleep 3000
		SplashTextOff
		 gosub F9
		}	
	
		
		; Loop through all possible keys
		Loop 127
		{
			; Check if the current key is pressed
			if (GetKeyState(Chr(A_Index), "P"))
			{
				; Return the name of the key
				nKey := GetKeyName(Chr(A_Index))
				; MsgBox, 262144, CPRS Booster, %nKey%
				return GetKeyName(Chr(A_Index))
			}
			
		}
		
	
		
		
    }

  */
  
  
  
  GetKey() {
    if GetKeyState("Down", "P") {
        return "Down"
    }

    if GetKeyState("Enter", "P") {
        return "Enter"
    }

    if GetKeyState("Space", "P") {
        return "Space"
    }

    if (GetKeyState("Tab", "P") && GetKeyState("Shift", "P")) {
        return "+Tab"  ; Shift+Tab combination
    } else if (GetKeyState("Tab", "P")) {
        return "Tab"   ; Regular Tab key press
    }

    if GetKeyState("Up", "P") {
        return "Up"
    }

    if GetKeyState("Right", "P") {
        return "Right"
    }

    if GetKeyState("Left", "P") {
        return "Left"
    }


    Loop 127 {
        if GetKeyState(Chr(A_Index), "P")
		{
            nKey := GetKeyName(Chr(A_Index))

            ; Check if Shift key is also being held down
            if GetKeyState("Shift", "P")
				{
					nKey := "+ " . nKey  ; Add "+" before the key name to indicate Shift key
				}

            return nKey
        }
    }
}




;############################################################################################
;####################END of GETkey function defintion############################################
;############################################################################################



;############################################################################################
;######################Look for WIN TITLE change WHILE RECORDING##############################################
;############################################################################################

checkforchange:

if (looppaused = false) && (loopstopped = false)
		{
			; Run mouse code only if we aren't paused or stopped
			WinGetTitle, Title, A



			FoundPos := InStr(Title, "VistA CPRS in use by")     ; don't want to record this.
			
			if (Title != lastTitle) && (foundpos = 0)
				{
					
							Recordarray[Rindex] := "w:" . Title . "|"
							
							

							
		;############################################################################################
		;#####################After we record the most recent = current wintitle s/p a change:#############################
		;#######################Then we check duration from last win change. If short: the last one was a blip to ignore#####################
			
					
					duration := (A_TickCount - lastTitleTime) / 1000
					
					if (duration < 7) ; this may just have been a background screen b/t actual important screens
					{
					
							maxindex := RecordArray.MaxIndex() 
							Loop %maxindex%
							{ 					; loop through values starting with the highest index number
								index := maxindex - A_Index     ; calculate the index to check from top down (actually maxindex will be one short of current index b/c zero based
							
							
									if InStr(RecordArray[index], "w:")   ; check if the element contains "w:"
											{ 
													todelete := RecordArray[index]
													 RecordArray[index] := "" ; replace the value of the found element with ""
													 
													 ; REMOVE SPLASH BELOW
													 ; SplashTextOn ,150 ,100, CPRS Booster, Removing wait for: %todelete%
													; sleep 3000
													; SplashTextOff
										
													break ; exit the loop
											}
							} ; end loop to delete next to last wait screen

					
					} ; end if duration < 5
					
					
					; MsgBox, 262144, CPRS Booster, Duration %duration%
					; currentfield := Recordarray[Rindex]
					; SplashTextOn ,150 ,100, CPRS Booster, %duration% before %currentfield%
					; sleep 1800
					; SplashTextOff
					
					
					
					
					Rindex++
					lastTitle := Title
					lastTitleTime := A_TickCount
					
					
				} ; end check if title changed
		
		} ; end check to make sure we aren't in a pause situation (don't want to record pause screens)

return

;############################################################################################
;########################END OF LOOK FOR WIN CHANGE###################################################
;############################################################################################


;############################################################################################
;###################################GUI 31:  RECORDING MESSAGE GUI#########################################################
;############################################################################################
gui31:

gui, 31: Destroy
Gui, 31: +AlwaysOnTop -Caption +ToolWindow
Gui, 31: Color, FFFF00
Gui, 31: Font, s11, Verdana  ; Set Verdana

if (qodebug = true)
		{
		Gui, 31: Font, s9, Verdana  ; Set Verdana
		Gui, 31: Add, Text, X20 Y0 w900 , ******DEBUGGING*****(F5 Cancel)***********(F11 Found Error)************(F12 Continue)****
		; Add a second line for the navigation path
		displaypath := StrReplace(keystrokes, "|", " --> ") ; Convert pipe-delimited path to arrow-delimited
		
		Gui, 31: Add, Text, X20 Y11 w900 vDisplayPathLine, %displaypath%
		gosub qoNavDisplayPath  ; length restrict displaypath
		Gui, 31: Show, x345 y0 w1200 h40 ; Adjust height for the additional line
		}
Else
		{
		Gui, 31: Add, Text, X20 Y5 w800 , ******RECORDING******(F1 to STOP)****(F9 TO ADD COMMENTS)****Do NOT use mouse***
		Gui, 31: Show, x345 y0 w1200 h30 ; Adjust height for the additional line
		}

return ; return for Gui 31





;############################################################################################
;##################Stop recording logic#################################################
;############################################################################################


stoprec:
stuffadd :=""
LoopStopped := True
LoopPaused := False

Gui 31: destroy

MsgBox, 262144, CPRS Booster, Please close any open CPRS windows (other than main) now.

finalnavpath := "" ; initialize finalnavpath to 0

Loop, %Rindex%   ; loop through the array from 1 to Rindex
{
	stuffadd := recordarray[A_Index]
	
    finalnavpath := finalnavpath . stuffadd  ; add the current element to finalnavpath

}

; MsgBox The sum of the elements in recordarray from 1 to %Rindex% is %finalnavpath%.  ; display the result

recordarray := []
Rindex := 1

	; COMPRESS NAV PATH 
	
	result := ""
	prev_key := ""
	count := 1
	duplicatefound := 0
    loop, parse, finalnavpath, |
    {
        key := A_LoopField
        if ((key = prev_key)&&(StrLen(prev_key) > 1)) ; repeat of direction key
				{
				count++
				duplicatefound := 1 ; keep track of repeats
				}
			else     ; NOT the same as the last key OR it's a single alpha num repeat
				{
				
						if (duplicatefound = 1)  ; dup found but we just got past it
						{
						duplicatefound := 0
						result .= prev_key " " count "|"
						count := 1 
						}
						else
						{
							if (prev_key != "") ; at start prev key set to ""
							{
								result .= prev_key "|"
							}
						} 
				}
				
			prev_key := key
		
	}  ; end parsing loop


Finalnavpath := rootpath . Result
qoNotes := rootNotes . "`n" . qoNotes
qoDesc  := rootDesc . "`n" . qoDesc 
rootpath := ""

recordingIsOn := 0 ; reset
; SetTimer, CheckPause, off

		SplashTextOn, 150, 100, CPRS Booster, Recording Stopped
		sleep, 2000
		SplashTextOff

		; Stop the recording loop

currentstatus := "READY TO RECORD"
GuiControl, Text, CurStat, READY TO RECORD
GuiControl,27:, NavEdit, %Finalnavpath%  ; set edit box on record GUI to full nav path.

GuiControl,27: ,qoNotes, %qoNotes% ;update notes box w/notes.
GuiControl,27: ,qoDesc, %qoDesc% ;update notes box w/notes.

Gui, 27: Show, , Booster: Automation Recorder



return ; END OF STOP RECORD

;############################################################################################
;#############END OF STOP RECORD##############################################
;############################################################################################



;############################################################################################
;##########################SAVE Quick Order Section###############################
;############################################################################################


SaveQO:  ; start logic to SAVE quick order just recorded.


; Define the site variable as a substring of A_UserName
site := SubStr(A_UserName, 4, 3)

; Get the values from the GUI edit controls

gosub RecgetAndvalidate 
if (validationerror =1)
{
validationerror := 0
return ; do not continue saving.

}

; ****************clean the button name b4 goes into file name

; List of illegal filename characters: must remove from the qoname before we put in filename
; illegalChars := [ "\\", "/", ":", "*", "?", "\"", "<", ">", "|" ]


illegalChars := [ "\\", "/", ":", "*", "?", "<", ">", "|" ]


;############################################################################################
;#################remove illegal character from QO name and QO category####################################
;############################################################################################

; Remove illegal characters from the qoname variable
for each, char in illegalChars {
    qoname := StrReplace(qoname, char, "")
}


; remove bad characters from Qocat - shouldn't use these messed up category names in first place
for each, char in illegalChars {
    QoCat := StrReplace(QoCat, char, "")
}


; Define the output filename

texttosend := "" ; clear this variable
qoCat := StrReplace(qoCat, "`n", "")
qoCat := StrReplace(qoCat, "`r", "")


outputFileName :=qopath . QoCat . "====" . site . "_" .  A_UserName . "_" . qoName . radiogroup . ".BSTRqo" ; we're going to need to use the unscore as a delimiter if



filedelete, %outputFileName% ; we don't want to write to a written to file	
; Write the data to the output file




; Check if variables are blank and set them to "   " if they are
if (qoNotes = "")
    qoNotes := "   "
	
if (qoDesc = "")
    qoDesc := "   "
	
	
if (finalNavPath = "")
   {
   MsgBox, 262144, CPRS Booster, Something didn't record properly. Please try again
   
   } 
	
		; SplashTextOn, 150, 100, CPRS Booster, Writing IN STOPPED
		; sleep, 2000
		; SplashTextOff

texttosend := Site . "|" . A_username . "|" . qoName  .  RadioGroup  . "|" . qoDesc . "|" . qoNotes . "||" . finalNavPath


if (inEditSection = 1)
	{
	
		if !(qofilename == outputFileName)  ; the edited filename changed and the original one is still floating out there.
		{
	
			filedelete, %qofilename%		;		gosub qoDelete ; if we're editing: delete old vesion,;;;; WAIT: if we changed Name does this delete current v
		}
	inEditSection := 0
	}



FileAppend, %texttosend%, %outputFileName%

HaventSavedYet := 0

if !FileExist(outputfilename)
{
MsgBox, 262144, CPRS Booster, Hmmmm. Something went wrong in saving `n the quick order

}
else
{
	SplashTextOn ,150 ,100, CPRS Booster, QUICK ORDER SAVED!
	sleep 1500
	SplashTextOff	
	;MsgBox, 262144, CPRS Booster, QUICK ORDER SAVED!
}


; MsgBox, 262144, CPRS Booster, %qofilename%
; MsgBox, 262144, CPRS Booster, %outputFileName%

; :::: BE CAREFUL bc outputfile is also a variable in dotphrase profile. ? change




gosub 27GuiClose ; close recorder. reload QOs,etc



return
;############################################################################################
;#################End STOP recording logic#################################################
;############################################################################################


;############################################################################################
;#################Get record GUI data (button name/comments/etc)#################################################
;############################################################################################


recGuiData:

gui 27: submit, nohide
finalNavPath := NavEdit




if (outpt)
	{
		RadioGroup := "(O)"
	}
	else if (inpt)
	{
	RadioGroup := "(I)"
	}
	else if (both)
	{
	RadioGroup := "(B)"
	}
	else RadioGroup := "missing"

return



;############################################################################################
;##################Pause to make NOTES during recording#################################################
;############################################################################################


pauserec:

 WinGetActiveTitle, PausedTitle ; need to activate this later I think

currentstatus := "PAUSED"
LoopPaused := True
Gui +OwnDialogs +AlwaysOnTop
InputBox, noteaddition, Helpful Notes For Users, Enter a Note
keywait enter ; wait until released o/w we will record an enter

qoNotes := qoNotes . noteaddition . "`n"
currentstatus := "RECORDING"
LoopPaused := False
sleep 50
; GuiControl, Edit , qoNotes, %qoNotes%

GuiControl,27: ,qoNotes, %qoNotes% ;update notes box w/notes.
gosub mousevanish ; hide mouse if moved

winactivate, %pausedtitle% ; get this active again.




  ; ? put back  SetTimer, CheckPause, 100  ; check every 100ms if LoopPaused is true

		/*	
			littleloop:
				sleep 100
			
			if(looppaused = 1)
			{ 
			goto littleloop 
			}
		 */

return

/*
checkpause:
if (LoopPaused = False)
{
SetTimer, CheckPause, off

}
else
{
sleep 50
}
return
*/
;############################################################################################
;#################End PAUSE recording logic#################################################
;############################################################################################


;############################################################################################
;##################Start Play back FOR TESTING AFTER RECORDING#########################################
;############################################################################################
testsave:
; Needs to use playback script as a gosub

Gui, 27: Hide
guicontrolget, qoNotes, ,qoNotes
guicontrolget, qoDesc, ,qoDesc


guicontrolget, keystrokes, ,NavEdit ; assign the value of NavEdit  on the GUI to keystrokes variable.\
finalNavPath := keystrokes ; make the edited version the working version to save

gosub testingnewQO ; THIS IS PLAYBACK OF WHAT WE JUST RECORDED.
sleep 2000 ; don't want gui 27 to pop up and mess up playback
gui, 27: Show

return
;############################################################################################
;#################END reference to playback#############################################################
;############################################################################################


;############################################################################################
;###############Start Mousevanish##################################################################################################
;############################################################################################

mousevanish:
	
		; need to get mouse out of way


CoordMode, Mouse, Screen  ; set mouse coordinates to be relative to the screen

; Move the mouse to the lower left corner of the screen
SysGet, virtualWidth, 78  ; 78 is the code for SM_CXVIRTUALSCREEN
SysGet, virtualHeight, 79  ; 79 is the code for SM_CYVIRTUALSCREEN
MouseMove, virtualWidth-1, virtualHeight-1

MouseGetPos, startX, startY  ; position once moved off screen

return



;  END of make mouse vanish



;############################################################################################
;###############END Mouse vanish#################################################
;############################################################################################



;############################################################################################
;##############END QUICK ORDER RECORD LOGIC################################################
;############################################################################################
;############################################################################################
;#############################################################
;############################################################################################


;############################################################################################
;##############QO National Library#############################


;############################################################################################
;############################################################################################
;########################start gui 33: Instruction to Turn Sync on####################
;#########################################QUICK ORDERS NOT DP###################################################


gui33:

 Gui, 33: Destroy
my_picturefile =%BoosterRoot%Pictures\QONationalLibrary.PNG
Gui, 33: Add, Picture,   w1000 h-1 , %my_picturefile%
Gui, 33: Show, x200 y150 , Booster: National Library Access     ; Display the GU
return ; return for Gui 33

33GuiClose:
 Gui, 33: Destroy ; Destroy the GUI to get it out of the way
Return


;############################################################################################
;################################End GUI 33###########################################
;############################################################################################




;############################################################################################
;######################GUI30 this is the GUI for Quick order right click pop up menu###################################
;############################################################################################

 
Gui30:
Gui, 30: Destroy
  ; Create the GUI for the pop-up menu (GUI number 30)
  Gui, 30: +AlwaysOnTop -Caption +ToolWindow +Owner
  Gui, 30:Color, White
  Gui, 30:Font, s10
; Add buttons for each option 
Gui, 30:Add, Button, x10 y5 w80 h20 gEdit, Edit 
Gui, 30:Add, Button, x10 y30 w80 h20 gDelete, Delete
Gui, 30:Add, Button, x10 y55 w80 h20 gCancel, Cancel
  ; Calculate the width and height of the GUI
  MouseX := MouseX + 20
   MouseY := MouseY + 20

  
  Gui, 30:Show, x%MouseX% y%MouseY% w100 h85
return

; Handle GUI close event
; GuiClose:
;  Gui, 30: destroy
  
;return

; Handle mouse click event on the menu items
Edit:

  Gui, 30: destroy ; 30 is the little rt click drop down
  Gui, 32: destroy ; 32 is the giant list of q orderes
  rtclicktracker := 0
  gosub qoedit
return

Delete:
 
  Gui, 30: destroy
  Gui, 32: destroy
  rtclicktracker := 0
  gosub qoDelete
return

Cancel:
	Gui, 30: destroy
	; we do not reset rtclicktracker here b/c big menu still open
return




;############################################################################################
;############################################################################################
;############################################################################################




/*
;############################################################################################
;####################QUICK ORDER: EDIT AND DELETE GUI####### WE CAN DELETE THIS GUI###################################
;###################################GUI 30#########################################################

gui30:
gui 30: Destroy
Gui, 30:Font, s11, Verdana 
Gui 30:Add, ListView, r25 w400 altsubmit gEditQOListView , Quick Order {RIGHT CLICK TO EDIT/DELETE}  | Index

	for i, QuickOrder in Alldata
	{
			displayname := QuickOrder.DisplayName
			qoindex := i
			filename := QuickOrder.Filename
			Gui, 30: default
			LV_Add("",displayname, qoindex)

			; MsgBox, 262144, CPRS Booster, %filename%
	}

LV_ModifyCol(1, "AutoHdr")
LV_ModifyCol(2, 0)
LV_ModifyCol(3, 0)



Gui 30:Show, x300 y100 w450 h600, QUICK ORDER DELETE/EDIT

return


; Handle the ListView events
EditQOListView:

if (A_GuiEvent = "RightClick")
{
    LV_GetText(index, A_EventInfo, 2)  ; Get the text from the row's first field.
    ; msgbox You double-clicked row number %A_EventInfo%. Text: "%RowText%"

Menu, RtclickMenu, Add, Delete, qoDelete  ; NOTE: there is a similar label GO delete: this is QO Delete
Menu, RtclickMenu, Add, Edit, qoEdit   ; same above label issue
Menu, RtclickMenu, Show
}
return

*/


;############################################################################################
;#####################Edit qo logic#############################################
;############################################################################################


qoedit:


		; NavEdit := AllData[Index].NavigationPath
		NavEdit := AllData[qoindex].NavigationPath
			
		If InStr(NavEdit, "Orders")  
		{
		startit := "Start on the ORDERS tab"
		}
		
		If InStr(NavEdit, "Tools")  
		{
		startit := "Start on the CPRS Tools Menu"
		}
		
		If InStr(NavEdit, "Consults")  
		{
		startit := "Start on the CONSULTS tab"
		}
		
		If InStr(NavEdit, "Toolbox")  
			{
			startit := "Consult Tracking (Toolbox)"
			}		
		
		
		
		category := StrSplit(AllData[qoindex].filename, "====").1  ; Extract the category name from the filename
	
	
		; qoFilename :=  userprofile . "\OneDrive - Department of Veterans Affairs\CPRSBooster\QuickOrders\"  . AllData[Index].filename

			qoFilename := onedrive . "\CPRSBooster\QuickOrders\" . AllData[Index].filename

		qoNotes := AllData[qoindex].Notes
		qoName := AllData[qoindex].DisplayName
		qoDesc := AllData[qoindex].Description
		
		
		; Retrieve the last 3 characters of the description
		lastThreeChars := SubStr(qoName, -2)
			
		; Trim the last three characters from the description if applicable
		
		if (lastThreeChars = "(O)" or lastThreeChars = "(I)" or lastThreeChars = "(B)")
			qoName := SubStr(qoName, 1, -3)		
	 
RecordAfterEdit := true
gosub qorecorder  ; this is gui 27	
GuiControl,27: ,NavEdit, %NavEdit%  ; set edit box on record GUI to full nav path.
GuiControl,27: ,qoNotes, %qoNotes% ;update notes box w/notes.
GuiControl,27: ,qoDesc, %qoDesc% 
GuiControl,27: ,qoName, %qoName%

GuiControl, 27: ChooseString, QoCat, %category%
GuiControl, 27: ChooseString, Selection, %startit%

 
 		; Set the appropriate radio button based on the last three characters
		if (lastThreeChars = "(O)")
			GuiControl, 27: ,outpt, 1
		else if (lastThreeChars = "(I)")
			GuiControl, 27: ,Inpt, 1
		else if (lastThreeChars = "(B)")
			GuiControl, 27: ,Both, 1
inEditSection := 1  ;needs this to delete old file later.				
 
return


qodelete:


	if !(inEditSection = 1) ; not going to ask to delete if we are saving edits. Just do it.
	{
MsgBox, 262145, CPRS Booster, You Sure You Want To Delete This Quick Order?
	IfMsgBox Cancel
    return
	}

; fn :=  userprofile . "\OneDrive - Department of Veterans Affairs\CPRSBooster\QuickOrders\" . Alldata[qoindex].filename
fn := onedrive . "\CPRSBooster\QuickOrders\" . Alldata[qoindex].filename


        FileDelete, %fn%
        Alldata.Remove(qoindex)
; MsgBox, 262144, CPRS Booster, Delete %fn%

gui 30:destroy


return

;############################################################################################
;################END QUICK ORDER EDIT AND DELETE GUI####################################################
;############################################################################################





;############################################################################################
;#############################START HYPERDRIVE BAR (top: gui7)######################################
;############################################################################################


Yellow:  ;--------******************************* THIS IS THE HYPERDRIVE BAR GUI

if (HBO=1)  ; if user disabled hyperdrivebar, stop here
{
return
}

gosub getvisn

if HBH is not number ; null or text
{
HBH:=0
}

if HBV is not number ; null
{
HBV:=0
}

	WinGetPos, X4, Y4, Width, Height, VistA CPRS

	Px := X4 + width - (width/1.05) + HBH ; division by smaller number moves bar to left ; was 1.15
	Py := Y4 + 5 - HBV

if Px is not number ; null or text     ; ****ERROR: this is not working. Crashes still happening
{
skipover:= 1
}

if Py is not number ; null
{
skipover:=1

}

if (skipover = 1)
{
skipover:=0
goto nohyperdrive

}


; my_picturefile = U:\CPRSBooster\Booster-med-res.png ;*** This is old and won't work for non-U drive users
; FileInstall, \\v23.med.va.gov\apps\GUI\MIN\Booster-med-res.png,  %my_picturefile%, 0 *******old: no

my_picturefile = %BoosterRoot%Booster-med-res.png

hbar := 26
hGui := hbar + 1

Gui, 7:Color, FFFFFF, FFFFFF
Gui 7: Font, s8 cblack, Verdana
Gui, 7: Margin, 6
Gui, 7: +AlwaysOnTop -Caption +ToolWindow +Owner
Gui, 7:Add, Picture,x0 y4  h18 w-1, %my_picturefile%

Gui, 7:Add, Button,x20 y0  h%hbar% -Tabstop, Unfreeze CPRS
Gui, 7:Add, Button, y0  h%hbar% -Tabstop, All Notes  
Gui, 7:Add, Button, y0  h%hbar% -Tabstop, My Notes
Gui, 7:Add, Button, y0  h%hbar% -Tabstop, Notes by Title
Gui, 7:Add, Button, y0  h%hbar% -Tabstop, Notes by Author
Gui, 7:Add, Button, y0  h%hbar% -Tabstop, Notes by Location

if (A_UserName = "VHAMINBOCKA" || A_UserName = "VHAMINHansoB2")  ; 
{
    ; Gui, 7:Add, Button, y0 h%hbar% -Tabstop, Quick Orders
}

; Gui, 7:Add, Button, y0 h%hbar% -Tabstop, Quick
Gui, 7:Add, Button, y0  h%hbar% -Tabstop, Secure Messaging

 Gui, 7:Add, Button, y0  h%hbar% -Tabstop, Dragon
	
Gui, 7:Add, Button, y0  h%hbar% -Tabstop, Dot Phrases
Gui, 7:Add, Button, y0  h%hbar% -Tabstop, CPRS Help Videos
Gui, 7:Add, Button, y0  h%hbar% -Tabstop, Exit Booster


; Gui, 7: GuiControl, Move, Picture,  h20

try
{
Gui, 7:Show, x%Px% y%Py% w1050 h%hGui% , hyperdrivebar   
}

hyperX := Px
hyperY := Py

; winactivate, VistA ; need this b/c creating GUI takes focus off CPRS.
nohyperdrive:

return   ; End of hyperdrive bar GUI

; return ; End of Yellow??



7ButtonUnfreezeCPRS:

winmove, VistA C,,,600

instru := "
(
Most CPRS Freezes are due to CPRS opening a SECOND
window BEHIND the main window. Find that window now.
Do whatever needs to be done with it.
)"


	SplashTextOn ,600 ,200, CPRS Booster, %instru%
	sleep 3000
	SplashTextOff
return



7buttonQuickOrders:
gosub gui32
return

7buttonquick:
goto  gui56
return

7ButtonCprsHelpVideos:

; OLD run https://dvagov.sharepoint.com/sites/min/SiteDirectory/CPRS/SitePages/CPRS-VIDEOS.aspx

run  https://dvagov.sharepoint.com/sites/vhamincprs/SitePages/CPRS-Videos.aspx 


instru := "
(
Note: Videos created by the Minneapolis VA. Some functionality may be different at other VAs.
)"

MsgBox, 262144, CPRS Booster, %instru%
return

7ButtonDragon:

gosub draggui
return


7ButtonMyNotes:
gosub ActivateCPRS
sleep 200
send ^n
sleep 200
send !va ; all by logged in  author
send {enter}

mynotes:=1 ; need this variable to track if mynotes was last b/c can't click notes by location after mynotes
Return ; end of my notes button

7ButtonNotesbyTitle:

if (mynotes=1)
{
gosub 7ButtonAllNotes ; convert to all notes FIRST if my notes was last and then by location
sleep 200
mynotes:=0
}
gosub ActivateCPRS
sleep 200
send ^n
sleep 200
send !vm ; Custom
sleep 200
send {tab 3}
sleep 200
send T	
sleep 100	
send {enter}

Return ; end of my notes by title




7ButtonNotesbyLocation:

if (mynotes=1)
{
gosub 7ButtonAllNotes ; convert to all notes FIRST if my notes was last and then by location
sleep 200
mynotes:=0
}
gosub ActivateCPRS
sleep 200
send ^n
sleep 200
send !vm ; Custom
sleep 200
send {tab 3}
sleep 200
send L	
sleep 100	
send {enter}

Return ; end of notes by loc

7ButtonClinicSchedule:


run %BoosterRoot%VistaReflections\AMReflections.rdox

SplashTextOn ,150 ,100, CPRS Booster, Starting Vista
sleep 3000
SplashTextOff


Return ; end of open vista

7ButtonExitBooster: ; Quit booster button

exitapp
Return ; 




7ButtonNotesbyAuthor:

if (mynotes=1)
{
gosub 7ButtonAllNotes ; convert to all notes FIRST if my notes was last and then by location
sleep 200
mynotes:=0
}
gosub ActivateCPRS
sleep 200
send ^n
sleep 200
send !vm ; Custom
sleep 200
send {tab 3}
sleep 200
send A	
sleep 100	
send {enter}

Return ; end of notes by author



7ButtonAllNotes:
gosub ActivateCPRS
sleep 200
send ^n
sleep 200
send !vs ; all 
mynotes:=0

Return ; end of my notes button

7ButtonSecureMessaging:
gosub SM
return

7ButtonDotPhrases:
gui 7: destroy ;Destroy ; get rid of hyperdrive
gui 8: destroy
Gui 14: Destroy ; get rid of floating fxn
winactivate, Booster Dot Phrases: Your Dot Phrases
return

Return   ; END HYPERDRIVE BAR

; ------------------------------------*************************END of HYPERDRIVE BAR LOGIC

;############################################################################################
;###############GUI8 LINK HELPER BAR (sub 7)###########################################
;############################################################################################

gui8:


if (HBO=1)  ; if user disabled hyperdrivebar, stop here
{
return
}




Gui, 8:Color, FFFFFF, FFFFFF
Gui 8: Font, s8 cblack, Verdana
Gui, 8: Margin, 2   
Gui, 8: +AlwaysOnTop -Caption +ToolWindow +Owner
; Gui, 8:Add, Picture,x0 y4  h18 w-1, %my_picturefile%

if (AmbScribePilotParticipant = 1)
{
Gui, 8:Add, Button, X20 y0  h20 gAmbDict -Tabstop, Ambient Scribe
}
Gui, 8:Add, Button, y0  h20 gMWW -Tabstop, My WorkWeek
if (sitecode = "MIN")
{
Gui, 8:Add, Button, y0  h20 -Tabstop, iMedConsent
}
Gui, 8:Add, Button, y0  h20 -Tabstop, UpToDate
Gui, 8:Add, Button, y0  h20  g8Voogle -Tabstop, CPRS SEARCH (Voogle)
gui, 8:Add, Button, y0  h20 g8GetPCP -Tabstop, Add/Flag/Forward PCP


linkbarX := Px+400
linkbarY := Py + 33   ; try change from + 40

try
{
Gui, 8:Show, x%linkbarX% y%linkbarY% w800 h20 , hyperdrivebar
}

return  

Mww:
run https://cds.med.va.gov/?app=mww&utm_source=superboard
return

AmbDict:

if !FileExist(dragonpath)
{
	MsgBox, 262144, CPRS Booster, Currently this only works with DRAGON MEDICAL ONE.
	MsgBox,  262144, CPRS Booster, It does NOT appear that you have Dragon Medical One installed.
	return
}
Else
{ 
	if !winexist("ahk_exe SoD.exe")  ; dragon isn't running.
	{
		MsgBox, 262144, CPRS Booster, Dragon Medical One is not running. Please start it and try again.
		return
	}	

	gosub gui64 ; dragon is installed and running, so open the Amb dictation GUI
}

Return ; this is the Amb dictation button


8GetPCP:  ;process PCP button

if (OneTimeAddPCPEducation = 0) || (OneTimeAddPCPEducation = "") ; have to agree to terms first time.
{
goto gui49 
}
else if (OneTimeAddPCPEducation = 1)
{
gosub FlagOrSignPCP
}
else
{
return ; if they don't agree: never add-flags PCP
}


; gosub FlagOrSignPCP
return 




8ButtoniMedConsent:
gosub ActivateCPRS

gosub gotools
sleep 50

send {down 18}
send {enter}

gosub imedopen
return


8ButtonUpToDate:
SplashTextOn ,150 ,100, CPRS Booster, Working
sleep 300
SplashTextOff
run, https://vacoweb02.dva.va.gov/VALNETCC/uptodate

return


;############################################################################################
;###################Booster top toolbar Voogle button action##############################################
;############################################################################################

8Voogle:

if (OneTimeVoogleEducation = 0) || (OneTimeVoogleEducation = "") ; have to agree to terms first time.
{
goto gui46 ; will go from GUI 46--->47 (if they agree) to startvoogle label below
}
else if (OneTimeVoogleEducation = 1)
{
gosub startvoogle
}
else
{
return ; if they don't agree: never starts Voogle
}


return

;############################################################################################
;#############################END Press Voogle BUtton in Booster ###################################################
;############################################################################################

;############################################################################################
;##############################edge search funtion##########################################
;###############################edgesearch####search edge#########################################################
SearchEdge(edgeWindowName, searchWord) {
    ; Save the current clipboard to a variable
    ClipSaved := ClipboardAll
    Clipboard := ""  ; Clear the clipboard

    ; Activate the Edge window
    WinActivate, %edgeWindowName%

    ; Send Ctrl+F to open the search box
    Send ^f

    ; Send 'bstjetx' to the search box
    Send bstjetx

    ; Send Tab 3 times
    Send {Tab}
	sleep 20
	  Send {Tab}
	sleep 20
	  Send {Tab}
	sleep 20
	

    ; Copy the current selection to the clipboard
    Send ^c
    ClipWait, 1  ; Wait for the clipboard to contain data

    ; Check if the clipboard contains 'bstjetx'
    if (Clipboard = "bstjetx")
    {
        ; We are in filtersOff search mode
    }
    else
    {
        ; We are in filtersOn search mode
        ; Convert to filtersOff search mode by pressing Tab, Space, Tab, Tab
        ; Send {Tab 3} ; we're starting out from the three tabs in step #1
		
		 ; Send Tab 3 times
    Send {Tab}
	sleep 20
	  Send {Tab}
	sleep 20
	  Send {Tab}
	sleep 20
	
        Send {Space} ; clicks on the filter to toggle
        Send {Tab 2}
    }

    ; Clear the clipboard again
    Clipboard := ""

    ; Send the actual search term
    Send %searchWord%

    ; Send Tab 4 times and Space once
		 
    Send {Tab}
	sleep 20
	  Send {Tab}
	sleep 20
	  Send {Tab}
	sleep 20
	  Send {Tab}
	sleep 20
    ;Send {Tab 4}
    Send {Space}

    ; Restore the original clipboard content
    Clipboard := ClipSaved
}

; Example usage
; SearchEdge("Microsoft Edge", "your search term here")


;############################################################################################
;######################end search edge function#####################################################
;############################################################################################

;############################################################################################
;###################Find Sta3n Code function##########################################
;############################################################################################



; Function to read the CSV file and return the Sta3n code for a given SiteCode
GetSta3nCode(SiteCode) {
    global Sta3nMapDir
    ; Read the file into an array
    FileRead, content, %Sta3nMapDir%
    if (ErrorLevel) {
        MsgBox, Failed to read the file.
        return
    }
    
    ; Split the content by lines
    lines := StrSplit(content, "`n", "`r")
    
    ; Iterate over each line and split by comma
    Loop, % lines.MaxIndex()
    {
        ; Skip the header line
        if (A_Index = 1) {
            continue
        }
        
        line := lines[A_Index]
        columns := StrSplit(line, ",")
        
        ; Check if the first column matches the SiteCode
        if (columns[1] = SiteCode) {
            return columns[2]
        }
    }
    
    ; Return a message if the SiteCode is not found
    return "SiteCode not found"
}








;############################################################################################
;###################start find and click voogle maintenance bar##########################################################
;############################################################################################

voogmaint:

/*


;  **** FIND VOOGLE maintenance bar (we are in the start voogle subroutine)
coords := ColorSearch("Voogle", "0xFFF3CD", 100 , "q2", "BR")
if (coords)   ; only do this if we found the color 
	{
	;; VooglMaintX := coords.windowX
	; VooglMaintY := coords.windowY 
	MainwithOffsetX := VooglMaintX - 600  
	MainwithOffsety := VooglMainty - 15
	mouseclick, left, %MainwithOffsetx%, %MainwithOffsety%
	sleep 50
	send {tab}
	sleep 30
	send {space}
	}

;******end find voogle maint
*/
return

;############################################################################################
;######################end click voog maintenance################################################
;############################################################################################


;############################################################################################
;#########################START VOOGLE######################################################
;############################################################################################


startvoogle:

		Sta3nCode := GetSta3nCode(SiteCode)
		
		VoogleURL := "https://cds.med.va.gov/smart-container/index.html?app=voogle&source=booster&sta3n=" . Sta3nCode
; MsgBox, 262144, CPRS Boosters, %voogleurl%

   ;  Run, https://cds.med.va.gov/smart-container/index.html?app=voogle&source=booster
	run, %VoogleURL%

/*    don't run booster helper for now beta
SetTitleMatchMode, RegEx
winwait, Voogle and|Voogle - Work ,, 12 

sleep  500
gosub ClickVoogleAgree	

if (vooglelauncherror != 1)   ; don't do this if we have error
{
gosub gui45 ; paint voogle helper gui ; find voogle bar now built into this

gosub clicksensitive

}

*/



/*  NOT LIVE>>>>>>
gosub Getpatientinfo

;**********start Voogle webpage************
 run, https://voogle.vha.med.va.gov/

SetTitleMatchMode, RegEx
winwait, Voogle and|Voogle - Work ,, 12
			
sleep 500
gosub ClickVoogleAgree	
gosub findvooglebar ; this does NOT click on vooglebar
gosub gui45 ; paint voogle helper gui 

gosub clickvooglebar
sleep 50
gosub tabToVoogPtinfobox
sleep 50
send %PatientName%
sleep 1000


;############################################################################################
;#########################Within the Start pt sequence#########################################
;###########################verify we have the correct pt#################################################################


lastFour := SubStr(reformattedSSN, -3)  ; Get the last 4 characters

; Save the current clipboard content
savedClipboard := Clipboard

startTime := A_TickCount  ; Record the start time
timeout := 10000  ; Set timeout period to 10 seconds (10000 milliseconds)

foundDash := false

loop 
{
    ; Move the cursor to the end of the text box
    Send, {Right}
	sleep 50
send {down}
sleep 50
send {enter}
sleep 100

;;;; {HERE WE NEED TO SOLVE SENSATIVE PATIENT ISSUE: could take the place of sleep 100?}
;;; it will pop up after enter

    ; Send keystrokes to select the last six characters
    Send, +{Left 6}  ; Hold Shift and press Left Arrow 6 times to select the last 6 characters
    Send, ^c  ; Copy the selected text to the clipboard

    ; Wait for the clipboard to contain the copied text
    ClipWait, 3
    if (ErrorLevel)
			{
				MsgBox, 262144, CPRS Booster, Something went wrong. Try pressing the Booster CPRS Search Button again. 
		
				; Restore the previous clipboard content
				Clipboard := savedClipboard
				return
			}

    ; Small delay to ensure clipboard has updated content
    Sleep, 100

    ; Retrieve the copied text from the clipboard
    clipboardText := Clipboard

			; Check if the first character is a dash
			if (SubStr(clipboardText, 1, 1) = "-") 
			{
				foundDash := true
				break
			}

			; Check if the timeout period has been reached
			if (A_TickCount - startTime > timeout)
			{
				MsgBox, Can't Find The Patient in Voogle. Try pressing Voogle Button In Booster Again.
				; Restore the previous clipboard content
				Clipboard := savedClipboard
				return
			}
	sleep 100 ; wait before next selection of 6 charactes
} ; END of loop looking for the dash after pt name and before last 4 in Voogle.

if (foundDash) {
    ; Extract the last four characters from the six-character selection
    lastFourFromText := SubStr(clipboardText, 3)

    ; Compare the copied text to the last four characters of reformattedSSN
    if (lastFourFromText = lastFour) {
        ; MsgBox, Correct Patient
		send {right}
		sleep 50
    } else {
        MsgBox, Wrong Patient
    }
}

; Restore the previous clipboard content
Clipboard := savedClipboard



;############################################################################################
;###################End patient verify subcomponent####################################################
;############################################################################################


send {tab 4}

patientname := "" ; clear variable
reformattedSSN := ""
lastFour := ""


*/

vooglelauncherror := 0 ; everything is good if we got to here

return 





;############################################################################################
;###############END Start Voogle##############################
;############################################################################################


;############################################################################################
;###############Handle Sensitive info button in Voogle.###########################################
;############################################################################################

clicksensitive:

gosub ActivateVoogle

coords := ColorSearch(browserTitle, "0xFFC107",3000 , "q4", "TL") ; sets coords  


if (coords !=false)
{
sleep 200
gosub clickoncolor ; clicks on the coords
}

return
;############################################################################################
;############################################################################################
;############################################################################################





; Sign|Add RN1|Add RN2|Add MSA|Add BOTH|Add PHARM|Unflag|Next Patient|Make Addendum|Add PROV1|Add PROV2|Phone Clinic|F2F Clinic|

shorten(x) ; this function ALTERS THE DISPLAY NAME FOR FLOATING FXN CHEAT SHEET

{

if (x = "Sign") 
 {
 short := "Sign"
 }
 
 if (x = "Add/Flag PCP") 
	{
	short := "PCP"
	}


if (x = "Edit Note") 
 {
 short := "Edit"
 } 
 
 if (x = "Find @@@") 
	{
	short := "@@@"
	}
if (x = "Quick") 
	{
	short := "Quick"
	}

if (x = "Spell Check") 
 {
 short := "Spell Chk"
 } 
 
 
if (x = "Add Misc") 
 {
 short := "Add Misc"
 } 
 
 
if (x = "Add RN1") 
 {

 short := Substr(Nurse1, 1, 4) ; gets first three
 StringUpper, short, short, T   ; converts to first capital letter

 }

if (x = "Add RN2")
 { 
;  short := "RN2"
 short := Substr(Nurse2, 1, 4) ; gets first three
 StringUpper, short, short, T   ; converts to first capital letter
 }

 if (x = "Add BOTH")
 {
 short := "Both"
 }

if (x = "Add PHARM") 
 {
 ; short := "Pharm"
 short := Substr(pharm, 1, 4) ; gets first three
 StringUpper, short, short, T   ; converts to first capital letter
 }

if (x = "Unflag")
 {
 short := "Unflag"
 }
 
 if (x = "Flag")
 {
 short := "Flag"
 }

if (x = "Add MSA")
 {
;  short := "MSA"
 short := Substr(MSA1, 1, 4) ; gets first three
 StringUpper, short, short, T   ; converts to first capital letter
 }

if (x = "Next Patient")
  {
   short := "Next"
  }
if (x = "Make Addendum")
  {
   short := "Addend"
  }

if (x = "Add PROV1")
  {
 ;   short := "Prov1"
 short := Substr(Prov1, 1, 4) ; gets first three
 StringUpper, short, short, T   ; converts to first capital letter
  }

if (x = "Add PROV2")
  {
  ; short := "Prov2"
 short := Substr(Prov2, 1, 4) ; gets first three
 StringUpper, short, short, T   ; converts to first capital letter
  }

; ---------------Additional, additional signers

if (x = "Add Person1")
  {

 short := Substr(Person1, 1, 4) ; gets first three
 StringUpper, short, short, T   ; converts to first capital letter
  }

if (x = "Add Person2")
  {

 short := Substr(Person2, 1, 4) ; gets first three
 StringUpper, short, short, T   ; converts to first capital letter
  }

if (x = "Add Person3")
  {

 short := Substr(Person3, 1, 4) ; gets first three
 StringUpper, short, short, T   ; converts to first capital letter
  }

if (x = "Add Person4")
  {

 short := Substr(Person4, 1, 4) ; gets first three
 StringUpper, short, short, T   ; converts to first capital letter
  }

if (x = "Add Person5")
  {
 short := Substr(Person5, 1, 4) ; gets first three
 StringUpper, short, short, T   ; converts to first capital letter
  }

if (x = "Add Person6")
  {

 short := Substr(Person6, 1, 4) ; gets first three
 StringUpper, short, short, T   ; converts to first capital letter
  }
; ---------------- end of extra additional signers




if (x = "Phone Clinic")
  {
   short := "Phone"
  }

if (x = "F2F Clinic")
  {
   short := "F2F"
  }

if (x = "VVC Clinic")
  {
   short := "VVC"
  }

; if (x = "Sign") short := "Sign"
; if (x = "Sign") short := "Sign"


return short
}


			
;-------------------------GUI FOR SETUP SCREEN BELOW (CTRL H)

^H::
gui, destroy
gosub refreshdata
Gui 14: Destroy
gui 7: destroy ;Destroy
gui 8: destroy
;-----------------mask the sigcode
SigLen := Strlen(SigCode)
;msgbox, %SigCode%
;msgbox, %SigLen%
SigMask := ""
loop %SigLen%
{
SigMask = *%SigMask%
}

;Msgbox, %SigMask%
;--------------end of masking


If WinExist("Minneapolis VA Informatics") ;---- if they are already on set up screen
{

winactivate, Minneapolis VA Informatics
;MsgBox,0,CPRS Booster: Been there Done that, The help/setup screen is already open somewhere. How much help do you need? :) 
return
}

;-----------display setup/instructions screen

instru := "
(
Instructions: Fill out the fields below. Names of individuals (RN, MSA, etc) need to exactly match the format in CPRS additional signer: last,first (no spaces).

Skip any fields you won't need.
)"

; helpvid := "https://gcc01.safelinks.protection.outlook.com/?url=https`%3A`%2F`%2Fweb.microsoftstream.com`%2Fvideo`%2Fc935ad80-37dc-4155-9126-3446c345ca32`%3FchannelId`%3D1527ec07-e93e-4321-996e-336cfb24fdbb&data=04`%7C01`%7C`%7C18c04554a4de459bc71608d8d9b5bbd9`%7Ce95f1b23abaf45ee821db7ab251ab3bf`%7C0`%7C0`%7C637498721858382121`%7CUnknown`%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0`%3D`%7C1000&sdata=QLqQlu6b6OvD3j`%2BBTM2rpBMi2eMg`%2FnD60qJmTLnxzNg`%3D&reserved=0"

Gui, Font, s11, Verdana  ; Set Verdana.
Gui, Add, Text, X5 Y5 w600 R4, %instru%
Gui, Font
Gui, Font, Underline cBlue s13, Verdana 
Gui, Add, Text, gAllHelp  w400 h30, How To Use CPRS Booster? CLICK HERE ; This just displays the text
Gui, Add, Text, gTroubleshooting  x600 y7 w350 h30, TROUBLESHOOTING: CLICK HERE ; This just displays the text

Gui, Add, Text, greleaseit x950 y7 w260 h30, SETTINGS: CLICK HERE
Gui, Add, Text, gWhatsNew x950 y50 w260 h60, WHAT'S NEW IN BOOSTER?

; Gui, Add, Link, x640 y50, <a href="%helpvid%">VIDEO TUTORIALS: CLICK HERE</a>
Gui, Add, Text, gVidfromCtrlH x600 y50 w300 h30, VIDEO TUTORIALS: CLICK HERE ; 

; Gui, Add, Text, gopenfxnscreen x450 y90 w500 h30, Use the Function Keys to GO FASTER: CLICK HERE ; This just displays the text
Gui, Font
Gui, Font, s11, Verdana  ; Set Verdana.


Gui, Font, s13, Verdana  ; Set 13-point Verdana.
Gui, Add, Text, x12 y145 w50 h30, Nurse ; This just displays the text 
Gui, Add, Text, x12 y+20 w100 h30, Nurse 2 ; This just displays the text 
Gui, Add, Text, x12 y+20 w100 h30, MSA ; This just displays the text
Gui, Add, Text, x12 y+20 w120 h30, Pharmacist ; This just displays the text
Gui, Add, Text, x12 y+20 w140 h30, Signature Code ; This just displays the text
Gui, Add, Text, x12 y+20 w120 h30, F2F Clinic ; This just displays the text 
Gui, Add, Text, x12 y+20 w120 h30, Phone Clinic ; This just displays the text
Gui, Add, Text, x12 y+20 w120 h30, VVC Clinic ; This just displays the text 
Gui, Add, Text, x12 y+20 w120 h30, Provider 1 ; This just displays the text

Gui, Font, Underline cBlue s10, Verdana
Gui, Add, Text, gextraadd x12 y+5 w250 h20, Want More Signers?
 


;----------------display entry boxes (edit boxes)

Gui, Font
Gui, Font, s13, Verdana 
Gui, Add, Edit, x165 y145 w225 h30 vRN1, %Nurse1% ;this is is the actual input box, so we must attach a variable to it. IE: vRN 
Gui, Add, Edit, x165 y+20 w225 h30 vRN2, %Nurse2% ; This is the actual input box, so we must attach a variable to it. 
Gui, Add, Edit, x165 y+20 w225 h30 vMSA, %MSA1% ; This is the actual input box, so we must attach a variable to it. 
Gui, Add, Edit, x165 y+20 w225 h30 vPharm1, %Pharm% ; This is the actual input box, so we must attach a variable to it. 
Gui, Add, Edit, x165 y+20 w225 h30 vCode, %SigMask% ; This is the actual input box, so we must attach a variable to it. 
Gui, Add, Edit, x165 y+20 w225 h30 vF2F, %f2fclinic% ; This is the actual input box, so we must attach a variable to it. 
Gui, Add, Edit, x165 y+20 w225 h30 vPhone,%phoneClinic% ; This is the actual input box, so we must attach a variable to it.
Gui, Add, Edit, x165 y+20 w225 h30 vVVC, %VVC% ; This is the actual input box, so we must attach a variable to it. 
Gui, Add, Edit, x165 y+20 w225 h30 vMD1, %Prov1% ; This is the actual input box, so we must attach a variable to it. 

;-------------------text showing key PSEUDOHYPERLINKS
Gui, Font, underline s11, Verdana  ; Set Verdana.
Gui, Add, Text, x425 y125 w300 h30, Shortcuts That Use This: ; This just displays the text 
Gui, Font
Gui, Font, Underline cBlue s13, Verdana 

Gui, Add, Text, gLink1 x425 y145 w250 h30, Ctrl-N,Ctrl-B,Ctrl-R ; pseudohyperlink
Gui, Add, Text, gLink2 x425 y+20 w250 h30, Alt-N (ALT-ernate Nurse) ; pseudohyperlink
Gui, Add, Text, gLink3 x425 y+20 w250 h30, Ctrl-M, Ctrl-B,Ctrl-R ; pseudohyperlink
Gui, Add, Text, gLink7 x425 y+20 w250 h30, Ctrl-F (Farmacist:P taken) ; pseudohyperlink
Gui, Add, Text, gLink4 x425 y+20 w250 h30, Ctrl-S ; pseudohyperlink
Gui, Add, Text, gLink5 x425 y+20 w250 h30, SHIFT-Ctrl-F (F-ace to face) ; pseudohyperlink
Gui, Add, Text, gLink6 x425 y+20 w250 h30, SHIFT-Ctrl-P (P-hone) ; pseudohyperlink
Gui, Add, Text, gLink6 x425 y+20 w250 h30, SHIFT-Ctrl-V (V-VC) ;  this is now VVC clinic: change glink prn (no current glink for this)
Gui, Add, Text, gLink10 x425 y+20 w250 h30, Ctrl-P ; pseudohyperlink

Gui, Add, Text, gLink8 x200 y650 w200 h20, Alt-C: starts CPRS ; pseudohyperlink



fctlbl := HasVal(fxn, "Unflag")
if fctlbl = Click here to assign
{
fctlbl := ""
}
Gui, Add, Text, gLink9 x400  y650 w200 h20, Ctrl-U (%fctlbl%): Unflags ; pseudohyperlink


fctlbl := HasVal(fxn, "Make Addendum")
if fctlbl = Click here to assign
{
fctlbl := ""
}
Gui, Add, Text, gLink12 x650  y650 w300 h20, Ctrl-A (%fctlbl%): Make Addendum ; pseudohyperlink

fctlbl := HasVal(fxn, "Next Patient")
if fctlbl = Click here to assign
{
fctlbl := ""
}
Gui, Add, Text, gopenfxnscreen x200  y670 w250 h30, %fctlbl%: Next Patient ; pseudohyperlink

Gui, Add, Text, glink20 x400  y670 w250 h30, Ctrl-I: I-gnore Flag

fctlbl := HasVal(fxn, "Edit Note")
if fctlbl = Click here to assign
{
fctlbl := ""
}
Gui, Add, Text, gopenfxnscreen  x650  y670 w300 h20, Ctrl-E (%fctlbl%): Edit Note 


fctlbl := HasVal(fxn, "Add Misc")
if fctlbl = Click here to assign
{
fctlbl := "(unassigned)"
}
Gui, Add, Text, gopenfxnscreen  x940  y670 w250 h20, %fctlbl%: Add Misc ; pseudohyperlink


fctlbl := HasVal(fxn, "Spell Check")
if fctlbl = Click here to assign
{
fctlbl := "(unassigned)"
}
Gui, Add, Text, gopenfxnscreen  x940  y650 w250 h20, %fctlbl%: Spell Check ; pseudohyperlink


fctlbl := HasVal(fxn, "Add/Flag PCP")
if fctlbl = Click here to assign
{
fctlbl := "(unassigned)"
}
Gui, Add, Text, gopenfxnscreen  x930  y630 w250 h20, %fctlbl%: Add/Flag PCP  ; pseudohyperlink


fctlbl := HasVal(fxn, "Find @@@")
if fctlbl = Click here to assign
{
fctlbl := "(unassigned)"
}

fctlbl := HasVal(fxn, "Quick")
if fctlbl = Click here to assign
{
fctlbl := "(unassigned)"
}

Gui, Add, Text, gopenfxnscreen  x930  y600 w250 h20, %fctlbl%: Find @@@  ; pseudohyperlink




Gui, Font
Gui, Font, s11, Verdana  ; Set Verdana.
Gui, Add, Button, x250 y600  w500 h30 gnotesetupinfo , ONE BUTTON NEW NOTES: CLICK HERE TO SET UP ; Button to submit the information


;-----------------------------------------Show function key assignment on main GUI
Gui, Font
Gui, Font, underline s11, Verdana  ; Set Verdana.
Gui, Add, Text, x710 y125 w300 h30, Assigned Function Key(s): ; This just displays the text 
Gui, Font
Gui, Font, Underline cBlue s13, Verdana


; ---- |Add RN1|Add RN2|Add MSA|Add BOTH|Add PHARM|Unflag|Next Patient|Make Addendum|Add PROV1|Add PROV2|Phone Clinic|F2F Clinic|

fctlbl := HasVal(fxn, "Add RN1")
Gui, Add, Text, gopenfxnscreen x710 y145 w300 h30, %fctlbl% ; pseudohyperlink
fctlbl := HasVal(fxn, "Add RN2")
Gui, Add, Text, gopenfxnscreen x710 y+20 w300 h30, %fctlbl% ; pseudohyperlink
fctlbl := HasVal(fxn, "Add MSA")
Gui, Add, Text, gopenfxnscreen x710 y+20 w300 h30, %fctlbl% ; pseudohyperlink
fctlbl := HasVal(fxn, "Add PHARM")
Gui, Add, Text, gopenfxnscreen x710 y+20 w300 h30, %fctlbl% ; pseudohyperlink
fctlbl := HasVal(fxn, "Sign")
Gui, Add, Text, gopenfxnscreen x710 y+20 w300 h30, %fctlbl% ; pseudohyperlink
fctlbl := HasVal(fxn, "F2F Clinic")
Gui, Add, Text, gopenfxnscreen x710 y+20 w300 h30, %fctlbl% ; pseudohyperlink
fctlbl := HasVal(fxn, "Phone Clinic")
Gui, Add, Text, gopenfxnscreen x710 y+20 w300 h30, %fctlbl% ; pseudohyperlink
fctlbl := HasVal(fxn, "VVC Clinic")
Gui, Add, Text, gopenfxnscreen x710 y+20 w300 h30, %fctlbl% ; pseudohyperlink
fctlbl := HasVal(fxn, "Add PROV1")
Gui, Add, Text, gopenfxnscreen x710 y+20 w300 h30, %fctlbl% ; pseudohyperlink




Gui, Add, Button, x2 y620  w80 h30 , OK ; Button to submit the information


;-------------------------end of help links
;############################################################################################
;########################dragon column on Ctrl H######################################################
;############################################################################################

;-------------------text showing key PSEUDOHYPERLINKS

Gui, font	
Gui, Font, underline s11, Verdana  ; Set Verdana.
Gui, Add, Text, x980 y125 w300 h30, Voice Command (Dragon): ; This just displays the text 
Gui, Font
Gui, Font, s13, Verdana 

Gui, Add, Text,  x980 y145 w250 h30, Dot Nurse 
Gui, Add, Text,  x980 y+20 w250 h30, 
Gui, Add, Text,  x980 y+20 w250 h30, Dot MSA
Gui, Add, Text,  x980 y+20 w250 h30, Dot Pharm
Gui, Add, Text,  x980 y+20 w250 h30, Dot Sign
Gui, Add, Text,  x980 y+20 w250 h30, 
Gui, Add, Text,  x980 y+20 w250 h30, 
Gui, Add, Text,  x980 y+20 w250 h30, 
Gui, Add, Text,  x980 y+20 w250 h30, Dot Provider






Gui, Show, x10 y0 w1200 h700, Minneapolis VA Informatics ; Display the GUI, x and y tell where to show the window at on the screen and h and w tell what size to make it

Return

GuiClose:
   Gui, Destroy ; Destroy the GUI to get it out of the way
  lastwin:= "notCPRS" ; make the floating help bar pop back up with next left click

return






starttitlemap:  ; button to map notetitle

   Gui, Destroy ; Destroy the GUI to get it out of the way
  lastwin:= "notCPRS" ; make the floating help bar pop back up with next left click
  
  
   if (strlen(notetitle1) < 4) && (strlen(notetitle2) < 4) ; this means first time set up
   {
	SplashTextOn ,150 ,
   gosub importtitles ; gets favs from CPRS (wait: do we need this each time?)
   }
   
   
  gosub autonote ; this is just the UI and data collection point.  Set up

return



;----------------Start of OK button processing on Help and Setup screen

ButtonOK: ; Execute the following actions when the button from the GUI OK is pressed
Gui, Submit ; Save all the information in the GUI (The variables)
Gui, Destroy ; Destroy the GUI to get it out of the way

;MsgBox, %RN1%   `n %RN2% `n %MSA% `n %Code% ; Display a message box to show what the user inputted. `n = an Enter key
;Return


;              -------------------write collected info to user's file

;----SigCode is the incoming sig code; Code is the outgoing; need to see if it was changed or not; **BUT masking changes outgoing
l := strlen(sigcode)

;msgbox, %sigcode% is inbound prior to form
;msgbox, sigcode length is %l%
;msgbox, %SigMask% is the masked diplay ; AND is the inbound to FORM with ***
;msgbox, %Code% is the outbound from form




If InStr(Code, Sigmask) and l > 0 then       

;if code = %Sigmask% then ;-----------Not change: === ************** don't let masking asterisks become the sig code

{
  ; MsgBox, The string was found. %SigCode%" Old: Didn't change"
   Code = %SigCode% ;don't let sigmask trickle through
   ; Msgbox, outbound code was changed to %Code%
}  
Else

{
 ; MsgBox, User Changed Sig code so %Code% will be written out; so Code variable will be the actually output to write from form
}
;-----------

;msgbox, %Code% is being written to file

gosub, writeit
sleep 10 ; data deletion issue: may not be able read if writing lags
gosub, refreshdata  ;----need to refresh the working variables


Return ;--------------THIS IS the return from the OK button


;############################################################################################
;######################################START of VIDEO MENU############################################
;############################################################################################


VidfromCtrlH:
comingfromctrlH := 1 ; set variable prior to section below.
gosub openVideoscreen

return



openVideoscreen:
gui18:

if (comingfromctrlH = 1)
{
Gui, 18: Destroy ; Destroy the GUI to get it out of the way
comingfromctrlH := 0
} ; for some reason this is also destroying gui 12 (dotphrase displayer)
  instru := "

(
Supercharge CPRS. The video above gets you started. 
***Note: Dot Phrases are NOT covered in this video but...
...you should also learn about them (videos below).

)"

Gui, 18: Font, s12, Verdana  ; Set Verdana
; Gui, 18: Add, Text, X5 Y5 w600 R15, %instru%
Gui, 18: Font, cBlue underline s12, Verdana
Gui, 18: Add, Text, gmainvid x10 y20 w400 R2, Main Booster Tutorial (13 min): Click here
Gui, 18: Font, Norm
Gui, 18: Font, CBlack s12, Verdana  ; Set Verdana
Gui, 18: Add, Text, X40 Y40 w600 R15, %instru%

;;;;;;;;;;;;;;;;RIGHTHAND COLUMN;;;;;;

  instru := "

(
Easily Flag Orders

)"

Gui, 18: Font, s12, Verdana  ; Set Verdana
Gui, 18: Font, cBlue underline s12, Verdana
Gui, 18: Add, Text, gflagvid x550 y20 w370 R2, Automatic Order Flagging (2 Min): Click here
Gui, 18: Font, Norm
Gui, 18: Font, CBlack s12, Verdana  ; Set Verdana
Gui, 18: Add, Text, X550 yp+20 w300 R1, %instru%

Gui, 18: Font, s12, Verdana  ; Set Verdana
Gui, 18: Font, cBlue underline s12, Verdana
Gui, 18: Add, Text, gaffPCP  x600 y+20 w360 R2, Add/Flag/Forward PCP Button Details





;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;RIGHTHAND COLUMN;;;;;;

  instru := "

(
Open New Notes Quickly
)"

Gui, 18: Font, s12, Verdana  ; Set Verdana
Gui, 18: Font, cBlue underline s12, Verdana
Gui, 18: Add, Text, gNewNvid x550 yp+60 w370 R2, One Click New Notes (3 Min): Click here
Gui, 18: Font, Norm
Gui, 18: Font, CBlack s12, Verdana  ; Set Verdana
Gui, 18: Add, Text, X550 yp+20 w300 R2, %instru%




;;;;;;;;;;;;;;;;;;;




instru := "

(
F1 Signs Any Refill Order.
No unflagging needed
)"


Gui, 18: Font, s12, Verdana  ; Set Verdana
Gui, 18: Font, cBlue underline s12, Verdana
Gui, 18: Add, Text, gRxAlertsvid x552 y250 w360 R2 , Med Refill Automation (1 min): Click Here
Gui, 18: Font, Norm
Gui, 18: Font, CBlack s12, Verdana  ; Set Verdana
Gui, 18: Add, Text, X552 y270 w500 R2, %instru%



; VARIABLE TEXT FOR AMB PILOT PARTICIPANTS
If (AmbScribePilotParticipant = 1)
{


instru := "

(
Dragon listens to your clinic visits
... and AI helps write your notes!
)"

			Gui, 18: Font, s12, Verdana  ; Set Verdana
			Gui, 18: Font, cBlue underline s12, Verdana
			Gui, 18: Add, Text, gAmbscribehelpVid x552 y370 w360 R1 , Ambient Scribe (5 min): Click Here
			Gui, 18: Add, Text, gAmbscribehelp x600 y392 w360 R1 , Printed Instructions: Click Here
			Gui, 18: Font, Norm
			Gui, 18: Font, CBlack s12, Verdana  ; Set Verdana
			Gui, 18: Add, Text, X550 y415 w500 R2, %instru%

}
;;;;;;;;;;;;;;;;;;;;;;

  instru := "

(
Dragon: Skip the keyboard altogether!
Simply SPEAK Booster commands.
Dragon dictation is available to all VA users.


)"

Gui, 18: Font, s12, Verdana  ; Set Verdana
Gui, 18: Font, cBlue underline s12, Verdana
Gui, 18: Add, Text, gdragvid x10 y120 w500 R2, Dragon And Booster - Better Together (3 Min): Click here
Gui, 18: Font, Norm
Gui, 18: Font, CBlack s12, Verdana  ; Set Verdana
Gui, 18: Add, Text, X40 yp+20 w450 R15, %instru%




;;;;;;;;;;;;;;;;;;;

  instru := "

(
Dot Phrases! Work in ANY program (not just CPRS). 
Don't type the same text again and again into e-mail,
or CPRS or Teams or ... anywhere: use Dot Phrases.

)"

Gui, 18: Font, s12, Verdana  ; Set Verdana
; Gui, 18: Add, Text, X5 Y5 w600 R15, %instru%
Gui, 18: Font, cBlue underline s12, Verdana
Gui, 18: Add, Text, gdpvid x10 yp+100 w400 R2, Dot Phrases Tutorial (4 Min): Click here
Gui, 18: Font, Norm
Gui, 18: Font, CBlack s12, Verdana  ; Set Verdana
Gui, 18: Add, Text, X40 yp+20 w450 R15, %instru%

  instru := "
(
Share your dot phrases. Quickly find dot phrases
that others have created that you could be using.
)"

Gui, 18: Font, s12, Verdana  ; Set Verdana
; Gui, 18: Add, Text, X5 Y5 w600 R15, %instru%
Gui, 18: Font, cBlue underline s12, Verdana
Gui, 18: Add, Text, gdpNatLib x10 yp+100 w500 R2, The National Dot Phrase Library (Click here)
Gui, 18: Font, Norm
Gui, 18: Font, CBlack s12, Verdana  ; Set Verdana
Gui, 18: Add, Text, X40 yp+20 w400 R15, %instru%


  instru := "

(
For a given patient, quickly search data from ALL VAs in the country
Search or trend labs; search progress notes; ....

)"

Gui, 18: Font, s12, Verdana  ; Set Verdana
; Gui, 18: Add, Text, X5 Y5 w600 R15, %instru%
Gui, 18: Font, cBlue underline s12, Verdana
Gui, 18: Add, Text, gVoogvid x10 yp+100 w500 R2, CPRS Search: Become a Search Guru! (Click here)
Gui, 18: Font, Norm
Gui, 18: Font, CBlack s12, Verdana  ; Set Verdana
Gui, 18: Add, Text, X40 yp+20 w600 R15, %instru%




Gui, 18: Add, Button,x50 y570 w100 , OK ; Button to submit the information
; Gui, 18: Add, Button,x170 y450 w100 , Cancel ; Button to submit the information

Gui, 18: Show, x100 y15 w1000 h600 , Booster Help Videos ; Display the GUI, x and y tell where to show the window at on the screen and h and w tell what size to make it
return ; return for Gui 18


18GuiClose:
 Gui, 18: Destroy ; Destroy the GUI to get it out of the way
return

18ButtonOK:
   
; Gui, 18: Submit ; Save all the information in the GUI (The variables) 
 
Gui, 18: Destroy ; Destroy the GUI to get it out of the way
 
return 


dpNatLib:
MsgBox, 262144, CPRS Booster, To use the National Dot Phrase Library, go to your dot phrases screen in Booster. Click the 'National Dot Phrase Library' button at the bottom. It will guide you from there.

return

Voogvid:

SplashTextOn ,150 ,100, CPRS Booster, Just a second....
sleep 700
SplashTextOff
run %Vooglehelpdoc%

; run https://dvagov.sharepoint.com/:w:/s/CPRSBooster950/ESdN0yYDfZBApMdl7cGEQdwBlqRdXgcIoUW_gKATucfoYQ?e=wr0BYe

return


affPCP:
gosub gui51
return





mainvid:

helpvid := "https://gcc02.safelinks.protection.outlook.com/?url=https%3A%2F%2Fdvagov.sharepoint.com%2F%3Av%3A%2Fs%2FVHAIPX%2FERTUvZ6xQ-RIrEyJXtT9UTUB54LgGnLSCQMioy2Cs6FJiQ%3Fe%3DAWVowg&data=05%7C02%7C%7Cc52890dd4ea7493a798b08dc347ea188%7Ce95f1b23abaf45ee821db7ab251ab3bf%7C0%7C0%7C638442965679204658%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C0%7C%7C%7C&sdata=1j36LIeyhApftYhajG9j2aCrS8KkJj6B3P0O03TCvy0%3D&reserved=0"
; OLD helpvid := "https://gcc01.safelinks.protection.outlook.com/?url=https`%3A`%2F`%2Fweb.microsoftstream.com`%2Fvideo`%2Fc935ad80-37dc-4155-9126-3446c345ca32`%3FchannelId`%3D1527ec07-e93e-4321-996e-336cfb24fdbb&data=04`%7C01`%7C`%7C18c04554a4de459bc71608d8d9b5bbd9`%7Ce95f1b23abaf45ee821db7ab251ab3bf`%7C0`%7C0`%7C637498721858382121`%7CUnknown`%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0`%3D`%7C1000&sdata=QLqQlu6b6OvD3j`%2BBTM2rpBMi2eMg`%2FnD60qJmTLnxzNg`%3D&reserved=0"
Gui, 18: Destroy
run  %helpvid%
return
 
 newnVid:
 helpvid := "https://dvagov-my.sharepoint.com/:v:/g/personal/jessica_bradley2_va_gov/EY4qLZ-VPxdBu2_WNZS1i1QB6urYNZFhLc3x3HEGZXA5ag?e=WFTGAm&nav=eyJyZWZlcnJhbEluZm8iOnsicmVmZXJyYWxBcHAiOiJTdHJlYW1XZWJBcHAiLCJyZWZlcnJhbFZpZXciOiJTaGFyZURpYWxvZy1MaW5rIiwicmVmZXJyYWxBcHBQbGF0Zm9ybSI6IldlYiIsInJlZmVycmFsTW9kZSI6InZpZXcifX0%3D"
; OLD helpvid := "https://gcc01.safelinks.protection.outlook.com/?url=https`%3A`%2F`%2Fweb.microsoftstream.com`%2Fvideo`%2Fc935ad80-37dc-4155-9126-3446c345ca32`%3FchannelId`%3D1527ec07-e93e-4321-996e-336cfb24fdbb&data=04`%7C01`%7C`%7C18c04554a4de459bc71608d8d9b5bbd9`%7Ce95f1b23abaf45ee821db7ab251ab3bf`%7C0`%7C0`%7C637498721858382121`%7CUnknown`%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0`%3D`%7C1000&sdata=QLqQlu6b6OvD3j`%2BBTM2rpBMi2eMg`%2FnD60qJmTLnxzNg`%3D&reserved=0"
Gui, 18: Destroy
run  %helpvid%
return


RxAlertsvid:
helpvid := "https://dvagov-my.sharepoint.com/:v:/g/personal/adam_bock_va_gov/EcvvcTqObRNMoFbjGlLB6wYBZ5QmV_0WWMqDpIqNpzR2Rw?e=ySQL1U&nav=eyJyZWZlcnJhbEluZm8iOnsicmVmZXJyYWxBcHAiOiJTdHJlYW1XZWJBcHAiLCJyZWZlcnJhbFZpZXciOiJTaGFyZURpYWxvZy1MaW5rIiwicmVmZXJyYWxBcHBQbGF0Zm9ybSI6IldlYiIsInJlZmVycmFsTW9kZSI6InZpZXcifX0%3D"
Gui, 18: Destroy
run  %helpvid%
return

dragvid:
helpvid := "https://gcc02.safelinks.protection.outlook.com/?url=https%3A%2F%2Fweb.microsoftstream.com%2Fvideo%2F6ab56f11-8862-44c6-a712-0ae2684b2094&data=05%7C01%7C%7C8d2405baba394177168a08da3fefcad9%7Ce95f1b23abaf45ee821db7ab251ab3bf%7C0%7C0%7C637892596369979028%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C3000%7C%7C%7C&sdata=2%2Bp096iRRGvqTH%2FycoYnAdjE5QsdjikM%2BJDwn7ESb3g%3D&reserved=0"
Gui, 18: Destroy
run  %helpvid%
return


flagvid:
helpvid := "https://dvagov-my.sharepoint.com/:v:/g/personal/adam_bock_va_gov/EZ_6oqrYiwJCnrjOG_WrvpwBBKPAONsd7B0fidmmtIWhkw?e=Lk5uYF&nav=eyJyZWZlcnJhbEluZm8iOnsicmVmZXJyYWxBcHAiOiJTdHJlYW1XZWJBcHAiLCJyZWZlcnJhbFZpZXciOiJTaGFyZURpYWxvZy1MaW5rIiwicmVmZXJyYWxBcHBQbGF0Zm9ybSI6IldlYiIsInJlZmVycmFsTW9kZSI6InZpZXcifX0%3D"
Gui, 18: Destroy
run  %helpvid%
return


dpvid:
Gui, 18: Destroy
; helpvid := "https://dvagov.sharepoint.com/:v:/s/VHAIPX/Eb35yVpXO_5Jh4o3_UvUSQYBXPEquWs7MGsyw0nrvcNJMA?e=utR0sH&xsdata=MDV8MDJ8fGJjODcyZDJiYmE2MDQzYTUxYTBlMDhkYzYwODJkZDc3fGU5NWYxYjIzYWJhZjQ1ZWU4MjFkYjdhYjI1MWFiM2JmfDB8MHw2Mzg0OTEzNjIzODcyMjkxODl8VW5rbm93bnxUV0ZwYkdac2IzZDhleUpXSWpvaU1DNHdMakF3TURBaUxDSlFJam9pVjJsdU16SWlMQ0pCVGlJNklrMWhhV3dpTENKWFZDSTZNbjA9fDB8fHw%3d&sdata=RDUwRzEvTHJqY3BZZVRnMEo1MFY2QnJ2bDhNQ2ttWktJYlpOWmEwb3lhST0%3d"


helpvid := "https://dvagov.sharepoint.com/sites/VHAIPX/_layouts/15/stream.aspx?id=%2Fsites%2FVHAIPX%2FResources%2FVideos%2FDot%20Phrases%20the%20basics%2Emp4&ga=1&LOF=1&referrer=StreamWebApp%2EWeb&referrerScenario=AddressBarCopied%2Eview"
;  OLD = "https://gcc02.safelinks.protection.outlook.com/?url=https%3A%2F%2Fdvagov-my.sharepoint.com%2F%3Av%3A%2Fg%2Fpersonal%2Fmichael_lindow_va_gov%2FESLWiOJO73ZFg-HQg8HnLUIBIRh8Z3JkVUzR6oPJSMqeGQ%3Fnav%3DeyJyZWZlcnJhbEluZm8iOnsicmVmZXJyYWxBcHAiOiJTdHJlYW1XZWJBcHAiLCJyZWZlcnJhbFZpZXciOiJTaGFyZURpYWxvZy1FbWFpbCIsInJlZmVycmFsQXBwUGxhdGZvcm0iOiJXZWIiLCJyZWZlcnJhbE1vZGUiOiJ2aWV3In19%26e%3D4%253A0p4Ou2%26fromShare%3Dtrue&data=05%7C02%7C%7C6312a35d88ab49875b7a08dc1e8f8aa0%7Ce95f1b23abaf45ee821db7ab251ab3bf%7C0%7C0%7C638418849056925343%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C3000%7C%7C%7C&sdata=l1ZXlUVhK8kUnhqn5CMOciNLewnWTG4xvo4Zzd%2B7nIg%3D&reserved=0"
; OLD helpvid := "https://web.microsoftstream.com/video/a2807765-eb8d-4a31-a742-88b7407d2f1a"
run  %helpvid%
return  


dpsend:
Gui, 18: Destroy
 helpvid := "https://web.microsoftstream.com/video/859de9a7-d729-414c-88be-cf3a0390b47c"
run  %helpvid%
return 


dpreceive:
Gui, 18: Destroy
 helpvid := "https://web.microsoftstream.com/video/7f5ce5a8-8368-40c6-8e31-c893d4d5b04e"
run  %helpvid%
return 

return  ; end open video screen label

;############################################################################################
;#####################################END of Video menu###################################################
;############################################################################################







Link1:

Linktext1:= "
(
Adding 'Nurse' As Additional Signer: `n

To use the shortcuts below, sign your CPRS note and then hit one of
key combinations shown. CPRS Booster will activate the additional signer
functionality in CPRS and fill it in for you.

Names of individuals (RN, MSA, etc) need to exactly match the format in
CPRS additional signer: last,first (no spaces).
 
Ctrl-N for Nurse: will add the person you enter in the 'Nurse' box
as an additional signer.

Ctrl-B for Both: will add both the Nurse and MSA to your note.

Ctri-R for Remove: will remove all additional signers (ie if you 
make a mistake in adding someone)


Note **: Booster knows what to do:

When you are in the NOTES section this command will add this person
   as additional SIGNER

BUT when you highlight an ORDER and use this command: Booster will 
   FLAG the order to that person

Booster knows where you are in CPRS (usually) and does what it
   thinks you want

)"

Gui, 2: Font, s11, Verdana  ; Set 13-point Verdana.
Gui, 2:Add, Text,, %Linktext1%
Gui, 2:Show, x500 y100 w600 h550, Additional Signer: Nurse
return ; end of Link 1 label.

2GuiClose:
   Gui 2: Destroy ; Destroy the GUI to get it out of the way
return


;--------------help text for second link
Link2:

Linktext2:= "
(
Adding 'Nurse2' As Additional Signer: `n

Alt-N: for the ALT-ernative Nurse

Note **: Booster knows what to do:

When you are in the NOTES section this command will add this person
   as additional SIGNER

BUT when you highlight an ORDER and use this command: Booster will 
   FLAG the order to that person

Booster knows where you are in CPRS (usually) and does what it
   thinks you want
)"

Gui, 2: Font, s11, Verdana  ; Set 13-point Verdana.
Gui, 2:Add, Text,, %Linktext2%
Gui, 2:Show, x500 y100 w600 h400, Additional Signer: Nurse 2
return ;---------return end of Link 2

Link3:


Linktext3:= "
(
Adding 'MSA' As Additional Signer: `n

To use the shortcuts below, sign your CPRS note and then hit one of
key combinations shown. CPRS Booster will activate the additional signer
functionality in CPRS and fill it in for you.

Names of individuals (RN, MSA, etc) need to exactly match the format in
CPRS additional signer: last,first (no spaces).
 
Ctrl-M for MSA: will add the person you enter in the 'MSA' box
as an additional signer.

Ctrl-B for Both: will add both the Nurse and MSA to your note.

Ctri-R for Remove: will remove all additional signers (ie if you 
make a mistake in adding someone)

Note **: Booster knows what to do:

When you are in the NOTES section this command will add this person
   as additional SIGNER

BUT when you highlight an ORDER and use this command: Booster will 
   FLAG the order to that person

Booster knows where you are in CPRS (usually) and does what it
   thinks you want
)"

Gui, 2: Font, s11, Verdana  ; Set 13-point Verdana.
Gui, 2:Add, Text,, %Linktext3%
Gui, 2:Show, x500 y100 w600 h550, Additional Signer: MSA

return ; -------------return end of link 3 = MSA

Link4:


Linktext3:= "
(
Sign Stuff: `n

Would you like to never type your signature code again? 

Ctrl-S will do it for you. 
The F1 (function 1) key does the same: but just one button.

CPRS Booster knows what you are trying to sign. If you are
writing an ADDENDUM, Ctrl-S will both call up the signature 
box (don't need to mouse click to 'sign note') AND will
type in your signature code and press enter.

If you are writing a note that requires an encounter, you will
have to press Ctrl-S twice (different times). The first time
you press Ctrl-S, the encounter will come up. Fill that out and
when you get to the box asking for your sig code: press
Ctrl-S again. Done.

Prescriptions/Orders: When the little signature box 
comes up: Ctrl-S

Security: This code is stored only on your computer under
your profile. Can't be seen by others.

WANT TO PRACTICE USING CPRS BOOSTER?
Go to CPRS and search for patients with last name zzTestpatient.
Any of these are mock patient charts: you can create notes and 
add signers using CPRS booster. Don't forget to REMOVE any
signers when you are done: otherwise they will get view alerts!
)"

Gui, 2: Font, s11, Verdana  ; Set 13-point Verdana.
Gui, 2:Add, Text,, %Linktext3%
Gui, 2:Show, x500 y50 w600 h600, Sign Stuff

return ;---------------end of link 4= sign



Link5:
MsgBox, 262144, CPRS Booster, Types your clinic name
return
Link6:
MsgBox, 262144, CPRS Booster, Types your phone clinic name
return
 
;-------------------------Link text 7 start
Link7:


Linktext7:= "
(
Adding 'Pharmacist' As Additional Signer: `n

Ctrl-F for Farmacist (P is used for providers)

Note **: Booster knows what to do:

When you are in the NOTES section this command will add this person
   as additional SIGNER

BUT when you highlight an ORDER and use this command: Booster will 
   FLAG the order to that person

Booster knows where you are in CPRS (usually) and does what it
   thinks you want


WANT TO PRACTICE USING CPRS BOOSTER?
Go to CPRS and search for patients with last name zzTestpatient.
Any of these are mock patient charts: you can create notes and 
add signers using CPRS booster. Don't forget to REMOVE any
signers when you are done: otherwise they will get view alerts!
)"

Gui, 2: Font, s11, Verdana  ; Set 13-point Verdana.
Gui, 2:Add, Text,, %Linktext7%
Gui, 2:Show, x500 y100 w600 h500, Additional Signer: Pharmacist

return ; ------------


;-------------------Link text 7 end



Link8:


Linktext8:= "
(

Yeah: it launches CPRS

)"

Gui, 2: Font, s11, Verdana  ; Set 13-point Verdana.
Gui, 2:Add, Text,, %Linktext8%
Gui, 2:Show, x500 y100 w600 h500, Launch CPRS

return ; ------------


;-------------------Link text 8 end


Link9:


Linktext9:= "
(

Unflags anything flagged..all of them at once

)"

Gui, 2: Font, s11, Verdana  ; Set 13-point Verdana.
Gui, 2:Add, Text,, %Linktext9%
Gui, 2:Show, x500 y100 w600 h500, Unflags Stuff

return ; ------------

;-------------------Link text 9 end



Link10:

Linktext10:= "
(
Adding 'Provider 1' As Additional Signer: `n

Ctrl-P (P for Provider)

Note **: Booster knows what to do:

When you are in the NOTES section this command will add this person
   as additional SIGNER

BUT when you highlight an ORDER and use this command: Booster will 
   FLAG the order to that person

Booster knows where you are in CPRS (usually) and does what it
   thinks you want

)"

Gui, 2: Font, s11, Verdana  ; Set 13-point Verdana.
Gui, 2:Add, Text,, %Linktext10%
Gui, 2:Show, x500 y100 w600 h400, Additional Signer: Provider 1
return ;---------return end of Link 10




Link11:

Linktext11:= "
(

Adding 'Provider 2' As Additional Signer: `n

Alt-P (the ALT-ernate Provider)

Note **: Booster knows what to do:

When you are in the NOTES section this command will add this person
   as additional SIGNER

BUT when you highlight an ORDER and use this command: Booster will 
   FLAG the order to that person

Booster knows where you are in CPRS (usually) and does what it
   thinks you want
)"

Gui, 2: Font, s11, Verdana  ; Set 13-point Verdana.
Gui, 2:Add, Text,, %Linktext11%
Gui, 2:Show, x500 y100 w600 h400, Additional Signer: Provider 2
return ;---------return end of Link 10


Link12:

Linktext12:= "
(

Ctrl-A: for A-ddendum. Makes addendum to note.
)"

Gui, 2: Font, s11, Verdana  ; Set 13-point Verdana.
Gui, 2:Add, Text,, %Linktext12%
Gui, 2:Show, x500 y100 w600 h400, Make Addendum
return ;---------return end of Link 12

Link20:

Linktext20:= "
(

Ctrl-I: for I-gnore. When you are flagged to an order that
    is ALSO flagged to someone else. Removes flag to you but 
    leaves order flagged for other person (same as:file-->remove notification)
)"

Gui, 2: Font, s11, Verdana  ; Set 13-point Verdana.
Gui, 2:Add, Text,, %Linktext20%
Gui, 2:Show, x500 y100 w600 h400, Ignore Flagged Order
return ;---------return end of Link 20


Gui2Close:
   Gui, 2: Destroy ; Destroy the GUI to get it out of the way
return

AllHelp: ;---------------start Allhelp


LinktextAll:= "
(
Would you like to never type your signature code again?
Never type your nurse/provider/MSA's name again?

When Booster is running, you will use keyboard shortcuts
to do all of this (and more) for you.

Sign:  (F1 or Ctrl-S: both do the same thing)

   Ctrl-S: Signs anything using your signature code. When
             writing a note/addendum: it will automatically
             bring up the sig box and then fill it out.
 
             Orders/others: will plug in sig code and hit enter
	
Add Additional Signers:
   From the signed note it (a) activates the additional signer
   function in CPRS and (b) fills in relevant name(s)

   Ctrl-N: Nurse
   Ctrl-M: MSA
   Ctrl-B: Adds BOTH your MSA and Nures to a note (same time)
   Ctrl-R: REMOVES all additional signers (error correction)
   Ctrl-P: Pharmacist

Open CPRS:

   Alt-C: C for CPRS. Only command using Alt. (Ctrl-C copies 
          to clipboard: so that was taken)

WANT TO PRACTICE USING CPRS BOOSTER?
Go to CPRS and search for patients with last name zzTestpatient.
Any of these are mock patient charts: you can create notes and 
add signers using CPRS booster. Don't forget to REMOVE any
signers when you are done: otherwise they will get view alerts!
)"

Gui, 2: Font, s11, Verdana  ; Set 13-point Verdana.
Gui, 2:Add, Text,, %LinktextAll%
Gui, 2:Show, x500 y0 w600 h675, CPRS Booster: How to Use

Return ; ----------End all help

Troubleshooting: ;---------------start troubleshooting

TSUrl := "https://tinyurl.com/CPRSBstr"    ; NOTE: THIS IS POINTING TO A TEAMS DOCUMENT ON a CPRS Booster team (library)

	SplashTextOn ,300 ,100, CPRS Booster, Working...
	sleep 500
	SplashTextOff

run, %TSUrl%


	SplashTextOn ,300 ,100, CPRS Booster, Opening FAQ Page...
	sleep 2000
	SplashTextOff

Gui, Destroy ; Destroy the ctrl h GUI to get it out of the way

Return ; ----------End Troubleshooting




LinkVersion:
gui48:    ; this is the new version info screen

/*
	; Read file and get row of locNames who are beta SITES
	FileRead, locNamesRow, %ListSITESBetaTesting%

	; Split row into individual locNames
	locNames := StrSplit(locNamesRow, "|")

	; Check if sitecode is in locNames
	isBETASITE:= false
	for each, locName in locNames
			{
				if (locName = sitecode)
				{
					isBETASITE := true
					break
				}
			}

	; Add special version text to beta sites

	if (isBETASITE)  ; BETA MUST CHANGE: REMOVE all SITES from sites folder in Auto to disable this
	{

*/

;**************************************NEW VERSION GUI AND TEXT*******************************

howtoGetInfoLater := "
(

Anytime: go to Ctrl-H --> Videos to
learn about Add/flag/forward PCP and 
Automating Med Refills


)"
NewVersionPicture =%BoosterRoot%Pictures\NewVersionCURRENT.PNG  ; just change the graphic going forward
Gui, 48: Add, Picture, h459 w900, %NewVersionPicture%

; Add buttons
Gui, 48:Font, S12 CDefault, Verdana
; Gui, 48: Add, Button, x12 y850 w300 h30 gTellMeMore_Gui48, Tell me more
Gui, 48: Add, Button, x500 y465 w100 h30 gOKButton_Gui48, OK

Gui, 48:Show, x100 y100 w900 h500, CPRS BOOSTER New Version: Less Work!
return



TellMeMore_Gui48:
    Gui, 48: Destroy
	Gosub, gui18
    
return

OKButton_Gui48:
    Gui, 48: Destroy
   ;  MsgBox, 262144, CPRS Booster, %howtoGetInfoLater%
return

48GuiClose:
   gui, 48: Destroy ; Destroy the GUI to get it out of the way
  lastwin:= "notCPRS" ; make the floating help bar pop back up with next left click

return

;**************************************END: NEW VERSION GUI AND TEXT*******************************




;-------------------****************HOT KEYS NOT IN CPRS MUST GO BETWEEN THIS LINE AND OTHER LINE with ASTERICKS below****

; Hotkey, !t, downlabel, on


;############################################################################################
;########################start testing area###########################################
;############################################################################################


  /* ; BETA must activate
	
	;----


 +!^t::


 gosub gui64
;gosub gui64 ; ambient dictation
return

/* ;



::..cxr::


send Chest x-ray ordered
    Loop, % AllData.MaxIndex() ; Loop through all elements in the AllData array
    {
        if (InStr(AllData[A_Index].displayname, "cxr") > 0)
        {
            ; MsgBox, 262144, CPRS Booster, Found ABI index: %A_Index%
			qoindex := A_Index
        }
    }
	
	
	RecordAfterEdit := false ; start with qoEditmode off
	Gosub ButtonAction ; Perform the button action for regular left-click
	rtclicktracker := 0   ; DEactivate this hotkey beginning of this program

return
  

::..fur20::


send Furosemide 20mg po q day ordered
    Loop, % AllData.MaxIndex() ; Loop through all elements in the AllData array
    {
        if (InStr(AllData[A_Index].displayname, "furosemi") > 0)
        {
            ; MsgBox, 262144, CPRS Booster, Found ABI index: %A_Index%
			qoindex := A_Index
        }
    }
	
	
	RecordAfterEdit := false ; start with qoEditmode off
	Gosub ButtonAction ; Perform the button action for regular left-click
	rtclicktracker := 0   ; DEactivate this hotkey beginning of this program

return
  



 /* ---- DO NOT DELETE text below: it is for the flag back button


    ; Select all text
    Send, ^a
    Sleep, 100
    ; Save the current clipboard content
    savedClipboard := ClipboardAll
    ; Copy the selected text to the clipboard
    Send, ^c
    ; Wait for the clipboard to contain the copied text
    ClipWait, 3
    if (ErrorLevel) {
        MsgBox, 262144, CPRS Booster, Something went wrong.
        ; Restore the previous clipboard content
        Clipboard := savedClipboard
        return
    }

    ; Get the clipboard text
    clipboardText := Clipboard
    ; Define an array of credentials to be stripped out IF boundary word is next to them
    credentials := ["MD", "RN", "MSA", "BSN", "PA-C", "PA"]
    

clipboardText:= StrReplace(clipboardText, "M.D.","" )   ; regardless of boundary word

    ; Strip out credentials from the clipboard text
    Loop, % credentials.MaxIndex()
    {
        credential := credentials[A_Index]
        ; Use a regular expression to remove standalone credentials
        clipboardText := RegExReplace(clipboardText, "\b" . credential . "\b", "")
    }

    ; Initialize an empty result string and an array to store names
    result := ""
    names := []
    
    ; Use a regular expression to find all instances of text between /es/ and the next comma or carriage return
    pos := 1
    while (pos := RegExMatch(clipboardText, "/es/ (.*?)(,|`r|`n|$)", match, pos)) {
        ; Extract the full name
        fullName := RTrim(match1)
        ; Split the name into parts
        StringSplit, nameParts, fullName, %A_Space%
        ; Assume the last part is the last name and the rest are the first names
        lastName := nameParts%nameParts0%
        firstName := ""
        Loop, % nameParts0 - 1
            firstName .= nameParts%A_Index% " "
        ; Trim the trailing space from the first name
        StringTrimRight, firstName, firstName, 1
        ; Append the formatted name to the result
        formattedName := lastName ", " firstName
        names.Push(formattedName)
        ; Move to the next match
        pos += StrLen(match)
    }

    ; Display each name in a message box
    for index, name in names {
        MsgBox, 262144, CPRS Booster, Name: %name%
    }

    ; Restore the previous clipboard content if needed
    Clipboard := savedClipboard
return

  /*


    ; Select all text
    Send, ^a
    Sleep, 100
    ; Save the current clipboard content
    savedClipboard := ClipboardAll
    ; Copy the selected text to the clipboard
    Send, ^c
    ; Wait for the clipboard to contain the copied text
    ClipWait, 3
    if (ErrorLevel) {
        MsgBox, 262144, CPRS Booster, Something went wrong.
        ; Restore the previous clipboard content
        Clipboard := savedClipboard
        return
    }

    ; Get the clipboard text
    clipboardText := Clipboard
    ; Define an array of credentials to be stripped out
    credentials := ["MD", "RN", "MSA", "BSN", "LPN"]
    
    ; Strip out credentials from the clipboard text
    Loop, % credentials.MaxIndex()
    {
        credential := credentials[A_Index]
        ; Use a regular expression to remove standalone credentials
        clipboardText := RegExReplace(clipboardText, "\b" . credential . "\b", "")
    }

    ; Initialize an empty result string
    result := ""
    
    ; Use a regular expression to find all instances of text between /es/ and the next comma or carriage return
    RegExMatch(clipboardText, "/es/ (.*?)(,|`r|`n|$)", match)
	MsgBox, 262144, CPRS Booster, %match%
    while (match) {
        ; Extract the full name
        fullName := match1
		fullname := RTrim(fullname)
        ; Split the name into parts
        StringSplit, nameParts, fullName, %A_Space%
        ; Assume the last part is the last name and the rest are the first names
        lastName := nameParts%nameParts0%
		MsgBox, 262144, CPRS Booster, %lastname%
        firstName := ""
        Loop, % nameParts0 - 1
            firstName .= nameParts%A_Index% " "
        ; Trim the trailing space from the first name
        StringTrimRight, firstName, firstName, 1
        ; Append the formatted name to the result
        result .= lastName ", " firstName "`n"
        ; Find the next match
        clipboardText := SubStr(clipboardText, matchPos + StrLen(match))
        RegExMatch(clipboardText, "/es/ (.*?)(,|`r|`n|$)", match)
    }

    ; Display the result or copy it back to the clipboard
    Clipboard := result
    MsgBox, 262144, CPRS Booster, Name: %result%
    ; Restore the previous clipboard content if needed
     Clipboard := savedClipboard
return
*/


	

 */   ; BETA must activate

;############################################################################################
;#########################End of testing area############################################
;############################################################################################

  
  
  
  ;############################################################################################
;######################START DRAGON########################################
;############################################################################################

  

dragon: ; section for gosub that starts dragon

		if (AutoDragon <> 1)
		{
		return ; don't start dragon if user configured out of it in settings.
		}
dragonherebutoff := 0
; westartedDragon := 0
;Ifexist C:\Program Files (x86)\Nuance\Dragon Medical One 2023\SoD.exe
Ifexist %dragonpath%
{  ; if the dragon program is installed AND 

		if !winexist("ahk_exe SoD.exe")  ; dragon isn't running.
		{
		dragonherebutoff := 1 ; this sets a variable to give dragon status
		
		if (startdragon = 1) ; at the gosub don't just check it but start it as well
			{
					try
					{
					;run, C:\Program Files (x86)\Nuance\Dragon Medical One 2023\SoD.exe
					run, %dragonpath%
						 ; westartedDragon := 1
						SplashTextOn ,300 ,100, CPRS Booster, I'm starting Dragon
						 sleep 1400
						SplashTextOff
						sleep 3000
						Startdragon := 0 ; Reset
						
								
					}
			}

		}
		dragonNotInstalled := 0 ; reset this variable; Dragon is installed

}
Else
{
	; THEY Don't need this ....MsgBox,262144, CPRS Booster, Dragon is not installed on this computer. `n Help desk ticket needed to install
	dragonNotInstalled := 1
}
return



;----------------open CPRS

!c::

gosub dragon ; is dragon installed and off?

if (dragonherebutoff = 1 )&&(AutoDragon = 1) ; we have to refresh data before CPRS start IF we want Autodragon variable
{
spltext := "I'm starting CPRS and Dragon..."
}
else
{
spltext := "I'm starting CPRS..."
}


	SplashTextOn ,300 ,100, CPRS Booster, %spltext%
	sleep 400
	SplashTextOff




	; run \\vNN.med.va.gov\apps\Goldstar\XXX\CPRSChart MIN.lnk

	UserPrefix := SubStr(A_UserName, 1, 3)
	If UserPrefix contains vha,VHA
	{
		SiteCode := SubStr(A_UserName, 4, 3)
		
		try
		{
		Gosub %SiteCode%
		}
			
		
		Loop, 4
		{
	
			/*
			Ifexist \\%Visn%.med.va.gov\apps\Goldstar\%SiteCode%\CPRSChart %SiteCode%.lnk
			{
				Run, \\%Visn%.med.va.gov\apps\Goldstar\%SiteCode%\CPRSChart %SiteCode%.lnk ,,UseErrorLevel,
				WinMaximize , Vista C
			}
		
			else
			*/
			
			Ifexist \\%Visn%.med.va.gov\apps\VA_Shortcuts\%SiteCode%\CPRSChart %SiteCode%.lnk
			{
				Run, \\%Visn%.med.va.gov\apps\VA_Shortcuts\%SiteCode%\CPRSChart %SiteCode%.lnk ,,UseErrorLevel,
				WinMaximize , Vista C
			}
			
			; \\v01.med.va.gov\apps\VA_Shortcuts\NHM\CPRSChart NHM.lnk  what actual link is I guess
			
			else ; none of the known CPRS locations are found.

			{
			       SplashTextOn ,300 ,100, CPRS Booster, Sorry! Booster can't start CPRS at your site...`n Or you are not on the network..
		  		 sleep 3000
		  	 	SplashTextOff
				break ; break the loop here ?
			}

			; ****DOne trying to start CPRS: now let's see what happened



if (dragonherebutoff = 1 ) ; now that we started CPRS (kinda), get dragon started IF not already running.
{
		   startdragon := 1 ; this tells the gosub dragon to actually start dragon
		   gosub dragon ; let's get dragon started first. then start CPRS. ; 
		   gosub FindDragonWindow1 ;  ; same as above comments ; we do't want to do this if running already.
}



		
		if ErrorLevel
			 {
	
			   if A_Index = 4
				
				{ ; failed after 4 trys

		  	 	SplashTextOn ,300 ,100, CPRS Booster, Sorry! Booster can't start CPRS ...
		  		 sleep 3000
		  	 	SplashTextOff
				break ; break the loop here ?

				}
			  }
		  	


		Process, Wait, CPRSChart.exe, 20
   		if !ErrorLevel
			{
			 ; MsgBox, 262144, CPRS Booster, Cprs is NOT running!
	
			}
    		  else
			{
			; MsgBox, 262144, CPRS Booster, Cprs is running!
			
			
			Winwait Windows Security,,20
			winactivate, Windows Security
			
			If WinActive("Windows Security")
				{
				send {tab}
				sleep 50
				send {enter}
				}
				
			break
			}

		
		
		} ; end of user prefix has VHA

	} ; Loop return point


	; run \\v23.med.va.gov\apps\Goldstar\%SiteCode%\CPRSChart %SiteCode%.lnk

	; ************** create log entry 
	Rulenum = 1
	RuleString:= ""
	Gosub logit
	; **************end of log entry
 	
return



;############################################################################################
;###############  START OF FUNCTION KEY SCREEN GUI  (fxn /Jump)       ########################
;############################################################################################


!h::

;-----------display setup/instructions screen

Gui 14: Destroy
gui 7: destroy ;Destroy
gui 8: destroy

If WinExist("Booster Functions") ;---- if they are already on function screen
{

winactivate, Booster Functions
;MsgBox,0,CPRS Booster: Been there Done that, The help/setup screen is already open somewhere. How much help do you need? :) 
return
}

instru := "
(
Assign Function Keys. CLick Ok when done.

**Note: Get directly to this screen (the ALT-ernate help screen): ALT-H

)"



Gui, 5: Font, s11, Verdana  ; Set Verdana.
Gui, 5: Add, Text, X5 Y5 w600 R4, %instru%
Gui, 5: Font

droplist := "
(
Sign|Add RN1|Add RN2|Add MSA|Add BOTH|Add PHARM|Add Misc|Unflag|Flag|Next Patient|Make Addendum|Edit Note|Find @@@|Quick|Spell Check|Add PROV1|Add PROV2|Phone Clinic|F2F Clinic|VVC Clinic|Add Person1|Add Person2|Add Person3|Add Person4|Add Person5|Add Person6|Add/Flag PCP|
)"


;;   Sign|Add RN1|Add RN2|Add MSA|Add BOTH|Add PHARM|Add Misc|Unflag|Flag|Next Patient|Make Addendum|Edit Note|Add PROV1|Add PROV2|Phone Clinic|F2F Clinic|VVC Clinic|Add Person1|Add Person2|Add Person3|Add Person4|Add Person5|Add Person6|New Note 1|New Note 2|New Note 3|New Note 4|New Note 5|New Note 6|



Gui, 5: Font, s12, Verdana  ; Set 13-point Verdana.
Gui, 5: Add, Text, x12 y80 w50 h30, F1 ; This just displays the text 
Gui, 5: Add, Text, x12 y+17 w100 h30, F2 ; This just displays the text 
Gui, 5: Add, Text, x12 y+17 w100 h30, F3 ; This just displays the text
Gui, 5: Add, Text, x12 y+16 w120 h30, F4 ; This just displays the text
Gui, 5: Add, Text, x12 y+16 w140 h30, F5 ; This just displays the text
Gui, 5: Add, Text, x12 y+16 w120 h30, F6 ; This just displays the text 
Gui, 5: Add, Text, x12 y+16 w120 h30, F7 ; This just displays the text
Gui, 5: Add, Text, x12 y+16 w120 h30, F8 ; This just displays the text 
Gui, 5: Add, Text, x12 y+16 w120 h30, F9 ; This just displays the text
Gui, 5: Add, Text, x12 y+16 w120 h30, F10 ; This just displays the text
Gui, 5: Add, Text, x12 y+16 w120 h30, F11 ; This just displays the text 
Gui, 5: Add, Text, x12 y+16 w120 h30, F12 ; This just displays the text

;---- We need to search and reaplace in droplist to set default item:


;----------------display entry boxes (edit boxes)

Gui, 5: Font
Gui, 5: Font, s13, Verdana 



ReplacedStr := StrReplace(droplist, fxn.1 , fxn.1 . "|") ;----THis modifies the dropdown options to select a default.
Gui, 5: Add, dropdownlist, x165 y80 w225 vF1,%ReplacedStr% ;this is is the actual input box, so we must attach a variable to it. IE: vF1 

ReplacedStr := StrReplace(droplist, fxn.2 , fxn.2 . "|")
Gui, 5: Add, dropdownlist, x165 y+19 w225 vF2,%ReplacedStr% ; This is the actual input box, so we must attach a variable to it. 

ReplacedStr := StrReplace(droplist, fxn.3 , fxn.3 . "|")
Gui, 5: Add, dropdownlist, x165 y+19 w225 vF3,%ReplacedStr% ; This is the actual input box, so we must attach a variable to it. 

ReplacedStr := StrReplace(droplist, fxn.4 , fxn.4 . "|")
Gui, 5: Add, dropdownlist, x165 y+19 w225 vF4,%ReplacedStr% ; This is the actual input box, so we must attach a variable to it.
 
ReplacedStr := StrReplace(droplist, fxn.5 , fxn.5 . "|")
Gui, 5: Add, dropdownlist, x165 y+19 w225 vF5,%ReplacedStr% ; This is the actual input box, so we must attach a variable to it. 

ReplacedStr := StrReplace(droplist, fxn.6 , fxn.6 . "|")
Gui, 5: Add, dropdownlist, x165 y+19 w225 vF6,%ReplacedStr% ; This is the actual input box, so we must attach a variable to it.
 
ReplacedStr := StrReplace(droplist, fxn.7 , fxn.7 . "|")
Gui, 5: Add, dropdownlist, x165 y+19 w225 vF7,%ReplacedStr% ; This is the actual input box, so we must attach a variable to it. 

ReplacedStr := StrReplace(droplist, fxn.8 , fxn.8 . "|")
Gui, 5: Add, dropdownlist, x165 y+19 w225 vF8,%ReplacedStr% ; This is the actual input box, so we must attach a variable to it. 

ReplacedStr := StrReplace(droplist, fxn.9 , fxn.9 . "|")
Gui, 5: Add, dropdownlist, x165 y+19 w225 vF9,%ReplacedStr% ; This is the actual input box, so we must attach a variable to it.


ReplacedStr := StrReplace(droplist, fxn.10 , fxn.10 . "|")
Gui, 5: Add, dropdownlist, x165 y+19 w225 vF10,%ReplacedStr% ; This is the actual input box, so we must attach a variable to it. 

ReplacedStr := StrReplace(droplist, fxn.11, fxn.11 . "|")
Gui, 5: Add, dropdownlist, x165 y+19 w225 vF11,%ReplacedStr% ; This is the actual input box, so we must attach a variable to it. 

ReplacedStr := StrReplace(droplist, fxn.12 , fxn.12 . "|")
Gui, 5: Add, dropdownlist, x165 y+19 w225 vF12,%ReplacedStr% ; This is the actual input box, so we must attach a variable to it.

Gui, 5: Add, Button, x2 y620  w40 h30 , OK ; Button to submit the information


;-------------------------end of help links



Gui, 5: Show, x345 y0 w700 h690, Booster Functions ; Display the GUI, x and y tell where to show the window at on the screen and h and w tell what size to make it

Return

5GuiClose:
   Gui, 5: Destroy ; Destroy the GUI to get it out of the way
  lastwin:= "notCPRS" ; make the floating help bar pop back up with next left click
return

;----------------Start of OK button processing on Help and Setup screen

5ButtonOK: ; Execute the following actions when the button from the GUI OK is pressed
Gui, 5: Submit ; Save all the information in the GUI (The variables)
Gui, 5: Destroy ; Destroy the GUI to get it out of the way

;              -------------------


  ; Each array must be initialized before use:
  ;global fxn := []
  fxn[j] := A_LoopField
  fxn[j, k] := A_LoopReadLine
  fxnCount := 0

   fxn[1] := F1
   fxn[2] := F2
   fxn[3] := F3
   fxn[4] := F4
   fxn[5] := F5
   fxn[6] := F6
   fxn[7] := F7
   fxn[8] := F8
   fxn[9] := F9
   fxn[10] := F10
   fxn[11] := F11
   fxn[12] := F12


gosub, writeit ;-----write these values to the file.
;------------------------------****************************END OF FUNCTION KEY GUI

return ;----------???---------------**************END of ctrl-Q = test of function gui


; #IfWinActive, ahk_exe CPRS ; this limits to CPRS
; #IfWinActive, VistA CPRS ; this limits to CPRS

; #If WinActive("ahk_exe CPRSChart.exe") || WinActive("ahk_exe CPRSMA312.exe") || Winactive("VistA CPRS")

;  #If WinActive("ahk_exe CPRSChart.exe") 


; beta 11-24-24 use line below #If (WinActive("ahk_exe CPRS") || WinActive("ahk_class AutoHotkeyGUI")) && !Winexist("Consult Toolbox") ; the second part means fxn and other keys will activate even if Floating bar active

#If (!IncludeToolboxLogic || !WinExist("Consult Toolbox")) && (WinActive("ahk_exe CPRS") || WinActive("ahk_class AutoHotkeyGUI")) 
;-------***********************-------HOT KEYS BELOW WILL ONLY WORK IN CPRS given LINE ABOVE



;############################################################################################
;#####################Deal with Alarm problem f9/11###################################################################
;############################################################################################

F9 & F11::

; msgbox both with f9 first 
gosub sendalarm
return


F11 & F9::

	; msgbox both with f11 first 
	gosub sendalarm
return

sendalarm:

	run, calc	
		; winclose, ahk_exe OUTLOOK.EXE ; weird way to turn off this hotstring from sending itself via hashtag above; CPRS in live version
	sleep 3000
	winactivate calculator
	sleep 700	
	
	loop, 6
	{
	send {f9){f11}
	sleep 2000
	}

return



;############################################################################################
;#######################End of alarm problem##################################################################
;############################################################################################





;############################################################################################
;######################SHIFT F1: AUTOLINK TO PDF FROM CITC###########################################
;################################NOT THE USUAL F1############################################################
 ; Defines Shift+F1 as the hotkey
+F1::
;;****************NOTE THIS IS NOW INSIDE OF BOOSTER LOGIC

    ; Activate the window title starting with 'Vista Cprs in use by'
    SetTitleMatchMode, 2
  
        Winactivate, VistA CPRS in use by
        MouseClick,, ,, 2
        sleep 100
        ; Send Ctrl+A to select all text and Ctrl+C to copy to clipboard
        Send, ^a
        Sleep, 200 ; Wait a bit for the selection
        Send, ^c
        Sleep, 100 ; Wait a bit for the copying
        SplashTextOn ,150 ,100, CPRS Booster, GETTING PDF! `n (30 Seconds)
        sleep 1000
        SplashTextOff
        ; Retrieve the clipboard content
        ;ClipboardOld := ClipboardAll
        ;Clipboard := "" ; Clear clipboard to ensure it's filled by the copied content
        ClipWait, 2 ; Wait for the clipboard to contain data, max 2 seconds
        send, {up} ;unselect  
        
        if Clipboard
        {
            content := Clipboard
			startDelim := "===PDF Key==="
            endDelim := "===END==="

            
            ; Find the starting position of the key
            startPos := InStr(content, startDelim) + StrLen(startDelim)
            ; Find the ending position of the key
            endPos := InStr(content, endDelim)

            ; Extract the key and tidy it up
            if (startPos > 0 && endPos > 0 && startPos < endPos)
            {
                pdfKey := SubStr(content, startPos, endPos - startPos)
                pdfKey := RegExReplace(pdfKey, "\s+", "") ; Remove all spaces, leading/trailing and in the middle
                ; Copy the cleaned key back to the clipboard
                Clipboard := pdfKey
                
                ; Check and create necessary subfolders in OneDrive
                EnvGet, onedrive, ONEDRIVE
                onedrivelocalCITC := onedrive . "\CPRSBooster\CITC"
                
                if not FileExist(onedrivelocalCITC)
                {
                    FileCreateDir, %onedrivelocalCITC%
                }
                ;sourceFile := "C:\Users\VHAMINBockA\OneDrive - Department of Veterans Affairs\Python\CITC PDF Encryption\ENDUSERuse_Decryption.py"
                ;targetFile := onedrivelocalCITC . "\ENDUSERuse_Decryption.py"
                sourceFile := "W:\Products\XRG\CITCFaxes\FindPDF.exe"
                targetFile := onedrivelocalCITC . "\FindPDF.exe"
                
                ; Check if the file already exists in the destination
				/*


                if not FileExist(targetFile)
                {
                    FileCopy, %sourceFile%, %targetFile%, 1
                }
                */
                ;msgbox %clipboard%

                
                ; Run the executable from OneDrive
               ; Run, %targetFile%

			   IfNotExist, w:\  ; need to try to start W drive first.
			{
				try
				{
				run, W:\ 
				winwait,(W:),,5
				sleep 1000
				 winclose, (W:)
				}

			}

				Run, %sourceFile%

            }
            else
            {
                MsgBox, Error: Key could not be found in the clipboard content.
            }
        }
        else
        {
            MsgBox, Error: No content in clipboard.
        }

        ; Restore the old clipboard content
       ; Clipboard := ClipboardOld

;msgbox %clipboard%

return



;############################################################################################
;############################################################################################
;############################################################################################


;-------------------------------------********************************START FUNCTION KEY DEFINITION
; --- CPRS window activation is in the function
F1::

		if (recordingIsOn = 1)  ; change f1 when record = stop button.
		{
		gosub stoprec
		recordingIsOn := 0
		return
		}

		if (MedQODownCount = 1)  ; change f1 when user is configuring MedQuickOrders
			{
			MedQODownCount := 0
			goto stopCounting
			return
			}

jumpfxn(1)
return



F2::

jumpfxn(2)
return

F3::

jumpfxn(3)
return

F4::
jumpfxn(4)
return

F5::

if (qodebug)  ; user wants to debug a quick order
	{

		; this is the cancel option for the debugger: this goes no where
		return
	}

jumpfxn(5)
return

F6::
jumpfxn(6)
return

F7::
jumpfxn(7)
return

F8::
jumpfxn(8)
return


F9::  

		if (recordingIsOn = 1)  
		{
		
		goto pauserec
		return
		}
jumpfxn(9)
return

F10::  
jumpfxn(10)
return

F11::

		if (qodebug)  ; user wants to debug a quick order
			{
				/*


				;MsgBox, 262144, CPRS Booster, index %Index%
				gui, 31: Destroy ; this is the yellow debugger ticker
				qodebug := false ; reset
				sleep 50
				goto qoedit
				; gosub qoedit ; I think we may currently still be in the playback loop (button action). Is that ok?
							; goto instead of gosub gets blank data
				; gosub GUi53
				*/
				return
			}

jumpfxn(11)
return

F12::
		if (qodebug)  ; during qo debug we use this
		{
			return
		}
jumpfxn(12)
return

-------------------------------------********************************END OF FUNCTION KEY DEFINITION



;----------------Add RN
$^n::     ; $ prevents it from sending itself: will send actual windows command prn tries to send itself.

; THIS LOGIC deals with key release option or not: 0 = no release

 if ctrln <> 1
{
Gosub ^+n ; This means  add Rn1
}
else
{
send ^n ; this means send ctrl n directly
}
return

^+n:: 
;MsgBox, 262144, CPRS Booster, rn1 in side the command

thisone := Nurse1 ; ---sets global variable prior to gosub; removed issue with passing comma
defaultToMed = no ;----will fill in flags assuming is a med refill flag
Gosub AddorFlag

	; ************** create log entry 
	Rulenum = 2
	RuleString:= thisone
	Gosub logit
	; **************end of log entry

return

;------------Add RN 2


$!n::     ; $ prevents it from sending itself: will send actual windows command prn tries to send itself.

; THIS LOGIC deals with key release option or not: 0 = no release

 if altn <> 1
{
Gosub ^!n ; This means send the alt nurse
}
else
{
send !n ; this means send alt-n directly.
}
return



^!n:: ; no one will ever press this combo; it is accessed by conditional gosub

sleep 40
KeyWait Alt
 thisone := Nurse2 ; ---sets global variable prior to gosub; removed issue with passing comma
defaultToMed = no ;----will fill in flags assuming is a med refill flag
Gosub AddorFlag

	; ************** create log entry 
	Rulenum = 3
	RuleString:= thisone
	Gosub logit
	; **************end of log entry

return

+^v:: ; no one will type this but mapped fxn key goes here. (well maybe they will; changed to shift-Ctrl-V)


send %VVC%
send {enter}

	; ************** create log entry 
	Rulenum = 27
	RuleString:= VVCClinic
	Gosub logit
	; **************end of log entry
Return


;---------------ADDITIONAL sign persons 1-6


^1:: ; no one will ever press this combo; it is accessed by conditional gosub


sleep 40
KeyWait Alt
 thisone := Person1 ; ---sets global variable prior to gosub; removed issue with passing comma
defaultToMed = no ;----will fill in flags assuming is a med refill flag
Gosub AddorFlag

	; ************** create log entry 
	Rulenum = 21
	RuleString:= thisone
	Gosub logit
	; **************end of log entry

return


^2:: ; no one will ever press this combo; it is accessed by conditional gosub

sleep 40
KeyWait Alt
 thisone := Person2 ; ---sets global variable prior to gosub; removed issue with passing comma
defaultToMed = no ;----will fill in flags assuming is a med refill flag
Gosub AddorFlag

	; ************** create log entry 
	Rulenum = 22
	RuleString:= thisone
	Gosub logit
	; **************end of log entry

return
^3:: ; no one will ever press this combo; it is accessed by conditional gosub

sleep 40
KeyWait Alt
 thisone := Person3 ; ---sets global variable prior to gosub; removed issue with passing comma
defaultToMed = no ;----will fill in flags assuming is a med refill flag
Gosub AddorFlag

	; ************** create log entry 
	Rulenum = 23
	RuleString:= thisone
	Gosub logit
	; **************end of log entry

return
^4:: ; no one will ever press this combo; it is accessed by conditional gosub

sleep 40
KeyWait Alt
 thisone := Person4 ; ---sets global variable prior to gosub; removed issue with passing comma
defaultToMed = no ;----will fill in flags assuming is a med refill flag
Gosub AddorFlag

	; ************** create log entry 
	Rulenum = 24
	RuleString:= thisone
	Gosub logit
	; **************end of log entry

return

^5:: ; no one will ever press this combo; it is accessed by conditional gosub

sleep 40
KeyWait Alt
 thisone := Person5 ; ---sets global variable prior to gosub; removed issue with passing comma
defaultToMed = no ;----will fill in flags assuming is a med refill flag
Gosub AddorFlag

	; ************** create log entry 
	Rulenum = 25
	RuleString:= thisone
	Gosub logit
	; **************end of log entry

return

^6:: ; no one will ever press this combo; it is accessed by conditional gosub

sleep 40
KeyWait Alt
 thisone := Person6 ; ---sets global variable prior to gosub; removed issue with passing comma
defaultToMed = no ;----will fill in flags assuming is a med refill flag
Gosub AddorFlag

	; ************** create log entry 
	Rulenum = 26
	RuleString:= thisone
	Gosub logit
	; **************end of log entry

return

; -------------------END ADD SIGN persons 1-6 

;------------Add MSA

$^m::     ; $ prevents it from sending itself: will send actual windows command prn tries to send itself.

; THIS LOGIC deals with key release option or not: 0 = no release

 if ctrlm <> 1
{
Gosub ^!m ; This means remove add msa
}
else
{
send ^m ; this means send ctrl m directly
}
return

^!m:: 

thisone := MSA1 ; ---sets global variable prior to gosub; removed issue with passing comma
defaultToMed = no ;----will fill in flags assuming is a med refill flag
Gosub AddorFlag
	; ************** create log entry 
	Rulenum = 4
	RuleString:= thisone
	Gosub logit
	; **************end of log entry
return


;------------Add Provider 1


$^p::     ; $ prevents it from sending itself: will send actual windows command prn tries to send itself.

; THIS LOGIC deals with key release option or not: 0 = no release

 if ctrlp <> 1
{
Gosub ^!p ; This means remove add p1
}
else
{
send ^p ; this means send ctrl  directly
}
return

^!p:: 

thisone := Prov1 ; ---sets global variable prior to gosub; removed issue with passing comma
defaultToMed = yes ;----will fill in flags assuming is a med refill flag
Gosub AddorFlag


	; ************** create log entry 
	Rulenum = 13
	RuleString:= thisone
	Gosub logit
	; **************end of log entry
return

;------------Add Provider 2

!p:: 

sleep 40
KeyWait Alt
thisone := Prov2 ; ---sets global variable prior to gosub; removed issue with passing comma
defaultToMed = yes ;----will fill in flags assuming is a med refill flag
Gosub AddorFlag

	; ************** create log entry 
	Rulenum = 14
	RuleString:= thisone
	Gosub logit
	; **************end of log entry
return


;Send  !a
;send I
;sleep 50
;send %Prov2%
;send {enter}
;sleep 50
;send !O
;return


;---------------------add both

^b:: 

gosub ActivateCPRS ; Floating bar drawing may take focus off

sleep 40
Send  !a
send I
sleep 80
send %Nurse1%
send {enter}
sleep 20
send %MSA1%
send {enter}
sleep 50
send !O


	; ************** create log entry 
	Rulenum = 15
	RuleString:= Nurse1 . MSA1
	Gosub logit
	; **************end of log entry
return

;--------------- face to face clinic

+^f::
send %f2fclinic%
send {enter}

	; ************** create log entry 
	Rulenum = 11
	RuleString:= f2fclinic
	Gosub logit
	; **************end of log entry
return

;--------------------------make addendum

$^a::     ; $ prevents it from sending itself: will send actual windows command prn tries to send itself.

; THIS LOGIC deals with key release option or not: 0 = no release

 if ctrla <> 1 
{
Gosub ^!a ; This means made addendum
}
else
{
send ^a ; this means send ctrl a directly
}
return


^!a:: ; NO one will ever use this key combo: it is accessed by gosub above.
gosub ActivateCPRS ; Floating bar drawing may take focus off
send !am


	; ************** create log entry 
	Rulenum = 16
	RuleString:= ""
	Gosub logit
	; **************end of log entry

return


;------------------------next pt

!+n::
If WinExist("Copy Medication Orders")|| WinExist("Copy Orders") ; can't change pts with this open

		{
		SplashTextOn ,150 ,100, CPRS Booster, The Copy Med Orders Window is Still Open
		sleep 3000
		SplashTextOff

		return ; terminate key action
		}





gosub ActivateCPRS ; Floating bar drawing may take focus off

gosub getpatientinfo ; need to figure out coming up if/when we're on new pt.
Oldpatient := reformattedSSN
send !fn

; -------NOW lets look for every screen that COULD come after a go to next (f12) command
; --- wait for 6 second after f12 UNLESS we get ones of these screens (Just for screen
; ------- to APPEAR
; --- problem is that you can have ordercheck AND immediately after that Sig box 
;  ----------AND THEN  current pross: so 2 screens after NEXT function
; --------ALSO PIV could come AFTER sig screens


InNextPtStep := 1 ; 
sleep 300

; we may need to see if coming from red order and IF so, change whatscreen am I so that all 
   ; order sig screens stop the loop and don't sign; This way we could use whatscreenamI
; gosub curprocess ; {WE"RE CALLING THIS iNSIDE OF WHATSCREEN AM I now}he prob with using whatscreenamI is that coming from red flag: it will just 
                 ; try to sign automatically rather than letting user do it. This is 
					; special case though. if we DON'T use whatscreen: it could time out. We have to use what screen and deal with issues there.
gosub whatscreenamI ; sort through screens until done. If pt selection screen is up next: whatscreenamI will see it and be done now.

Oldpatient := ""   ; we only need this inside of whatscreenamI to tell it we're coming from file new
	; ************** create log entry 
	Rulenum = 17
	RuleString:= ""
	Gosub logit
	; **************end of log entry
return

curprocess:
;############################################################################################
;##############################Start of Currently Processing notifications logic############
;############################################################################################

; FIRST thing we should do is make sure that screen before this is gone before waiting for cur proc



WinWait, Currently Processing Notifications, , 2 ; should not actually wait here b/c we got here from whatscreenamI identifying this screen

; We have a problem where the sign screen is sometimes open at same time.
;   Does this only happen during the ignore order step? Seems to.

		if (ignoreON = 1)
		{
		; first get rid of any open sign orders screen

		IfWinExist, Review / Sign Changes
				{
				winactivate, Review / Sign Changes
				 ignoreOn := 0
				 
				 send {enter}  ; click option to skip signing order
				 sleep 400
				 }

		}



		IfWinExist, Currently Processing Notifications
			{ ; ---------------

			winactivate, Currently Processing Notifications
			sleep 100
			send n  ; exit out of curr process screen. 
			sleep 300

			; ---- NOW we need to sent Alt-N to CPRS.
				if altn <> 1
				{
				altn := 1
				chgback := 1
				}

			gosub $!n ; if altn = 1, this will send actual Alt N to cprs

				if (chgback = 1)
				{
				altn :=0 ; reset alt-n release to its original status.
				}
			}

;############################################################################################
;#####################################end currently processing notification##############################################
;############################################################################################
Return


;--------------------------PHONE CLINIC

+^p::
send %phoneClinic%
send {enter}

	; ************** create log entry 
	Rulenum = 12
	RuleString:= phoneClinic
	Gosub logit
	; **************end of log entry

return

;-----------pharm
^f:: 



thisone := Pharm ; ---sets global variable prior to gosub; removed issue with passing comma
defaultToMed = no ;----will fill in flags assuming is a med refill flag
Gosub AddorFlag

	; ************** create log entry 
	Rulenum = 5
	RuleString:= thisone
	Gosub logit
	; **************end of log entry

return


;-----------------Remove all


$^r::     ; $ prevents it from sending itself: will send actual windows command prn tries to send itself.

; THIS LOGIC deals with key release option or not: 0 = no release

 if ctrlr <> 1 
{
Gosub ^!r ; This means remove add sign
}
else
{
send ^r ; this means send ctrl r directly
}
return

^!r:: ; no one uses directly
gosub ActivateCPRS ; Floating bar drawing may take focus off

send !ai
sleep 30
send !e
sleep 50
send !o



	; ************** create log entry 
	Rulenum = 18
	RuleString:= ""
	Gosub logit
	; **************end of log entry
return


^u::
unflag:
gosub ActivateCPRS ; Floating bar drawing may take focus off
gosub flaglocation ;--- hold the screen location of first flag (problem: this gets repeated below)
sleep 50
comingfromUnflag := 1 ; this is used to determine if we are coming from unflagging orders or not.
gosub flagclick ; select all flagged orders
comingfromUnflag := 0 ; reset this
oldclipboard := clipboard ; we are gonna use clip so save current value to oldclip prior to taking it.

clipboard := "noted" ; need this for V32a

sleep 150
send !au
WinWait, Unflag Order, , 3

UnflagLoopCounter := 0
hitenter:     ; loopback position

sleep 200
WinWait, Unflag Order, , 1
IfWinActive, Unflag Order
  {



	; WinGetText, OutputVar, Unflag Order ; get the text ont he unflag screen
	; Sleep, 200
	; IfInString, OutputVar, * Denotes the Required Fields ; this means CPRS v32a is present. comment required

	; {
	send {tab}
	sleep 100
	send ^v ; paste
	sleep 400
	send !u ; unflag (not ctrl U but alt U = CPRS command)
	sleep 600 ; 7-23: increase 400 to 600: we are finding Unflag screen again even when we've done the last one; Finding on hitenter loop

	; }
	;  Else ; old CPRS version w/o 4 digit requirement
	; {
	; send {enter}
	; sleep 400
	; }


 goto, hitenter ; loop until no more unflag order screens


  } ; end of ifwinactive unflag order


gosub flaglocation ; **** repeating this here: even if we don't see another 'unflag order' screen: check to see if we still see red: if so, we're gonna loop


if (UnflagLoopCounter > 4)
{
flagged := "no"
; prevent run away finding of red which is not a flag
}

	if (flagged = "yes") ; still see red even though no 'unflag order screen at this second'
	{
	UnflagLoopCounter++
	goto, hitenter
	}

;gosub flagclick ;---***highlight order for other stuff
flagged = no ; reset this

clipboard := oldclipboard ; restore original value

	; ************** create log entry 
	Rulenum = 19
	RuleString:= ""
	Gosub logit
	; **************end of log entry

return
;----------------------***************************************SIGN note --- the FANCY version

$^s::     ; $ prevents it from sending itself: will send actual windows command prn tries to send itself.

; THIS LOGIC deals with key release option or not: 0 = no release

 if ctrls <> 1
{
Gosub ^!s ; This means remove sign
}
else
{
send ^s ; this means send ctrl s directly
}

return

^!s::

sleep 50 ;  ... sometime it's not finding the meds .. ? need time for finger to come off key

; in notes we have "ClassNN:	TRichEdit6"
; blue meds that need refills "ClassNN:	TORListBox2"; ALSO flagged med orders to
;screen title need to deal with: NEXT NOTIFICATION:  Restricted Record
; needs to handle title: Location for Current Activities
;    followed by: Visit Is In Future

encnter = 0 ; set the encounter counter back to zero.

quitloop = no ; set this back to no

; beta comment this out 8-15-24?
; SetTitleMatchMode, 1 ; try this 3-27-23: was commented out. some people ? losing sign screen (?)

;  1 = A window's title must start with the specified WinTitle to be a match.



IfWinExist, Review / Sign ; we're either signing in the sig box.. or we're not
	{
	winactivate, Review / Sign  ; Floating bar drawing may take focus off; I think there has to be a sign box right??***

	gosub whatscreenamI ; This actually does the signing
	return ; added 3-15-23 per above
	; msgbox, test   
	}
	else  
; BETA CHANGED THIS IfWinExist, Sign ; THIS IS PICKING UP 'SIGN IN' webpages: exclude sign in
	IfWinExist, Sign,,Sign in
	{
	winactivate, Sign ; Floating bar drawing may take focus off; I think there has to be a sign box right??***

	gosub whatscreenamI ; added 12-8-23: Rob Bayer issue: not signing correctly. Need whatscreenamI
	return ; added 12-8-23
	; msgbox, test   
	}
	else  
IfWinExist, Cosign ; we're either signing in the sig box.. or we're not
	{
	winactivate, Cosign ; Floating bar drawing may take focus off; I think there has to be a sign box right??***
	gosub whatscreenamI ; added 12-8-23: Rob Bayer issue: not signing correctly. Need whatscreenamI
	return ; added 12-8-23
	; msgbox, test   
	}

else 
	{
; beta remove 8-16-24
; 	gosub ActivateCPRS ; Floating bar drawing may take focus off ; Orders Red or Blue need activation***
	sleep 50 ; ? 3-15-23 blue orders not getting done. ? !Winactive below not having time to activate.
	}

; SetTitleMatchMode, regex

hereIam := whereAmI() ;-----DETERMINE what we're looking at via whereamI() function

if !(WinActive("ahk_class TfrmSignOrders") or WinActive("ahk_class TfrmReview") or WinActive("ahk_class TfrmSignItem")) ;---NOT JUST A SIG BOX

{  ;------------ for things NOT just an SIG box :************LEFT 1



;----PROBLEMS: TORTreeView1 is consults tab cosign NOT an order; TORTreeView3 also now on consults cosign

;-------------List box doesn't appear to be active IF Patient Record Flags  screen comes first. Great.



	If hereIam = order ; what type of control are we looking at?

	{   ; ***********LEFT 2: IT'S AN ORDER NOT A NOTE



     ;	gosub ActivateCPRS ; Floating bar drawing may take focus off ; Orders Red or Blue need activation***  try this off 3-15-23: we activated Vista above.
	; but above does  not activated for blue flag tho

;--------------is this a flaggeed order? Search for RED color************LOOK FOR RED***************


gosub flaglocation  ; added 8-15-24: don't we need this here?

	if flagged = yes ;--------------THIS IS FLAGGED ORDER PROCESSING************************ LEFT 3: RED ORDERS
		{

			; SplashTextOn ,150 ,100, CPRS Booster, This is a flag!
		; sleep 500
		; SplashTextOff
	
	;MsgBox, 262144, CPRS Booster, THIS IS A FLAG

	; Figure out if this is an unreleased order or not

        Gosub flagclick ;?? click on flagged order
				if (UnreleasedOrder	= 1)
				{
						send !ag  ; just sign blue orders
						
						wesignedit := 0  ; this tracks if there was a sig in whatscreenamI
						gosub whatscreenamI ; process screens
						
						
						if (wesignedit = 0) ; did not sign
						{
						MsgBox, 262144, CPRS Booster, Order NOT signed!
						return
						
						}
						else ; we did sign the unreleased order and now we need to unflag
						{
								SplashTextOn ,150 ,100, CPRS Booster, Wait!
								sleep 1000
								SplashTextOff
								; when done the orders may not show up with flags.

								gosub showflaggedorders ; show flagged orders
								
						
							
								MsgBox, 262145, IMPORTANT: UNFLAG? ,I'M ABOUT TO UNFLAG THESE.`nOrder Was Signed`n (Can hit spacebar to accept) `n OK?

								IfMsgBox, Cancel
								{
								return
								}

								gosub unflag 
								SplashTextOn ,150 ,100, CPRS Booster, Done!
								sleep 600
								SplashTextOff

								return
						}
				}   ; end of unreleased order signing

	sleep 200

	send !a
	send w    ; renew
	SetTitleMatchMode, RegEx

	WinWait, Currently Processing Notifications|Primary Encounter Provider|Renew Orders|Sign|Sign Orders|Location for Current Activities|Unable to Renew Order|New Order|Copy Orders|Order Checking|Review / Sign Changes , , 15  ; *** SOME screen MUST appear so wait here before going on to whereI: o/w pay attn screen too soon
	sleep 200
	 ; Will repeat this b/c always more than one screen ;; NO this will cause a problem: because to process the first screen above we need WhatscreenamI
	;  WinWait, Primary Encounter Provider|Renew Orders|Sign|Sign Orders|Location for Current Activities|Unable to Renew Order|New Order|Copy Orders|Order Checking|Review / Sign Changes , , 5 ; *** SOME screen MUST appear so wait here before going on to whereI: o/w pay attn screen too soon

	sleep 300 ; there is a flagged delay at whatscreenamI but if we elongate that, the entire loop is elongated
	camefromflag := 1 ; might need this for multiple view alert processing/current process
	
	
		gosub whatscreenamI  ; should we just wait for the only possible screens after this? Unable vs renew?
	


	flagged = no
	flagged2 = no ; reset this; this variable is only used in the whereamI section
	
	

msgtxt := "                    ; ERROR happening here: sometimes the unflag process starts when red is there but blue not THEN blue shows up and probs
(
***

WAIT UNTIL YOU SEE RED FLAGGED ORDERS BEFORE
    CLICKING OK ON THIS SCREEN.
(CPRS can take a minute to show them)

I'm about to unflag this (these) order(s):

MAKE SURE the orders you see are displayed on
the signing screen (next).

If not, GO FIND them. 

Press CANCEL to skip unflag

Note: Using Ctrl-S/F1 on flagged orders works best
when there is a single (or two) flagged orders. 
5 flagged orders? Hope you're feeling lucky..

***
)"

bx := "CPRS Booster: Pay attention here"


	;  MsgBox, 262145, CPRS Booster: Pay attention here, %msgtxt%


SetTimer, WinMoveMsgBox, 50
Sleep 100
MsgBox, 262145, %bx%, %msgtxt%



	
	IfMsgBox, Cancel
	{
	return
	}
	sleep 120
	


	
	sleep 200
	gosub ^u  ;----unflag everything prior to tee up screen
	sleep 300
	gosub !+n ;---- go to next pt to tee up orders
	gosub youdoit

;  LOG HERE: flagged order processing

	; ************** create log entry 
	Rulenum = 6
	RuleString:= ""
	Gosub logit
	; **************end of log entry

	return


WinMoveMsgBox:
  If WinExist(bx)
    SetTimer, WinMoveMsgBox, OFF
  WinMove, %bx%, , 40, 500
Return
	

		} ;*****************---CLOSE of flagged order logic: RIGHT 3

;**************----------------for the blue orders NOT FLAGGED  ;-----------***************START BLUE MED ORDERS

;**********NOTE: THIS IS NOT THE BLUE INSIDE OF RED LOGIC: THAT's above.

		;	SplashTextOn ,150 ,100, CPRS Booster, NOT A flag!
		; sleep 500
		; SplashTextOff

sleep 200
send !ag 
	gosub whatscreenamI


;  LOG HERE: Blue orders


	; ************** create log entry 
	Rulenum = 7
	RuleString:= ""
	Gosub logit
	; **************end of log entry

	return  ; ----END of SIGNING med orders that are NOT flagged (ie blue orders)



		}    ;  ************RIGHT 2:-------------------end of logic to deal with signing orders

 Else ;--------------for anything not clearly an order and not an order box, ASSUME NOTE******************** BELOW IS NOTE STUFF**************

;If InStr(controlname, "RichEdit") ;  ---or InStr(controlname, "tree") ; SIGN NOTES; THIS WORKS; NO others can have tree
	{

	gosub ActivateCPRS ; Floating bar drawing may take focus off; Note sigs also need CPRS activation***

	;MsgBox, 262144, Note, this is note of some sort
	;return

	 ;if (focused_control = "TRichEdit6") or  (focused_control = "TRichEdit3")   ;------------THese are progress notes/ dc
	; Rich3 appears to be the one where you see only one note

; look at code capture from note concept


	send ^+g
	
	 sleep 300 ; ------ PHONE clinic hand off missing. THIS SHOULDN'T Matter if WhatscreenamI is working to wait correctly.

	gosub whatscreenamI



;  LOG HERE: Note signing


	; ************** create log entry 
	Rulenum = 8
	RuleString:= ""
	Gosub logit
	; **************end of log entry

	return ;-----------end of note signing

	; PROBLEM: what if encounter location comes up?; PROBLEM#2: COSIGNING CONSULTS: CTRL ALT G doesn't work

	}   ;-----------end of signing progress notes 

 ;-----}

   } ;-***********RIGHT 1:--------end of logic to do something besides just pound in the sig code


winactivate, Sign ; Floating bar drawing may take focus off; I think there has to be a sign box right??***

gosub whatscreenamI ; this will get through to the review/sign changes but after we send sig code (after F1) it will come back here
					; and we then need to wait for rest of screens{gosub again) (PIV/curr process/etc If there was an innextstep prior)

if (InNextPtStep=1)
{
gosub whatscreenamI ; hopefully the end terminus screens will reset this variable to 0
}

;  LOG HERE: fill in sig box


	; ************** create log entry 
	Rulenum = 9
	RuleString:= Sigcode
	Gosub logit
	; **************end of log entry

return


whereAmI()  ;------*************function to find out what user looking at
{


whereI ="" ; reset variable

;  new stuff ---
gosub flaglocation ; ----***see if there is a flag: if so assume flagged order and finish --Test 6-20-21

	if flagged = yes 
	{
	whereI = order
	return WhereI
	}


gosub Bluelocation ; check for blue orders

 ;  msgbox, %blue% 
	if blue = yes
	{
	whereI = order
	Global blue:= "no" ; we are inside of a function
	;  msgbox BLUE!  
	 
	
	return WhereI
	}


ControlGetFocus, focused_control

; msgbox, %focused_control%   ; in consults alt-a then R then g will sign


if errorlevel = 1
{
;   whereI = unknown
whereI = note  ;**********experiment: assume it's an order if type not known??

}


controlname :=focused_control


If InStr(controlname, "ListBox")  ;---------order highlighted prob 
{
whereI = order
}

If InStr(controlname, "RichEdit") or  InStr(controlname, "TreeView") or InStr(controlname, "TabC") ; ERROR BLUE ORDERS ARE TRIGGERING

{
whereI = note
}


If InStr(controlname, "ComboEdit") ;-----THis is actually INSIDE the flagged order screen

{
whereI = flag
}



; msgbox, here I am   %controlname%  

return WhereI

}  ;-----------------********************END of where am I



Refreshdata:  ;  ******************-----------start refresh/READ FILE function INPUT only

gosub netcheck

; MsgBox, 262144, CPRS Booster, we are reading data


 ; ? could this be copying blank data from one drive to another
try
{
FileGetTime, LastOneDrive, %onedriveBoosterFilename% , M
FileGetTime, LastUDrive, u:\CPRSBooster\CPRSData.txt , M
}


if (LastOneDrive > LastUDrive)
{
; msgbox ONE IS RECENT  One: %LastOneDrive% `n  U: %LastUDrive%
filenameRead =  %onedriveBoosterFilename%

		try
	{
	FileCopy, %onedriveBoosterFilename%, u:\CPRSBooster\CPRSData.txt, 1  ; *** If ONE is more recent AND U is available: copy to U
	}

}
else
{
; msgbox U is recent  One: %LastOneDrive% `n  U: %LastUDrive%
filenameRead = u:\CPRSBooster\CPRSData.txt

	try
	{
	filenameCopy =  %onedriveBoosterFilename%
	FileCopy, u:\CPRSBooster\CPRSData.txt, %filenameCopy%, 1  ; *** If U is more recent AND One is available: copy to ONE.

	}


}



filenameRead =  %onedriveBoosterFilename%   ; 5-1-23: always use OneDrive

;---------------Varible#1 as below:
;---------1: version # of this program;  2: Has user seen help for this version: yes/no; 
;-------3: RN1; 4: RN2; 5: MSA; 6: sigcode; 7:F2f Clinic; 8:phoneClinic; 9: pharm

  ; Each array must be initialized before use:
  Array := []
  Array[j] := A_LoopField
  Array[j, k] := A_LoopReadLine
  ArrayCount := 0


  Loop, Read,  %filenameRead%

  {
      ArrayCount += 1
 
      Array[ArrayCount] := A_LoopReadLine
  }



;-------------------!THIS IS THE ORDER OF THE DATA IN THE USER'S LOCAL FILE!-------------------****ADD NEW STUFF HERE: STEP 1
; --------------- NOTE: the file read above will pull every line into the array. Then you need to assign variables from array values

Global version := Array[1]
Global versionHelp:=Array[2]
Global Nurse1:=Array[3]
Global Nurse2:= Array[4]
Global MSA1:=Array[5]
SigCode:= Array[6]
f2fclinic:=Array[7]
phoneClinic:= Array[8]
Global pharm:= Array[9]
Global Prov1:=Array[10]
Global Prov2:=Array[11]
  		  ;----load the fxn keys

fxn.1:= Array[12]

Length := StrLen(fxn.1)
if Length <1  ; sets a default value
{
fxn.1 := "Sign"
}


fxn.2:=Array[13]
Length := StrLen(fxn.2)
if Length <1  ; sets a default value
{
fxn.2 := "Add RN1"
}

fxn.3:=Array[14]
Length := StrLen(fxn.3)
if Length <1  ; sets a default value
{
fxn.3 := "Add MSA"
}



fxn.4:= Array[15]


; Sign|Add RN1|Add RN2|Add MSA|Add BOTH|Add PHARM|Unflag|Next Patient|Make Addendum|Add PROV1|Add PROV2|Phone Clinic|F2F Clinic|

Length := StrLen(fxn.4)
if Length <1  ; sets a default value
{
fxn.4 := "Unflag"
}

fxn.5:=Array[16]
fxn.6:= Array[17]
fxn.7:=Array[18]
fxn.8:= Array[19]
fxn.9:= Array[20]

Length := StrLen(fxn.9)
if Length <1  ; sets a default value
{
fxn.9 := "Phone Clinic"
}


fxn.10:=Array[21]

Length := StrLen(fxn.10)
if Length <1  ; sets a default value
{
fxn.10 := "F2F Clinic"
}




fxn.11:=Array[22]

Length := StrLen(fxn.11)
if Length <1  ; sets a default value
{
fxn.11 := "Make Addendum"
}


fxn.12:=Array[23]


Length := StrLen(fxn.12)
if Length <1  ; sets a default value
{
fxn.12 := "Next Patient"
}



ctrla:=Array[24] ; variable to track release of Ctrl-A
altn:=Array[25] ; variable to track release of Alt-N

ctrlm:=Array[26] ; variable to track release of Ctrl-M
ctrln:=Array[27] ; variable to track release of Ctrl-N
ctrlp:=Array[28] ; variable to track release of Ctrl-P
ctrlr:=Array[29] ; variable to track release of Ctrl-R
ctrls:=Array[30] ; variable to track release of Ctrl-S


; NOTE from here we have an additional # of array variables = to the # of write lines (loop) in the WriteArray[] below.

HBO:=Array[31] ; Hyperdrive bar settings; reading in
HBH:=Array[32]
HBV:=Array[33]

FBO:=Array[34] ; function bar settings
FBH:=Array[35]
FBV:=Array[36]

VVC:=Array[37] ; 
SMUrl:=Array[38]


Global Person1:=Array[39] ; additional additional signers; NOTE ANY NAME THAT WILL APPEAR ON FXN BAR MUST BE ***GLOBAL VARIABLE
Global Person2:=Array[40]
Global Person3:=Array[41]
Global Person4:=Array[42]
Global Person5:=Array[43]
Global Person6:=Array[44]

Global Noshortcut:=Array[45]
Global AutoDragon:=Array[46] 
Global Nevershortcut:=Array[47]


Global notetitle1:=Array[48] 
Global notetitle2:=Array[49]
Global notetitle3:=Array[50]
Global notetitle4:=Array[51]
Global notetitle5:=Array[52]
Global notetitle6:=Array[53]


Global locNote1:=Array[54]
Global locNote2:=Array[55]
Global locNote3:=Array[56]
Global locNote4:=Array[57]
Global locNote5:=Array[58]
Global locNote6:=Array[59]
NoteFavsArray[1] := Array[60]
NoteFavsArray[2] := Array[61]
NoteFavsArray[3] :=Array[62]
NoteFavsArray[4] :=Array[63]
NoteFavsArray[5] :=Array[64]
NoteFavsArray[6] :=Array[65]
NoteFavsArray[7] :=Array[66]
NoteFavsArray[8] :=Array[67]
NoteFavsArray[9] :=Array[68]
NoteFavsArray[10] :=Array[69]
tempNote1 :=Array[70]
tempNote2 :=Arrays[71]
tempNote3 :=Array[72]
tempNote4 :=Array[73]
tempNote5 :=Array[74]
tempNote6 :=Array[75]
OneTimeVoogleEducation :=Array[76]
OneTimeAddPCPEducation :=Array[77]
SiteSpecificDownKeysToMedOrderMenu :=Array[78]
GotRxQOInstructions :=Array[79]
AmbDictationDone :=Array[80]
lastprompttype := Array[81] 

 ; msgbox, %NoShortcut%  ;



;----THESE are the FORM (CtrlH) variables... to be overwritten, if used, by Ctrl H: MAKE SURE TO ADD HERE WITH NEW VARIABLES
; ----LEFT side of this equation below has to equal the data written in the Writing to file subroutine
RN1:=Nurse1
RN2:=Nurse2
MSA:=MSA1
Code:=SigCode
F2F:=f2fclinic
Phone:=phoneClinic
Pharm1:=pharm
MD1:=Prov1
MD2:=Prov2

;----- the function keys use a drop down box and don't need these default variable to set the default option.


return ;-----------------**************END OF DATA REFRESH SUBROUTINE****************--------------------


writeit:


gosub netcheck

 ;--- start writing: one copy to each location


	;-----***WRITE TO U****
	IfExist, U:\   ; **************** If there is a U drive write a copy there.
	{
	filename = u:\CPRSBooster\CPRSData.txt
	gosub writingdetails
	} 
	    ; ?? THESE TWO write statements coming close together may cause a write error ? if Onedrive is slow
	sleep 100

	;-----***WRITE TO ONE********
	if (getprocesses() = 1) ; ONE DRIVE IS ACTIVE ; CALLS a function located toward end of script
	
	{

	filename = %onedriveBoosterFilename% 
        gosub writingdetails
	}	

return ;---------------------******************END of FILE WRITING ROUTING




writingdetails: ;-------****************took this out of writeit sub routine b/c gonna write twice: once to U and Once to OneDrive if both extant


; MsgBox, 262144, CPRS Booster, %code%

instru := "
(
DATA NOT SAVED

As a safeguard against deleting your
Booster data, Booster always looks to see
that the signature code field on the Ctrl-H
screen is NOT blank. If it IS blank, Booster
assumes there is a problem and does not 
save data (it might otherwise write blank data
....overwriting all of your data). 

So make sure, on Ctrl-H, you have
something in the signature code field.

IF you already have something there: there 
is some problem saving Booster data and your 
most recent edits to Booster may not have 
been saved (to avoid deleting everything).

Go to Ctrl-H--> troubleshooting. Look at 
FAQ 1b. Follow steps.


)"

if (strlen(code) < 3)
{
MsgBox, 262144, CPRS Booster, %instru%

return
}
; lenthofcode := strlen(code) 
; MsgBox, 262144, CPRS Booster, writing
; MsgBox, 262144, CPRS Booster, length %lenthofcode%
file := FileOpen(filename,"w `n")   ;-------******************WRITING DATA TO FILE
;                  ----------------the variable names from the form are case sensative: ORDER MATTERS BELOW
file.writeline(CurVersion)
file.writeline("No")F
file.writeline(RN1)
file.writeline(RN2)
file.writeline(MSA)
file.writeline(Code)
file.writeline(F2F)
file.writeline(Phone)
file.writeline(Pharm1)
file.writeline(MD1)
file.writeline(MD2)

file.writeline(fxn.1)
file.writeline(fxn.2)
file.writeline(fxn.3)
file.writeline(fxn.4)
file.writeline(fxn.5)
file.writeline(fxn.6)
file.writeline(fxn.7)
file.writeline(fxn.8)
file.writeline(fxn.9)
file.writeline(fxn.10)
file.writeline(fxn.11)
file.writeline(fxn.12)

file.writeline(ctrla)
file.writeline(altn)

file.writeline(ctrlm)
file.writeline(ctrln)
file.writeline(ctrlp)
file.writeline(ctrlr)
file.writeline(ctrls)


file.writeline(HBO)  ; THIS IS ITEM #31 ON READ IN ARRAY
file.writeline(HBH)
file.writeline(HBV)
file.writeline(FBO)
file.writeline(FBH)
file.writeline(FBV)
file.writeline(VVC)
file.writeline(SMUrl)
file.writeline(Person1)
file.writeline(Person2)
file.writeline(Person3)
file.writeline(Person4)
file.writeline(Person5)
file.writeline(Person6)

; USE THE ARRAY BELOW

 writeArray := []
 writeArrayCount := 0


; NEW DATA GOES IN ARRAY VALUE BELOW:45 to (44+loop num) -----------don't use a array numb < 45 o/w wont match numbers on read (refresh) section)



; **** note: NUMBER OF LOOP COUNTS (below) MAY need to be increased if new data is added
writeArray[45] := 1 ; this is read item #45 ; we will use this as flag: never ask to create desktop shortcut again= 1; null or 0 = ok to ask
writeArray[46] := AutoDragon
writeArray[47] := Nevershortcut


writeArray[48] := notetitle1
writeArray[49] := notetitle2
writeArray[50] := notetitle3
writeArray[51] := notetitle4
writeArray[52] := notetitle5
writeArray[53] := notetitle6

writeArray[54] := locNote1
writeArray[55] := locNote2
writeArray[56] := locNote3
writeArray[57] := locNote4
writeArray[58] := locNote5
writeArray[59] := locNote6
writeArray[60] := NoteFavsArray[1]
writeArray[61] := NoteFavsArray[2]
writeArray[62] := NoteFavsArray[3]
writeArray[63] := NoteFavsArray[4]
writeArray[64] := NoteFavsArray[5]
writeArray[65] := NoteFavsArray[6]
writeArray[66] := NoteFavsArray[7]
writeArray[67] := NoteFavsArray[8]
writeArray[68] := NoteFavsArray[9]
writeArray[69] := NoteFavsArray[10]
writeArray[70] := tempNote1
writeArray[71] := tempNote2
writeArray[72] := tempNote3
writeArray[73] := tempNote4
writeArray[74] := tempNote5
writeArray[75] := tempNote6
writeArray[76] := OneTimeVoogleEducation
writeArray[77] := OneTimeAddPCPEducation 
writeArray[78] := SiteSpecificDownKeysToMedOrderMenu
writeArray[79] := GotRxQOInstructions
writeArray[80] := AmbDictationDone
WriteArray[81] := lastprompttype






 	; The loop below is ONLY for writing the additional items assigned to writeArray[] starting at [45]: so need at loop to include as many items prn
 Loop, 50 ; make this loop at least as big as need to write data; 

 {
      looper := A_Index + 44 ; we're starting the array 44 slots later on the write than we did on the read.
      file.writeline(writeArray[looper])
	
	; MsgBox, % A_Index " " writeArray[looper]
  }


file.close()



return ; -------------------************end of write details



;############################################################################################
;###############Flag or Sign whoever PCP is########################################
;############################################################################################

^+!p::
FlagOrSignPCP:


defaultToMed := "yes"

WinActivate, VistA CPRS in use
sleep 100
; add forward logic here 
IfWinExist, Forward Alert
{


gosub getPCP 

	if (PCPfound = true)
	{

	
			ControlClick,TORComboEdit1, Forward Alert
			; winactivate, Forward Alert
			; send {tab}
			send %PCPname%
			send {tab}
			send {enter}
			Send {tab 3}
			SplashTextOn ,150 ,100, CPRS Booster, You finish
			sleep 500
			SplashTextOff
	}
}
else
{
gosub getPCP

	if (PCPfound = true)
	{
	gosub addorflag
	}
}
return


;############################################################################################
;###########################Logic to Get PCP from CPRS#######################################
;############################################################################################
getPCP:


PCPfound := true ; assume we can find it until proven otherwise
; gosub ActivateCPRS
; WinGetText, chartPCP, A  ; BETA try using line below: doesn't work in forward alert

WinGetText, chartPCP, VistA CPRS in use

; Check for 'No PACT/HBPC'
if InStr(chartPCP, "No PACT")
{
    MsgBox, 262144, CPRS Booster, Cannot figure out who PCP is
    PCPfound := false
    return
}

; Use InStr to find the second occurrence of "/ PCP"
secondPCP := InStr(chartPCP, "/ PCP", 0, 1, 2)

; Check if "/ AP " follows the second "/ PCP"
apPos := InStr(chartPCP, "/ AP ", 0, secondPCP)

if (apPos > 0)
{
    ; Find the position of line break after "/ AP "
    mhPos := InStr(chartPCP, "`n", 0, apPos)
    
    ; Calculate the length of the resident PCP name
    textLength := mhPos - apPos - 5
    
    ; Extract the resident PCP name using SubStr
    residentPCPName := SubStr(chartPCP, apPos + 5, textLength)
    
    ; Remove newline (`n`) and carriage return (`r`) characters
    StringReplace, residentPCPName, residentPCPName, `n, , All
    StringReplace, residentPCPName, residentPCPName, `r, , All
    
    ; Assign the resident PCP name to thisone
	    if (StrLen(residentPCPName) > 25)
    {
        pcpName := SubStr(residentPCPName, 1, 25)
    }
	
	
    thisone := residentPCPName
	
}
else
{
    ; Use the original logic to find the staff PCP name
    lineBreak := InStr(chartPCP, "`n", 0, secondPCP)
    textLength := lineBreak - secondPCP - 6
    pcpName := SubStr(chartPCP, secondPCP + 6, textLength)
    StringReplace, pcpName, pcpName, `n, , All
    StringReplace, pcpName, pcpName, `r, , All
    
    ; Truncate the pcpName if it's longer than 25 characters
    if (StrLen(pcpName) > 25)
    {
        pcpName := SubStr(pcpName, 1, 25)
    }

    thisone := pcpName
}

pcpname := residentPCPName  ; for forward alert we are usign %pcpname%
; MsgBox, 262144, CPRS Booster, PCP is %pcpname%


return



;############################################################################################
;############################################################################################
;############################################################################################






AddorFlag:   ;-----------------************this function adds as ADD signer OR FLAGS order to them: based on whereamI() location.

If WinExist("Location for Current Activities") 

{

Msgbox, 262144, Booster, I think you hit the wrong key! You tried to add a signer not enter a clinic location.

return

}

gosub ActivateCPRS ; Floating bar drawing may take focus off
hereIam := whereAmI()



 ;-----*********what if whereAm I doesn't know where you are? This is likely a flag that isn't activated

	if hereIam = unknown

	{
	;---check to see if flagged
	gosub flaglocation
	if flagged = yes

		{
		; gosub FlagClick  ; Don't we do this below? Duplicate?
	
		hereIam = order ;---set this to order to work below
		}
	
	
	}

	if hereIam = note ;----**user adding additional signer
	{
			;MsgBox, 262144, location, note

			sleep 40

			 Send  !a
			 sleep 100
			 send I
			 sleep 50
			 send {BackSpace 3}
			
			 ; SendEvent, i 
			 sleep 200 ; BETA From 500

			IfWinExist, Insufficient Authorization
			{ ; ----------------Someone trying to add someone to a note they didn't write.

			return
			}

			sendraw %thisone%
			send {enter}
			sleep 200
			send !O
	} ;----END of if I'm a note (add signer)

 if hereIam = order ;----**user in orders section getting ready to flag someone
	{
		;MsgBox, 262144, location, order

		gosub flaglocation ; ----***see if the order is flagged

			if flagged = yes ; ----***someone wants to both unflag AND reflag to person
				{
			flagged = no ; reset this
			; gosub ^u ; we're unflagging MOVE THIS BELOW capture of last flag location
			; PROBLEM HERE: The UNFLAG subroutine itself (line above) LOOPS until all Red is gone. HENCE we've LOST last flag location.
			;    so flag click has no where to go.
			 ; THE SOLUTION: saved PxOld inside ^u:: that will hold last SUCCESSFULL find flag:
				PxStartOfUflag := PxOld  ; pxold is found coords from flaglocation
				PyStartOfUflag := PyOld
				Px2StartOfUflag := Px2Old
				Py2StartOfUflag := Py2Old 
			gosub ^u  ; this will RESET Px and Py kind of inadvertendly by using flaglocation to stop looping
			
			PxFlag := PxStartOfUflag 
			PyFlag := PyStartOfUflag 
			Px2FlaG :=	Px2StartOfUflag 
			Py2Flag :=	Py2StartOfUflag
			
			gosub flagclick ; re-select the area that WAS flagged: if blue background orders were the orders: we don't need to select: user did
				}

		; ************************* modified for new version of flagging

		sleep 130
		Send  !a
		send f


		SetTitleMatchMode, Slow

		startTime := A_TickCount
		previousText := ""

		Loop    ; LOOK FOR MULTIPLE FLAG ORDER SCREENS IN SEQUENCE PRN
		{
			; Check if 'Flag Order' screen exists
			IfWinExist, Flag Order
			{
				; Reset the start time as the screen is present
				startTime := A_TickCount

				; Check for text changes in the 'Flag Order' screen
				WinGetText, slowText, Flag Order
				If (slowText != previousText)
					{
					; Text has changed, perform the logic
					startTime := A_TickCount  ; reset timer for new screen
					previousText := slowText
					sleep 200
					; Perform the logic
					send {tab}
					sleep 100
						if defaultToMed = yes
						{
							sleep 100
							; clipboard := "Med renewal"
							; sleep 100
							; send ^v
							send Med Renewal
							sleep 100
							namefrag := SubStr(thisone, 1, 13)
							send - %namefrag%
						}

					send {tab}
					sleep 500
					send %thisone%
					send {enter}

				
			
				;############################################################################################
				;##################start flag success check###############################################
				;############################################################################################

				sleep 300
				; Save the current clipboard contents
				ClipSaved := ClipboardAll

				; Send Ctrl+c to copy the current selection to the clipboard
				Send, ^c
				Sleep, 150  ; Wait a moment for the clipboard to update

				; Retrieve the clipboard contents
				ClipNew := Clipboard


				; Check if 'thisone' is found inside the clipboard contents
					if InStr(ClipNew, thisone)
					{
					  ;  MsgBox, Flagging was successful.
					}
					else
					{
						MsgBox, 262144, CPRS Booster, Booster Could Not Flag It: you finish
						return
					}

				; Restore the original clipboard contents
				Clipboard := ClipSaved

				; Clean up
				ClipSaved := ""
				ClipNew := ""


			
				;############################################################################################
				;############################end flag success check###########################################################
				;############################################################################################

					if defaultToMed = no
					{
						Send {tab 6}
					}

					sleep 50
					send !f
					sleep 400
				}
			}
			else
			{
				; Check if timeout period (5 seconds) has passed
				if (A_TickCount - startTime > 5000)
				{
					; Exit the loop if timeout period has passed
					break
				}
			}
			; Small delay to prevent high CPU usage
			sleep 100
		}


}  ;---------END if I am an order to flag



defaultToMed = no ; reset this 

return 

;############################################################################################
;################END OF ADD OR FLAG SUBROUTINE#########################################
;############################################################################################


;############################################################################################
;###################START flag location: FINDs flag borders/coodinates#############################
;############################################################################################


flaglocation:
flagfound := "yes"   ; if there are pixel search errors below, we change this to no.
    

if (debugging = true)
	{
		SplashTextOn ,150 ,100, CPRS Booster, In flag LOCATION subroutine
		sleep 800
		SplashTextOff

	} 
; COORDS OF TOP RIGHT OF FLAG:
CoordMode, Mouse, Screen
CoordMode, Pixel, Screen
WinActivate, VistA CPRS in use
;  BETA 11-20-24: THIS MAYBE CAUSING BOOSTER TO STOP WinWaitActive, VistA CPRS in use
sleep 50
WinGetPos, cx ,cy, cw, ch, VistA CPRS in use
; the offset of - 200 is to avoid red on the right side of screen; + 200 is to move the left margin rightward (clocks)
;-50 is to avoid icons in tray
; 
PixelSearch, PxFlag, PyFlag, cx+cw-200, cy+150, cx+200, cy+ch-50, 0xFF0000, 0, Fast RGB ; This should search only within the window width and height
if (ErrorLevel = 0)  ; COORDS OF TOP RIGHT OF FLAG: PxFlag, PyFlag
{
    if (debugging) 
    {
        SplashTextOn ,150 ,100, CPRS Booster, I think you're dealing with a flagged order.
        sleep 4000
        SplashTextOff
        ; MsgBox, 64, Debugging, I think you're dealing with a flagged order.
        
        MouseMove, PxFlag, PyFlag
        SplashTextOn ,150 ,100, CPRS Booster, Find the Mouse! That's red
        sleep 3000
        SplashTextOff
    }
    
    ; COORDS OF BOTTOM RIGHT OF FLAG:
    PixelSearch, Px2Flag, Py2Flag, cx+cw-200, cy+ch-50, cx+200, cy+150, 0xFF0000, 0, Fast RGB ; This should search only within the window width and height
}
else
{
    flagfound := "no"
    if (debugging) 
    {
        SplashTextOn ,150 ,100, CPRS Booster, Debugging, I think there is NOT a flagged order here (note or unflagged order)
        sleep 4000
        SplashTextOff
        ; MsgBox, 64, Debugging, I think there is NOT a flagged order here (note or unflagged order)
    }
}

if (flagfound = "no")
{
    global flagged := "no" ; if either the top or bottom red search borders fail===>flag found = no
}
else
{
    global flagged := "yes"
    
    ; These next lines hold the last known flagged position because when we do addorsign:
    ; that includes the unflag subroutine which loops until all flags are gone.
    ; BUT then we need the last FOUND flag position to reselect those orders to flag back.
    PxOld := PxFlag
    PyOld := PyFlag
    Px2Old := Px2Flag
    Py2Old := Py2Flag
}

return

	
;#################################END OF FLAGLOCATION LOGIC###########################################################
;############################################################################################
;############################################################################################





clickoncolor(colorVar,searchdelay) ; THIS WORKS ;waits for a certain color (ie screen) and clicks; only works from top down now
{
coordmode,pixel,window


	loop, %searchdelay%
	{
	;  Activativate application prior to this routine ----winactivate, Dragon Medical One
	PixelSearch, Dx, Dy, 0,10, 1500, 950,colorVar ,,RGB Fast  ; 

			if ErrorLevel
			{
			; msgbox %searchdelay% %colorVar%
			sleep 500
			}
			else
			{
			sleep 500
			
			  ; MsgBox, 262144, CPRS Booster, %clicktoside%  pos  %dx%
			
					if (clicktoside = 1) ; click NEAR the color
					{
					
					Dx := Dx - 300
					; MsgBox, 262144, CPRS Booster, New dx %Dx%
					mouseclick, left, %Dx%, %Dy%
					
					clicktoside := 0
					}
					else
					{
					mouseclick, left, %Dx%, %Dy%
					}
			
			break ; we found and clicked on color. break loop
			}
	
	}

}

;############################################################################################
;##################################Start PIV screen processing##################################################
;############################################################################################

Piv:
	

; Check if the "ActivClient Login" window is present ; have to get out of way of color search
	IfWinExist, ActivClient Login
			{
				; Save the current position and size of the window
				WinGetPos, X, Y, Width, Height, ActivClient Login
				
				; Move the window to the left side of the screen
				WinMove, ActivClient Login, , 0, Y
				
				
			}
	

	winactivate, Authenticating
	send {pgup 3} ; don't know if this does anything but need top bar on screen
	; winactivate, Authenticating
  coords := ColorSearch("Authenticating", "0x393939", 4000 , "q2", "TR")
  ; winactivate, Authenticating
 	gosub clickoncolor ; clicks on the coords 
    Colorfound := coords.color
	 MsgBox, 262144, CPRS Booster, color: %colorfound%

  IfWinExist, ActivClient Login
  {
	  ; Move the window back to its original position
	  WinMove, ActivClient Login, , X, Y
  }
return


 		;  MsgBox, 262144, CPRS Booster, PIV screen %Colorfound%  
	/*


		; Once we're on that screen (can uses color search but don't need to click on color)
	
		sleep 50
		winactivate, Authenticating
		send {tab 2}
		sleep 750
		winactivate, Authenticating
		send {enter}
	*/

return




;############################################################################################
;#########################END PIV processing##########################################
;############################################################################################


;############################################################################################
;##########################start Click through Dragon Login############################################
;############################################################################################

;*** dragon pIV visible text is 'VA Identity and Access Management System (IAM)''
; VA user has text 'Home Realm Discovery'
FindDragonWindow1:

if (AutoDragon <> 1)
{
return ; don't start dragon if user configured out of it in settings.
}

SplashTextOn ,300 ,100, CPRS Booster, FINISH Dragon Login in MANUALLY FOR NOW
sleep 4000
SplashTextOff

Return



; Wait for either of the windows to appear
WinWait, Authenticating, , 45 ; Adjust timeout as needed

SplashTextOn ,300 ,100, CPRS Booster, DON'T TOUCH MOUSE: processing dragon screens
sleep 1000
SplashTextOff
CoordMode, Mouse, Screen
CoordMode, Pixel, Screen
Loop 
	{
		; Check if the 'Authenticating' window exists
		if WinExist("Authenticating") 
		{
			; Retrieve visible text from the 'Authenticating' window
			WinGetText, windowText, Authenticating
			
			; Look for 'Home Realm Discovery' text for VA Users window
			if InStr(windowText, "Home Realm Discovery")
				 {
				
				Gosub, VAUsers ; Call the VAUsers processing section
				continue ; Go back to the loop to check for the PIV window
				}


				WinActivate, Authenticating
				WinGetText, windowText, Authenticating
			; Look for 'VA Identity and Access Management System' text for PIV window
			if InStr(windowText, "VA Identity and Access Management System")
				{		
					;SplashTextOn ,150 ,100, CPRS Booster, VA identity
					; sleep 600
					;SplashTextOff
				WinMove, Authenticating,,500,0
				sleep 30

					; Get the new position and size of the 'Authenticating' window
					WinGetPos, xPos, yPos, width, height, Authenticating
				
					; Calculate the starting and ending points for PixelSearch
					startX := xPos + width - 1
					startY := yPos
					endX := xPos
					endY := yPos + height - 1
				
					; Search for the color 0x393939 starting from the upper-right corner
					PixelSearch, foundX, foundY, startX, startY, endX, endY, 0x393939, 0, Fast RGB
				
					if (ErrorLevel = 0) ; If the color was found
					{
						; Calculate the Y coordinate for the click (150 pixels below foundY)
						; clickY := foundY + 150
						;MsgBox, 262144, CPRS Booster, X,y %foundX%, %foundy%
						; Move the mouse and click 150 pixels below the found color
						MouseMove, %foundX%, %foundY% 
						;MsgBox, 262144, CPRS Booster, MOUSE WAS MOVED TO FOUND
						MouseClick, left, foundX, foundy
					}
					else
					{
						; MsgBox, Color not found on the window
					}
					
				break ; End the loop as PIV window has been processed
				} ; End of PIV loop
		} ; End of Look for authenticating window
	} ; end of loop 



; NOW CLEAR THE LAST DRAGON SCREEN
	Winwait Dragon Medical One,,10     ; this is the last screen: the use past settings 
	coords := []
	coords := ColorSearch("Authenticating", "0x2DC6D6", 7000 , "q2", "TR") 
	; The line above basically just pauses us until that color is there.
	winactivate Dragon Medical One
	foundcolor := coords.color
	; MsgBox, 262144, CPRS Booster, %foundcolor% 
	; 36C8D8  color on this last page: b/c page doesn't load its content even when title present
	
			if (coords !=false)
			{
			sleep 2200
			winactivate Dragon Medical One
			send {tab 5}
			sleep 60
			winactivate Dragon Medical One
			send {enter}
			}
			
		  SplashTextOn ,300 ,100, CPRS Booster, Ok - Mouse is all yours
		  sleep 2000
			SplashTextOff


 return 


; SUPPORT FUNCTIONS FOR DRAGON PROCESSING WINDOWS
 ; VA Users processing
 VAUsers:
		; code to handle the VA Users window goes here
		winactivate Authenticating
		sleep 50
		send {tab}
		sleep 50
		send {enter}
		sleep 3000
 Return


/*


sleep 10000
repeatcolorsearch:
coords := []

; WE are looking for ONE of either of two screens: VA users screen and/or PIV screen

; What if CPRS pops up and is blocking one of these
coords := ColorSearch("Authenticating", "0x505050|0x393939",13000,"","") ; sets coords 
;
; this is the 'VA users' screen: 0x71ABE7 ==> now 505050 ; This is the PIV gold pic 0x3287C5 (not using)

; 0x106BAE this is the PIV top bar: gold thingy can be blocked by CPRS when dragon AND cprs launching at same time.

if (coords !=false)
{
colorfound := coords.color


					SplashTextOn ,300 ,100, CPRS Booster, DON'T TOUCH MOUSE: processing dragon screens
					sleep 1000
					SplashTextOff

		if (colorfound = "0x505050")
		{
		 MsgBox, 262144, CPRS Booster, VA USERS screen
		gosub clickoncolor ; clicks on the coords
		winactivate Authenticating
		sleep 50
		send {tab}
		sleep 50
		send {enter}
		sleep 2500
		goto repeatcolorsearch  ; we found the vA users screen, now repeat search for PIV screen.
		}
		else ; we are past 'VA users' screen. Flow is consistent here forward.
		{
		 MsgBox, 262144, Found PIV bar, Found PIV color: %colorfound%  
		
		 dispcolorx := coords.screenX
		dispcolory := coords.screenY

		MsgBox, 262144, CPRS Booster, PIV color found at %dispcolorx%,%dispcolory%
		gosub PIV ; clicks through PIV card page to 'other options'
		; sleep 200  ; wait for wavy flag page
		; send {tab}
		; sleep 50
		; send {enter}


		
	
		Winwait Dragon Medical One,,10     ; this is the last screen: the use past settings 
		coords := []
		coords := ColorSearch("Authenticating", "0x2DC6D6", 7000 , "q2", "TR") 
		; The line above basically just pauses us until that color is there.
		winactivate Dragon Medical One
		foundcolor := coords.color
		; MsgBox, 262144, CPRS Booster, %foundcolor% 
		; 36C8D8  color on this last page: b/c page doesn't load its content even when title present
		
				if (coords !=false)
				{
				sleep 2200
				winactivate Dragon Medical One
				send {tab 5}
				sleep 60
				winactivate Dragon Medical One
				send {enter}
				}
				
			  SplashTextOn ,300 ,100, CPRS Booster, Ok - Mouse is all yours
			  sleep 2000
				SplashTextOff
		}
}
else
{
  MsgBox, 262144, CPRS Booster, Color NOT found

}


return
 
*/

;############################################################################################
;###############################END of Dragon logon############################################
;############################################################################################

;############################################################################################
;#######################? this is Find blue orders??#########################################
;############################################################################################


Bluelocation: ;----load the variabels px and py with top of blue location (STARTING LOCATION OF BLUE); also sets the blue y/n variable
	; winactivate Vista C
	
	if (debugging = true)
		{
			SplashTextOn ,150 ,100, CPRS Booster, In BLUE LOCATION click subroutine Px and Py
			sleep 1600
			SplashTextOff
	
		} 

	gosub activateCPRS  
	sleep 10
	coordmode,pixel,screen
	coordmode,mouse,screen
	PixelSearch, PxBlue, PyBlue, 750, 10, 850, 950,0x0078D7,,RGB Fast ; 8-21 moved this to the right so doesn't pick up 'all services'
	if ErrorLevel = 0
		  {
		global blue:= "yes"
		; 
    ; Msgbox, 262144, Blue location?, Blue! ; 
		 }
	else 
	{
		global blue:= "no"
	}

return





BlueClick:
    ;---------------------************Click BOTTOM of BLUE orders; DRAG over blue

	if (debugging = true)
		{
			SplashTextOn ,150 ,100, CPRS Booster, In BLUE click subroutine
			sleep 1500
			SplashTextOff
	
		} 

	gosub activateCPRS 
    ; Get the title of the active window
    WinGetActiveTitle, activeWindow
    
    ; Get the dimensions of the active window
    WinGetPos, winX, winY, winWidth, winHeight, A
    
    ; Define the search area (right quarter of the active window)
    startX := winX + winWidth * 0.75
    startY := winY
    endX := winX + winWidth
    endY := winY + winHeight - 100   ; I think we may be finding blue in the Onedrive tray icon. Need to stop above it
    
	/*
    ; Debugging: Move to the four corners of the active window with splash text
    SplashTextOn, 200, 100, Debug, Top Left
    MouseMove, startX, startY
    Sleep, 1000
    
    SplashTextOn, 200, 100, Debug, Top Right
    MouseMove, endX, startY
    Sleep, 1000
    
    SplashTextOn, 200, 100, Debug, Bottom Right
    MouseMove, endX, endY
    Sleep, 1000
    
    SplashTextOn, 200, 100, Debug, Bottom Left
    MouseMove, startX, endY
    Sleep, 1000
    
    SplashTextOff
	*/
    
    ; Find the lower bounds of the blue area within the defined region
    PixelSearch, lowerX, lowerY, endX, endY, startX, startY, 0x0078D7, 0, Fast RGB
    if (ErrorLevel) {
        SplashTextOn, 200, 100, Debug, Failed to find the lower bounds of the blue area.
        Sleep, 2000
        SplashTextOff
        return
    }
    
    ; Find the upper bounds of the blue area within the defined region
    PixelSearch, upperX, upperY, endX, startY, startX, endY, 0x0078D7, 0, Fast RGB
    if (ErrorLevel) {
        SplashTextOn, 200, 100, Debug, Failed to find the upper bounds of the blue area.
        Sleep, 2000
        SplashTextOff
        return
    }
    
	
	/*
    ; Debugging: Move to the four corners of the blue area with splash text
    SplashTextOn, 200, 100, Debug, Blue Top Left
    MouseMove, upperX, upperY
    Sleep, 1000
    
    SplashTextOn, 200, 100, Debug, Blue Top Right
    MouseMove, lowerX, upperY
    Sleep, 1000
    
    SplashTextOn, 200, 100, Debug, Blue Bottom Right
    MouseMove, lowerX, lowerY
    Sleep, 1000
    
    SplashTextOn, 200, 100, Debug, Blue Bottom Left
    MouseMove, upperX, lowerY
    Sleep, 1000
    SplashTextOff
	*/
    
    ; Save the current mouse position
    MouseGetPos, xStart, yStart
    
    ; Calculate the adjusted coordinates for the drag operation
    dragStartX := lowerX - 80
    dragEndX := upperX - 80
    
    ; Drag to select the blue area
    MouseClickDrag, left, dragStartX, lowerY, dragEndX, upperY
    Sleep, 50
    
    ; Move mouse back to the original position
    MouseMove, xStart, yStart
    
return

;############################################################################################
;####################NOTE FLAG CLICK DEPENDS ON VARIABLES BEING SET AHEAD###############################
;############################################################################################


FlagClick:
; be aware that variables can be changed by hereIam = order	section
UnreleasedOrder := 0
CoordMode, Mouse, Screen
CoordMode, Pixel, Screen
   

if (debugging = true)
	{
		SplashTextOn ,150 ,100, CPRS Booster, In flag click subroutine
		sleep 800
		SplashTextOff

	} 

avgB := 0

; Step 1: Calculate the click coordinates (flag location gets the top) just above and to the right of the upper RIGHT corner of the drag area
;*******************New Code to fix LST banner clicking: incremental look for non-red

; Start searching just below the found red pixel
SearchStartX := PxFlag
SearchStartY := PyFlag + 5 ; Start a little below the detected red pixel

Loop
{
    ; Check the pixel color at the current coordinates
    PixelGetColor, Color, SearchStartX, SearchStartY, RGB

    ; If the color is not red, stop the loop
    if (Color != 0xFF0000)
    {
        UpperEdgeY := SearchStartY ; Store the Y position of the first non-red pixel
        break
    }

    ; Move upward one pixel
    SearchStartY -= 1

    ; Break the loop if we reach the top of the screen
    if (SearchStartY < 0)
    {
        ; MsgBox, Reached the top of the screen without finding a non-red area!
        ; ? what to do here .. shouldn't occur
        break
    }
}

; Adjust Y position IUP after finding the edge; 
; NOTE: for UNFLAGGED you DON'T want to click ABOVE: if there is another non-flagged order, it will mess it up.

if (comingfromunflag = true)
{
		If (debugging)
		{
			SplashTextOn ,150 ,100, CPRS Booster, In Flag Click subroutine called by UNFLAG
			sleep 4000
			SplashTextOff
		}
SafeClickY := UpperEdgeY + 5 ; Adust down to make sure we are INSIDE of the flagged order not a nonflagged order above
}
Else
{
	If (debugging)
		{
			SplashTextOn ,150 ,100, CPRS Booster, In Flag Click subroutine NOT called by
			sleep 4000
			SplashTextOff
		}
SafeClickY := UpperEdgeY - 12 ; Adjust UP slightly to ensure a safe position within the non-red area
}
; Define the click position
ClickX := SearchStartX + 100 ; Adjust X offset as needed
ClickY := SafeClickY ; Use the dynamically calculated safe Y position; THIS DOES NOT work for unflagging. DON'T want to CLICK ABOVE FLAG

if (debugging = true)
{
    SplashTextOn ,150 ,100, CPRS Booster, I'm about to click here
    sleep 800
    SplashTextOff
    ShowDebugArea(ClickX, ClickY, 5000,5000)
}  

; Perform the click
sleep 50  ; if there is no sleep, seems like the mouse doesn't move to area above the order correctly
MouseMove, %ClickX%, %ClickY%
MouseClick, left, %ClickX%, %ClickY%
sleep 100
; MouseClick, left, %ClickX%, %ClickY% ; IT SEEMS WE NEED TWO CLICKS ABOVE THE ORDER BAR (??)
;*****************************
; Here is where we need to look for the code status inadvertenly open

IfWinExist, Resuscitation Status
{
    gosub, gui63
}

;********************end new code

; MouseClick, left, %ClickX%, %ClickY% ; IT SEEMS WE NEED TWO CLICKS ABOVE THE ORDER BAR (??)
; removed above 5-28-25: causing flagged orders to be double clicked when unflagging:open the order

	
;****THE DELAY BELOW GIVES TIME FOR THE BLUE TO GO AWAY AFTER CLICKING ON FLAGGED ORDER
;   ******IF IT IS TOO FAST, THE BLUE from the SELECTION background is there on EXPIRED ORDERER
; and booster MISTAKES an expired order for an Unreleased order (sees blue)
Sleep, 100 ; I think if this is too fast (short) the logic below picks up the blue color from the 
	    ; rx being highlighted rather than the blue of the rx text; ***think this may be two click prob instead above

; Step 2: Search the drag area for color 0505FE
BluePxStart := PxFlag + 20 ; this is the X of the top right of flag
BluePxEnd := BluePxStart + 200   ; Right edge of flag + 200
	
If (debugging = true)
{
    ; Show search area debug GUI
    SplashTextOn ,150 ,100, CPRS Booster, Blue search area here
    sleep 800
    SplashTextOff
    ShowDebugArea(BluePxStart, PyFlag, BluePxEnd, Py2Flag)  
}
CalculateAverageBlue(BluePxStart, PyFlag, BluePxEnd, Py2Flag)

;PixelSearch, ColorX, ColorY, %PxFlag%, %PyFlag%, %BluePxEnd%, %Py2Flag%, %bluecolor%, 20, RGB Fast
; ColorFound := ErrorLevel  ; Store the result of the color search

; Get the initial mouse position
MouseGetPos, xStart, yStart ; this is where the user has the mouse before we tinker with it. 

; Perform the drag action
if (PyFlag != Py2Flag)
{
    ; MsgBox, 262144, CPRS Booster, %PxFlag%, %PyFlag%, %Px2Flag%, %Py2Flag%

    MouseClickDrag, left, %PxFlag%, %PyFlag%, %Px2Flag%, %Py2Flag%
    Sleep, 20
}
else
{
    ; MsgBox, 262144, CPRS Booster, Didn't find flagged order PyFlag=Py2Flag
}

; Move the mouse back to the initial position
MouseMove, %xStart%, %yStart%  ; move mouse back to where they had it after selection above.

if (avgB > 200)
{
    UnreleasedOrder := 1
    If (debugging = true)
    {
        MsgBox, 262144, CPRS Booster, unreleased order
    }
}
else
{
    If (debugging = true)
    {
        MsgBox, 262144, CPRS Booster, flagged order NOT unreleased
    }
}

IfWinExist, Resuscitation Status
{
    gosub, gui63
}
return

;************************END FLAG Click
	
;****THE DELAY BELOW GIVES TIME FOR THE BLUE TO GO AWAY AFTER CLICKING ON FLAGGED ORDER
;   ******IF IT IS TOO FAST, THE BLUE from the SELECTION background is there on EXPIRED ORDERER
; 	**** and booster MISTAKES an expired order for an Unreleased order (sees blue)

	Sleep, 100 ; I think if this is too fast (short) the logic below picks up the blue color from the 
	        ; rx being highlighted rather than the blue of the rx text; ***think this may be two click prob instead above

    ; Step 2: Search the drag area for color 0505FE
	BluePxStart := PxFlag + 20 ; this is the X of the top right of flag
	BluePxEnd := BluePxStart + 200   ; Right edge of flag + 200
	
	If (debugging = true)
	{
	 ;Show search area debug GUI
	 SplashTextOn ,150 ,100, CPRS Booster, Blue search area here
	 sleep 800
	 SplashTextOff
	 ShowDebugArea(BluePxStart, PyFlag, BluePxEnd, Py2Flag)  
	}
	CalculateAverageBlue(BluePxStart, PyFlag, BluePxEnd, Py2Flag)
	
	
    ;PixelSearch, ColorX, ColorY, %Px%, %Py%, %BluePxEnd%, %Py2%, %bluecolor%, 20, RGB Fast
    ; ColorFound := ErrorLevel  ; Store the result of the color search

	

    ; Get the initial mouse position
    MouseGetPos, xStart, yStart ; this is where user has mouse before we tinker with it. 

    ; Perform the drag action
	if (PyFlag != Py2Flag)
	{
	; MsgBox, 262144, CPRS Booster, %Px%, %Py%, %Px2%, %Py2%

    MouseClickDrag, left, %PxFlag%, %PyFlag%, %Px2Flag%, %Py2Flag%
    Sleep, 20
	}
	else
	{
	; MsgBox, 262144, CPRS Booster, Didn't find flagged order Py=py2
	
	}

    ; Move the mouse back to the initial position
    MouseMove, %xStart%, %yStart%  ; move mouse back to where they had it after selection above.

   if (avgB > 200)
    {
        UnreleasedOrder := 1
		If (debugging = true)
		{
		 MsgBox, 262144, CPRS Booster, unreleased order
		}
	}
    else
    {
		If (debugging = true)
			{
			 MsgBox, 262144, CPRS Booster, flagged order NOT unreleased
			}
    }
   

return

;************************END FLAG Click
*/
;############################################################################################
;###################Colorsearch averaging function for blue###########################################
;############################################################################################

CalculateAverageBlue(x1, y1, x2, y2)
{
    totalB := 0
    pixelCount := 0
    maxSamples := 3
    backgroundColor := 0xFFFBF0  ; Background color to ignore
    maxAttempts := 100  ; Limit the number of total sampling attempts to prevent infinite loops

    attempts := 0

    ; Loop to collect 30 valid (non-background) pixels
    while (pixelCount < maxSamples && attempts < maxAttempts)
    {
        ; Randomly select a pixel within the bounds
        Random, randomX, x1, x2
        Random, randomY, y1, y2
        
        PixelGetColor, pixelColor, randomX, randomY, RGB
        
        ; If the pixel color is the same as the background, skip it
        if (pixelColor = backgroundColor)
        {
            attempts++
            continue
        }

        ; Extract the blue component only
        blue := pixelColor & 0xFF
        
        ; Add to the total blue component
        totalB += blue
        pixelCount++
        attempts++
    }

    ; If no valid pixels were found, return
    if (pixelCount = 0)
    {
       ; MsgBox, No valid pixels (excluding background) found!
        Return
    }

    ; Calculate the average blue component
    global avgB := totalB / pixelCount

    ; Show the averaged blue component
   ;  MsgBox, The average blue component is: %avgB%
}



;############################################################################################
;############################################################################################
;############################################################################################


;*******************************start color search and drag debug function


; Function to create GUI for debugging
ShowDebugArea(x1, y1, x2, y2)
{
    ; If x2 or y2 Are set to 5000: treat as single point click
    if (x2 = 5000 || y2 = 5000)
    {
        x2 := x1 + 10  ; Set width for a 10x10 square
        y2 := y1 + 10  ; Set height for a 10x10 square
        Gui, New, +AlwaysOnTop -Caption +ToolWindow
        Gui, Color, black  ; Highlight click point in red
        Gui, Show, x%x1% y%y1% w10 h10
		SplashTextOn ,150 ,100, CPRS Booster, Press SPACEBAR to continue
		sleep 2000
		SplashTextOff
    }
    else
    {
        Width := x2 - x1
        Height := y2 - y1
        Gui, New, +AlwaysOnTop -Caption +ToolWindow
        Gui, Color, black  ; Highlight the area in green
        Gui, Show, x%x1% y%y1% w%Width% h%Height%
		SplashTextOn ,150 ,100, CPRS Booster, Press SPACEBAR to continue
		sleep 2000
		SplashTextOff
    }

    ; Wait for spacebar press to close the GUI
    Loop
    {
        if GetKeyState("Space", "P")
        {
            Gui, Destroy
            return
        }
        Sleep, 50
    }
}



;*****************8end debug function






;############################################################################################
;###################Edit progress note funtion###########################################################
;############################################################################################
^e::

gosub ActivateCPRS
MouseGetPos, xStart, yStart
MouseMove, 800, 500 , 0
mouseclick, right
sleep 50
send {up 9}
sleep 50
send {enter}

sleep  50
MouseMove, xstart, ystart , 0
SplashTextOn ,150 ,100, CPRS Booster, Ready!
sleep 500
SplashTextOff
return


;############################################################################################
;###################Find NEXT @@@ funtion###########################################################
;############################################################################################
^!+e::
MouseMove, 800, 500 , 0  ; if we come from the toolbar button, we need to click on note
mouseclick
sleep 20
mouseclick
; gosub ActivateCPRS
sleep 10

 
; Retrieve the position of the control

	ControlGetPos, cX, cY, cW, cH, TRichEdit4, VistA CPRS in use



; Adjust the coordinates to move the mouse to the control
Cx := Cx+5
Cy := Cy+5
;MsgBox, 262144, CPRS Booster, %cx%, %cy%
;Return
; Move the mouse to the top-left corner of the control
MouseMove, %cX%, %cY%, 0
send {left}
; click
;Return ; MUST REMOVE
mouseclick, right
sleep 50
send {down 5}
sleep 50
send {enter}
sleep 50
send @@@
sleep 20
send {tab 3}
send  {enter}
sleep 50



if winexist("No more matches")
	{
		WinActivate, No more matches
		sleep 50	
		send {enter}	
		sleep 50
		WinActivate, Find
		sleep 50
		send {tab 4}
		sleep 50
		send {enter}
		sleep 50
		gosub activateCPRS
		sleep 50
		send {tab 2}
		sleep 40
		SplashTextOn ,150 ,100, CPRS Booster, NO MORE MATCHES
		sleep 1000
		SplashTextOff
		return

	}

WinActivate, Find
sleep 50
send {tab}
sleep 50
send {enter}
sleep 50
gosub activateCPRS
sleep 50
send {tab 2}
sleep 40


return






;############################################################################################
;################### Spell check funtion###########################################################
;################## ##########################################################################
!s::

gosub ActivateCPRS
MouseGetPos, xStart, yStart
MouseMove, 800, 500 , 0
mouseclick, right
sleep 50
send {down 8}
sleep 50
send {enter}

sleep  50
MouseMove, xstart, ystart , 0
return




;############################################################################################
;##########################Add Misc add signer######################################################
;############################################################################################

^+m::
gosub ActivateCPRS
sleep 40

 Send  !a
 send I
 sleep 500
return



currentlocation:  ;-------------************ current location subroutine
controlname :=focused_control
; ClassNN of the new visits tab: TORComboEdit1

sleep 250
ControlClick,TORComboEdit1,Location for Current Activities
sleep 250

	if (innoteloop = 1) && (strlen(getlocation) > 3)   ; quick prog notes will send f2f location if no specified location.
	{
	
	loctosend := getlocation
	innoteloop := 0  ; reset
	}
	else
	{
	loctosend := f2fclinic
	}
	
send %loctosend%
sleep 30
send {enter}
sleep 500

If Winexist("Incomplete Encounter Information")
{

MsgBox, 262144, CPRS Booster, Booster tried to use `'%loctosend%`' as `n your location. CPRS doesn't recognize it. `n Use Booster Ctrl-H screen to edit location name.
quitloop = yes

return

}



WinWaitNotActive, Location for Current Activities,,3
sleep 1800 ; was 2k but cut down for log time

	; ************** create log entry 
	Rulenum = 10
	RuleString:= f2fclinic
	Gosub logit
	; **************end of log entry
return ; --------------------*******************end of current location subroutine


youdoit:

		SplashTextOn ,150 ,100, CPRS Booster, You do this screen...
		sleep 500
		SplashTextOff

return


jumpfxn(x) {  ;--------------START JUMP FUNCTION
 sleep 50 ; 3-20-23 clicking function buttons on bottom bar sometimes note sign blue
; -----------WE do NOT need (maybe we do) to active CPRS within here b/c it's within the individual commands (add or sign only) that need it.
;fxnum := 1

if (qodebug)
{
return  ; don't run any fxn keys when in qo debug mode
}
gosub ActivateCPRS 

; Winactivate, VistA C ; try this on again 3-2-23 (fxn buttons not signing) ; yeah but sometimes CPRS has a subwindow and this takes focus off.

fxnum := x
Length := StrLen(fxn.1)

;msgbox, % fxn.1
;msgbox, % Length


If WinExist("Copy Medication Orders")|| WinExist("Copy Orders")   ; can't change pts with this open

		{
		SplashTextOn ,150 ,100, CPRS Booster, The Copy Med Orders Window is Still Open
		sleep 3000
		SplashTextOff

		return ; terminate key action
		}


 if (fxn[fxnum] = "Sign" )
 	{
	gosub, ^!s
	}
  else if (fxn[fxnum]= "Add RN1")
	{
	
	gosub, ^+n
	}
  else if (fxn[fxnum]= "Add RN2")
	{
	
	gosub ^!n
	}
  else if (fxn[fxnum]= "Add MSA")
	{
	
	gosub ^!m
	}
  else if (fxn[fxnum]= "Add BOTH")
	{
	
	gosub ^b
	}
  else if (fxn[fxnum]= "Add PHARM")
	{
	
	gosub ^f
	}
   else if (fxn[fxnum]= "Edit Note")
	{
	gosub ^e
	}
	else if (fxn[fxnum]= "Find @@@")
		{
		gosub ^!+e
		}
	else if (fxn[fxnum]= "Quick")
		{
		gosub Gui56
		}
	else if (fxn[fxnum]= "Spell Check")
	{
	gosub !s
	}
    else if (fxn[fxnum]= "Add Misc")
	{
	gosub ^+m 
	}
  else if (fxn[fxnum]= "Unflag")
	{
	
	gosub ^u
	}
   else if (fxn[fxnum]= "Flag")
	{
	gosub ActivateCPRS ; Floating bar drawing may take focus off
	send !a
	sleep 30
	send f
	sleep 40
	send {tab}
	}
  else if (fxn[fxnum]= "Next Patient")
	{
	
	gosub !+n
	}
  else if (fxn[fxnum]= "Make Addendum")
	{
	gosub ^!a
	
	}
  else if (fxn[fxnum]= "Add PROV1")
	{
	gosub ^!p
	}
  else if (fxn[fxnum]= "Add PROV2")
	{
	gosub !p
	}
  else if (fxn[fxnum]= "Phone Clinic")
	{
	gosub +^p
	}

  else if (fxn[fxnum]= "F2F Clinic")
	{
	gosub +^f
	}
  else if (fxn[fxnum]= "VVC Clinic")
	{
	gosub +^v
	}
  else if (fxn[fxnum]= "Add Person1")
	{
	gosub ^1
	}
  else if (fxn[fxnum]= "Add Person2")
	{
	gosub ^2
	}
  else if (fxn[fxnum]= "Add Person3")
	{
	gosub ^3
	}
  else if (fxn[fxnum]= "Add Person4")
	{
	gosub ^4
	}
  else if (fxn[fxnum]= "Add Person5")
	{
	gosub ^5
	}
  else if (fxn[fxnum]= "Add Person6")
	{
	gosub ^6
	}
  else if (fxn[fxnum]= "Add/Flag PCP")
	{
	gosub FlagOrSignPCP
	}
	Else
	Return
	; msgbox, Error

}  ; ------------------*****************END JUMP FUNCTION


;-----------------find the assigned function key

HasVal(haystack, needle) {
	if !(IsObject(haystack)) || (haystack.Length() = 0)
		return 0
	for index, value in haystack
		if (value = needle)

		return "F"index
			;return index
	

	;return 0
	return "Click here to assign"    ;------------this happens when no fxn assigned
}


; arr := ["a", "b", "", "d"]




openfxnscreen: ; ---Go to FxnSetup screen

if  (gui9on=1)
{
gui9on :=0
Gui, 9: Submit ; Save all the information in the GUI (The variables)
}

Gui, Destroy ;--- if getting there from main help screen

Gosub, !H

return

;###########################################################################################
;##############WHAT SCREEN AM I LOOPING LOGIC START #############################################
;############################################################################################

whatscreenamI:  ;-----------------------*****************Find screen user is looking at during signing


wesawreneworcopy = 0 ; reset this
; lastknownPatient :=  "" ; we only want to track this in the context of whatscreenamI looping ... to break loop prn ; beta remove 7-8-24

startingLoopPatient :=  ""
newOrOld := ""
; BETA: remove line below; seems to be causing processing delay then people start clicking stuff an
gosub getpatientinfo ; need to figure out coming up if/when we're on new pt. 
startingLoopPatient := reformattedSSN 


doingencounter = no ;----- this will keep the 'you do this sc' message from repeatdly coming up

if flagged = yes  ;**********the timeout period cannot be long for flagged b/c sequence ends w/o known screen
	{
	ht := 2 ; 8-5-21: increase b/d missing (from 2 s to 3 s); 7-12-21 TRY shortening from 6 sec
	flagged2 = yes ; unsure why we need this new variable but flagged is getting reset somewhere
	}
else
	{
	ht := 4 ;  reduced 7-20-22 from 12 to 8
	flagged2 = no
	}

	lpnum := 6 ; changed from 8 to 4: if we wait for screens to close we shouldn't need a lot of looping (but we may need a loop per screen: but we 
	                   ; may be able to wait out some other screens while awaiting closure of the sign screens (ie wait out encounter/order check etc
					   ; ht = hangtime between screens could be long thou ? on load order sig screen.
	
	
whatscreenamIshortcut:
quitloop = no ; reset this to off ; need below shortcut 



loop, %lpnum%

{    ;----------------START Loop of screen processing whatscreenamI 

cantbedone:

if quitloop = yes
{
break ; the missing encounter overflow will trigger this; ALSO if users backs out of rx signing at order check end up here
}


SetTitleMatchMode, RegEx

; 3-30-25 changed 'order checking' to 'order check' to hopefully catch both	(?? need explicitly list both)
WinWait, ActivClient Login|Electronic Signature|Progress Note Properties|Patient Selection|Primary Encounter Provider|Currently Processing Notifications|Insufficient Authorization|Encounter Form|Lookup Diagnosis|Renew Orders|Sign Note|Sign Summary|Cosign Note|Sign Orders|Location for Current Activities|Missing Encounter Information|Unable to Renew Order|New Order|Copy Orders|Order Check|Review / Sign Changes , , %ht% ; *** so awesome that this contains an OR statement

WinGetTitle, WinTitle ; Only needed to display the name. 

SetTitleMatchMode, 1



IfWinExist, Progress Note Properties ; pick note type
{
 innotetitleget := 1 ; relay success that we got to this screen

; maybe wait just a tad since perhaps this win is active but not ready to scroll through progress notes (?)
sleep 120
  return ; had to have come from pn: to get here: deviated to do encounter; now go back
}


IfWinExist, Patient Selection
{
; sometimes we seem to (after ctrl ignore) have BOTH the patient selection screen and the current process
; screens open at once. 
InNextPtStep := 0 ; we finised the go to next pt process for those who multiselected multiple view alerts at once. Reset to 0
break ; exit processing it pt selection screen there 
; return
}


IfWinExist, Primary Encounter Provider
{
gosub primeencounter
; return
}

else IfWinExist, Renew Orders
	{
	sleep 200
	send {enter}

	wesawreneworcopy = 1 ; (not yet using) this will effect loop delay time (dead end processing at end here) since we have to see this for red orders prior to going on
	sleep 1500 ; we need delay here rather than in loop to make loop faster.
	}

else IfWinExist, Currently Processing Notifications
	{
	gosub curprocess
	InNextPtStep := 0 ; we finised the go to next pt process for those who multiselected multiple view alerts at once.
	; can we break here or might there be other screens AFTER this?
	break ;  I think we have to break here o/w we are looping to wait and can't send new commands 
	}


else IfWinExist, Sign Orders
{
gosub signnote
; Msgbox, 262144, which win, Sign orders

; Note: when signing meds, we need to handle the SC connection screen possibility here. Another Sign Orders sc 
  ;    .... will appear
sleep 200



	IfWinExist, Sign Orders ; persistance of same screen due to sc questions
	{
	send {enter}
	gosub youtakeit
	}
	
WinWaitClose, Sign Orders, , 75 ; changed 7-24-22
	
if (InNextPtStep=0) ; it's actually not here we come but line 3327-ish (flagged order) if we got here usual way: stop here; otherwise we got here as part of next pt/multiple view alerts: keep going.
	{
	break
	}
	

   ;   break ;----------------***stop looping after sig code ; Not so sure after curr process; per above only break if NOT in next pt loop
return
}

else IfWinExist, Sign Note
{
gosub signnote

if (InNextPtStep=0) ; if we got here usual way: stop here; otherwise we got here as part of next pt/multiple view alerts: keep going.
	{
	break
	}
	
return
}

else IfWinExist, Electronic Signature
{ 
winactivate, Electronic Signature ; make sure code not put in somewhere else; 
sendraw, %SigCode%
send {enter}
wesignedit := 1  ; this let's the unreleased and flagged order signing loop know if it was actually signed.
break

return
}



else IfWinExist, Insufficient Authorization
{ ; ----------------Someone trying to sign something that is already signed.

return
}

else IfWinExist, Sign Summary
{
gosub signnote
if (InNextPtStep=0) ; if we got here usual way: stop here; otherwise we got here as part of next pt/multiple view alerts: keep going.
	{
	break ;----------------***stop looping after sig code
	}
	
	
return
}


else IfWinExist, Cosign Note
{
gosub signnote

if (InNextPtStep=0) ; if we got here usual way: stop here; otherwise we got here as part of next pt/multiple view alerts: keep going.
	{
	break ;---------------***stop looping after sig code
	}
	
return
}

else IfWinExist, Location for Current Activities
{
gosub currentlocation
; return
}


else IfWinExist, Lookup Diagnosis ; this has to come before Encounter form else if b/c both are extant
{
gosub lookupdx

; SplashTextOn ,175 ,100, CPRS Booster, Done with lookup?
; sleep 700
; SplashTextOff

; return
}

else IfWinExist, Encounter Form
{
gosub Encounter

 ; SplashTextOn ,175 ,100, CPRS Booster, Done with encounter?
 ; sleep 700
 ; SplashTextOff
; return
}


else IfWinExist, Missing Encounter Information
{
gosub MissingEncounter
; return
}


else IfWinExist, Unable to Renew Order
{
gosub Unable
; return
}

else IfWinExist, ActivClient Login ; this is the PIV screen (at least in the non VPN/Azure version)
{
WinWaitNotActive, ActivClient Login, , 20 ; wait till PIV screen gone.
}


else IfWinExist, New Order
{
gosub NewOrder

; return
}


else IfWinExist, Copy Orders
{
copyon = yes ; not sure what this does: prob intended same as variable below

wesawreneworcopy = 1
gosub Copyorder
; return
}


else IfWinExist, Order Check  ; this should capture both order checking and order checks
{
gosub Ordercheck

;*************seems like we need to wait here to allow continue processing current notification box time to show up??
; *******unsure

 ; return
}


else IfWinExist, Review / Sign Changes
{

		 if (ignoreON=1)   ; what if we're ignoring multiple orders in sequence (cur process)
		 {
		 ignoreOn := 0
		 
		 send {enter}  ; click option to skip signing order
		 
		 }

		if (InNextPtStep=1) ; if we got here via file next ***NO we have a problem: we may see the REview/sign screen again after we signed it with f1 after order check
			{
			stepneeded:= 1 ; we're going to need to use this to remind ourselves that even though we're ending the 
							; whatscreenamI loop the first time through that when user hits F1, we're still needing to finish the next pt loop
			; wait we're gonna hit this screen twice: once to end the next pt loop AND again with F1 to sign it.
			InNextPtStep:= 0 ; THIS is the other end point for a next pt loop (besides Cur process and pt selection). We stop here and F1 brings back.
							; we need this reset to zero so we don't break again when F1 is hit again on this screen (we DO want to auto sign then)
			break ; IF we break here how we process order checks and PIV?
			return ; unsure if this line or above does it
			
			; Wait: shouldn't we always stop here whether or not we came from flagged? But you could hit F1 right on this screen denovo.
			; : what to do here. First time through we want to stop here & make them hit sign again;---------------***stop looping after sig code
			; since we didn't reset innextstep variable, it shold still hold through next trip of f1 BUT will this screen still exist? D
			;  DO other screens exist at the SAME time as Review / Sign: cause that's a mess 
			}
			else
			{
			gosub ReviewSign
			}
			
			
;*************seems like we need to wait here to allow continue processing current notification box time to show up??
; *******unsure

	; ------*******Stop looping after sig code sent.
   ; return    We comment this out to because we're not done here in some cases 
}





else ; -----Some unrecognizable window is active; break the loop ; OR we are between windows = processing time

{


  ;Msgbox, 262144, Unrecognized, Window  `n%WinTitle% 

 ; SplashTextOn ,175 ,100, CPRS Booster, Don't recognize this window
 ; sleep 700
 ; SplashTextOff

; flagged2 = yes
 if flagged2 != yes
	{
	; msgbox flag is no ; 
	              
	 ; SplashTextOn ,175 ,100, CPRS Booster, Don't recognize this window
	 ; sleep 700
	 ; SplashTextOff

	;; break : I don't think we want to break here: if there is a delay going to next patient, we miss the looping.
	
	; 7-11-24: add a check for change in patient during looping here; for unknown location
	
	gosub newPtStatus ; let's see if pt changed b/t this loop and last one: if so, I think we always break (booster never crosses pts)

			if (newOrOld = "New") ; this variable is updated by above subroutine 
			{
			; SplashTextOn ,150 ,100, CPRS Booster, We will break for NEW PT
			; sleep 3000
			 ; SplashTextOff

			break

			}
	
	; end 7-11-24 change
	
	
	}
	else    ; This is the pause while waiting for the screen saying wait for red orders
	{

	; SplashTextOn ,175 ,100, CPRS Booster, Don't recognize this window AND FLAGGED <> NO
 	; sleep 700
 	; SplashTextOff 

	gosub flaglocation ; let's see if there are flags showing during the flag processing period after we renewed.
		if flagged = yes ; once we see flags (red) jump back: otherwise loop: but we shorten the loop cycle time.
		{
	
		; we have a problem here: red orders stick around through the long period BEFORE the Renew or COPY screens occur.

		 if wesawreneworcopy = 1
			{
			; SplashTextOn ,175 ,100, CPRS Booster, I see red; 
 	 		; sleep 700
 	 		; SplashTextOff

			wesawreneworcopy = 0 ; reset
			return ; if we got here via flagged order processing: jump back there to finish
			} ; if not this will continue to loop
		}
		else 
		{		
	; shouldn't need this b/c looping would continue w/o else
	 ; SplashTextOn ,175 ,100, CPRS Booster, We are holding AND NO RED ; 
 	 ; sleep 700
 	;  SplashTextOff
		}

	}
	


}

/* ;Moved above: this should not be outside of all the else statements b/c we need to only check this if 
; in an unknown screen... not AFTEr processing a known screen.

			gosub newPtStatus ; let's see if pt changed b/t this loop and last one: if so, I think we always break (booster never crosses pts)

			if (newOrOld = "New") ; this variable is updated by above subroutine 
			{
			; SplashTextOn ,150 ,100, CPRS Booster, We will break for NEW PT
			; sleep 3000
			 ; SplashTextOff

			break

			}
*/

	}  ;---------------------END of screen processing loop

return   ;-------------------********************************END FIND SCREEN I'm ON



;############################################################################################
;####                        END WHAT SCREEN AM I  #############################################
;############################################################################################


;############################################################################################
;#############################Hotkeys  for progress notes ###################################
;############################################################################################


!1:: ; add progress note 1

innoteloop := 1 ; tell currentlocation to use getlocation
gettitle := notetitle1
getlocation := converttoStandardloc(locNote1) ; converts something like "F2F" back to full name
gettemp := tempnote1
gosub pn

return

!2:: ; add progress note 2

innoteloop := 1 
gettitle := notetitle2
getlocation := converttoStandardloc(locNote2)
gettemp := tempnote2
gosub pn
return


!3:: ; add progress note 3
innoteloop := 1 
gettitle := notetitle3
getlocation := converttoStandardloc(locNote3)
gettemp := tempnote3
gosub pn
return

!4:: ; add progress note 4
innoteloop := 1 
gettitle := notetitle4
getlocation := converttoStandardloc(locNote4)
gettemp := tempnote4
gosub pn
return


!5:: ; add progress note 5
innoteloop := 1 
gettitle := notetitle5
getlocation := converttoStandardloc(locNote5)
gettemp := tempnote5
gosub pn
return

!6:: ; add progress note 6

innoteloop := 1 
gettitle := notetitle6
getlocation := converttoStandardloc(locNote6)
gettemp := tempnote6
gosub pn
return

pasteit(thing)
{
oldclip := clipboard
sleep 100
clipboard := thing

sleep 10
loop 
{
		if(clipboard = thing) ; see if this checking step works or not
		{
		break
		}
sleep 10
}


sleep 150
send  ^v
sleep 100
clipboard := oldclip

}

;############################################################################################
;#####################NoteTitle To location look up start###########################################
;####################################This is if coming straight from drop down w/o guaranteed map################################
Findlocation:

loop, 6
{
; notefornow 


}

return
;############################################################################################
;###############################Location lookup END#############################################################
;############################################################################################







pn:
;############################################################################################
;################################Auto-start progress notes###############################
;############################################################################################

gosub ActivateCPRS
sleep 200
send ^n
sleep 70
 send !a   ; this gets to new note when used with send n below. 
 sleep 100
 send n 
 sleep 100
 

 	ht := 1 ; needed for whatscreenamishortcut
	 lpnum := 6 ; whatscreenamishortcut
 innotetitleget := 0 ; if prog note properties sections is seen by whatscreenamI, this will change to 1 = correct. 0 = failed.
 gosub whatscreenamIshortcut ; to handle encounter AND pick note.

 
 If (innotetitleget = 0) ; set to 1 if works in whatscreenamI
 {
 
 instru := "
(
Something is wrong

- Do you already have a note open?
 - Can't open second note then
 
 - (could be something else too)

)"
		
		MsgBox, 262144, CPRS Booster:  Speed Notes, %instru%
		return ; end processing
}
-------------------
ControlGetText, OutputVar , TButton3, Progress Note Properties
if (outputvar = "show all")
{
send +{tab 6}
}



; pasteit(gettitle) ; this is failing
send %gettitle%
sleep 30


send {enter}


if (outputvar = "show all")
{
sleep 100
send y
}

sleep 850 ; down from 1000

dlp := gettemp ; template #

if dlp is number
{

gosub gettemplate

}


return

;############################################################################################
;###################################End choose note type#####################################################
;############################################################################################



;############################################################################################
;#############################################start get template####################################################################

gettemplate:

sleep 1500


		loop, 5   ; find the button for the templates drawer (usually 3 but sometimes 4)
		{
		buttonNum := "TBitBtn" . A_index
		controlGetText, templatetext, %buttonNum%, ahk_class TfrmFrame
		
			if (templatetext = "templates")
			{
			break   ; we have found the templates button
			}
				
		}




ControlGetPos, x1, y1, w, h, %buttonNum%, ahk_class TfrmFrame,, Templates
MouseClick ,, x1, y1,
ControlGetPos, x2, y2, w, h, %buttonNum%, ahk_class TfrmFrame,, Templates

if (y1 < y2) ; templates drawer is closed (moved down)
{
MouseClick ,, x2, y2,   ; click again to reopen
sleep 50
}

sleep 80
send {down 3}
sleep 80
send {pgup 6}
sleep 80
send {right}  ; this will open personal templates if folder closed
sleep 50
send {up 3} ; back to top 

dlp := gettemp   ; template #

if dlp is number
{

		loop, %dlp%
		{
		send {down} ; this is the one that varies
		sleep 50
		}
		send {enter}

}



return

;############################################################################################
;########################get to top of template list#############################################
;############################################################################################

gettotop:
loop, 5 ; just get to top before we send enter (if closed this won't really be the top.
{
send {pgup}  ; change from just 'up'
sleep 20
}

return



;############################################################################################
;##############################Import CPRS favorite Note titles#######################
;############################################################################################

importtitles:

gettitle := "________________________________________________________________________"   ; marks end of their fav notes in Cprs

gosub ActivateCPRS
sleep 200
send ^n ; notes tab
sleep 200
 send !a   ; this gets to new note when used with send n below. 
 sleep 100
 send n 
 sleep 240
 
 ; we don't need a winwait here b/c we're using whatscreenamIshortcut for that.


; ControlClick, TORComboEdit4,Progress Note Properties 

 	ht := 3 ; needed for whatscreenamishortcut
	lpnum := 4 ; whatscreenamishortcut
 innotetitleget := 0 ; if prog note properties sections is seen by whatscreenamI, this will change to 1 = correct. 0 = failed.
 gosub whatscreenamIshortcut ; process location OR Note title screen

 
 If (innotetitleget = 0)
 {
 
 instru := "
(
Something is wrong
- Make sure CPRS is Open

- Will not work if you have unsigned notes
  OR addenda for patient your are looking at.
	 Use different patient w/o open notes.

)"
		
		MsgBox, 262144, CPRS Booster: Import Titles, %instru%
	
	
		MsgBox, 4100, CPRS Booster, Should we try the import again?
			IfMsgBox Yes
					Goto importtitles
				else
					return
	
 
 }
 

 
  send {down} ; first row is blank
 sleep 100
 

previousTitle := "" ; Variable to store the previous title
pntitle  := ""

loop, 10
{

	; sleep 60
	; ControlGetText, pntitle, TORComboEdit4, Progress Note Properties
    ; sleep 100


				maxIterations := 20 ; Maximum number of loop iterations

				loop, %maxIterations%      ; NOTE: THIS IS WAITING FOR A TITLE CHANGE
				{
					ControlGetText, pntitle, TORComboEdit4, Progress Note Properties


					if (pntitle != previousTitle)
					{
					previousTitle := pntitle  ; reset this
						; Title has changed, exit the inner loop

						break
					}
					; Title has not changed, continue looping
					sleep 100
				}

				 ; Continue executing the rest of the script after the inner wait loop


	If (pntitle = gettitle) ; if we reached the END of the note titles (top 10)
		{
				numCPRSfavs := A_index - 1 ; this stores the loop count (number of favs) at the end of CPRS favs scan; 
			
						loop, 10
						{
								If (A_index > numCPRSfavs) ; meaning we have 10 slots on disk but only 4 favs in CPRS: we need to clean old #5 to 10 on disk
									{
									NoteFavsArray[A_Index] := ""  ; need to wipe these for write below.
									}
						}
						
						gosub savefavtitles
				
				return
		}
	else ; this is actually the majority case
		{
		NoteFavsArray[A_Index] := pntitle

		send {down}
		sleep 64 ; the main delay should occur above in the inner wait loop
		}

}

; we finished loop of 10 and person has more than 10 so save now 

gosub savefavtitles

return


Savefavtitles:
				send {tab 2} ; get to cancel button
				sleep 50
				send {enter}
				gosub writeit
				
				SplashTextOn ,150 ,100, CPRS Booster, Note Titles Imported!
				sleep 1500
				SplashTextOff
				
				
				MsgBox, 4097, CPRS Booster, Now Let`'s Configure Booster to USE/DISPLAY These Titles..
				
				IfMsgBox, Cancel
				{
				return ; skip the mapping step if they cancel
				}
				gosub autonote ; title:location:button mapping
				


return

;############################################################################################
;#####################End Import favorite note titles #################################
;############################################################################################


primeencounter:  ;-----------------**************handle primary provider for encounter screen


sleep 200
send Y
sleep 150
send {enter}
sleep 2000 ; there is a hand off missing to next screen here ; 1-6-21 STILL a prob on phone clinic
return ;------------------**************end of primary provider encounter


Signnote: ;-----------------------************Start sign note

SetTitleMatchMode, 2
winactivate, Sign ; make sure code not put in somewhere else; 
sendraw, %SigCode%
wesignedit := 1  ; this let's the unreleased and flagged order signing loop know if it was actually signed.
send {enter}

;  LOG HERE: fill in sig box
	; ************** create log entry 
	Rulenum = 9
	RuleString:= SigCode
	Gosub logit
	; **************end of log entry
return

Return ;---------------************END SIGN NOTE


ACPRS: ;--------------------*************** Activates CPRS window


Return ; END CPRS activation

MissingEncounter:  ;--------------------************start of missing encounter screen

	 ; SplashTextOn ,175 ,100, CPRS Booster, starting missing encounter
 	 ; sleep 700
 	 ; SplashTextOff



encnter += 1 ; need to keep track of # times on this screen in case user actually trying to cancel.

if encnter > 2 ; if someone gets to missing encounter screen x 3: they want out.

{
gosub youtakeit
quitloop = yes
return ; can't break the screen analysis loop but variable quitloop will send info back to loop to stop it

}

send {enter}  ; ---- this is the difference b/t the MISSING encounter screen and the plain encounter screen


	  SplashTextOn ,175 ,100, CPRS Booster, Complete Encounter
 	  sleep 700
 	  SplashTextOff

sleep 1500

 if doingencounter = no
{
gosub youdoit
}
doingencounter = yes ;---don't show message again during this round of screen processing.

WinWaitActive, Encounter Form, , 10   ;----It need to wait here b/c losing any screen b/t steps.SHOULDN'T need if whatscreenamI delay working

sleep 3000
;Msgbox, 262144, which win, Done

return ;------------------------***********END of Missing encounter info screen


Encounter:  ;--------------------************start of encounter screen

sleep 1000

 if doingencounter != yes
{
gosub youdoit
}

doingencounter = yes ;---don't show message again during this round of screen processing.
; Msgbox, 262144, which win, %doingencounter%

;WinWaitNotActive, Encounter Form, , 40

winwaitclose, Encounter Form, , 70 ; I think this will keep it here even if dx lookup occurs.

; sleep 200 ;---- I'm not sure but I think if they search for dx, there may be a brief period where no win title is active ... so this pauses

return ;------------------------***********END of encounter info screen
 
Lookupdx: ;-----------------------************Start lookupdx

WinWaitNotActive, Lookup, , 40
doingencounter = yes
sleep 200 ;---- I'm not sure but I think if they search for dx, there may be a brief period where no win title is active ... so this pauses

; Msgbox, 262144, lookup , Done


Return ;---------------************END lookupdx




unable:  ;--------------------************start of unable to renew screen

	hitenteragain:
	sleep 100
	send {enter} ; -------send enter to shut down the error box
	sleep 500          ; sleep 1000  try changing 6-7-21


    ; -----------------WHAT IF THERE ARE MULTIPLE ORDERS UNABLE to renew: We need to loop before we process.
	IfWinExist, Unable to Renew Order
	{

	if (debugging) 
	{
		SplashTextOn ,150 ,100, CPRS Booster, In unable to renew subroutine
		sleep 3000
		SplashTextOff
	}
	goto hitenteragain
	; return
	}


	;--------------NOW we need to highlight the orders we're gonna copy to new.


    gosub flaglocation ; I'm not sure we need this but prob should do this immediately before
                        ; flag click to ensure that the correct flag location is clicked on
                        ; and that no intervening information causes yellow banner selection
	Gosub flagclick
   	 sleep 800 ; sleep 1000 ;------ IF this and sleep above are too short, somehow the order is not flagged by the time !an sent
	send !an ; Copies to new order
	; sleep 1000 ;---- IT TAKES A WHILE TO GENERATE A NEW ORDER may need to enlongate

	; SplashTextOn ,175 ,100, CPRS Booster, Waiting for CPRS to finish order copy
 	  sleep 1500
 	;  SplashTextOff

	WinWait, Copy Orders, , 40
	;gosub showflaggedorders ; this will show the flagged orders so that when we unflag it will be correct
	; should we wait for screen 'copy orders' ?? does this always show up?

	 ;msgbox, waiting
	; is it always unable--->'copy orders'---> 'new order'?
	; no b/c you can multiple orders where it's: unable--> unable--> unable. etc

return ;------------------------***********END of unable to renew  screen


NewOrder:  ;--------------------************start of new order screen

    if (debugging) 
    {
        SplashTextOn ,150 ,100, CPRS Booster, In new order subroutine
        sleep 4000
        SplashTextOff
	}

ControlGetText, Cporder, TRichEdit1 ; let's make sure this is a medication order

IsMed:= InStr(Cporder, "Medication:")



if (IsMed = 0) ;************ Not a med: Cancel out of here. User should not have tried to sign a flagged order <> med
	{
	sleep 20
	send {tab 2}
	send {enter}


	instru := "
	(
*** DON'T use Booster to try to sign a FLAGGED order OTHER than a MEDICATION order****

*** For other order types: 
   - If you are signing something flagged to you: unflag first THEN sign
   - If you are writing order and flagging others: sign first THEN flag

    Why? Booster sees red (flag): thinks meds.
	)"

	Msgbox, 262144, Not A Flagged Medication Order, %instru%

	ctr :=0
	anothernew:
	ctr++
	WinWait,New Order, , 3 ; 

		IfWinExist, New Order
		{
		winactivate, New Order
		sleep 50
		send {tab 2}
		send {enter}
		if (ctr<8) ; just a precaution to avoid endless loop
			{
			goto anothernew ; loops back through mulitple copy to new order screen to shut them all
			}
		}

		gosub youtakeit
	exit

    } ;  *********Done with handling person tried to sign a flagged order <> med

else ; ************************this is what it was designed to do: process flagged meds

{
;  msgbox, it's a medicine


send {enter} ; ---- we accept as last written ; do we need to wait for something here? We seem to be dropping out of whatscreen here

;    *************problems here: drop b/t this and the 'be careful screen'

SetTitleMatchMode, RegEx

winwait, New Order|Order Checking , , 2 ; we need to wait for one of multiple possible screens **** THIS IS THE IMPT FIX LINE

; the winwait above will mean the if no additional screen we stuck waiting 2 seconds BUT if one of above: shorter
SetTitleMatchMode, 1

}
return ;------------------------***********END of new order screen

Copyorder:  ;--------------------************start of copy order screen

    if (debugging) 
    {
        SplashTextOn ,150 ,100, CPRS Booster, In copy order subroutine
        sleep 4000
        SplashTextOff
	}
	sleep 200
	send {enter} ;----approve copy
	sleep 400
	send {enter} ;-------------release order now, don't delay
	sleep 300 ; --- we seem to be ending loop between this step and 'new order' screen: this will buy time.
	; doesn't every copy order have a NEW order screen after it? Maybe we should wait for that??
	

SetTitleMatchMode, RegEx

    if (debugging) 
    {
        SplashTextOn ,150 ,100, CPRS Booster, waiting for New Order screen OR Order Checking screen
        sleep 4000
        SplashTextOff
	}
	winwait, New Order|Order Checking , , 10 ; we need to wait for one of multiple possible screens **** THIS IS THE IMPT FIX LINE

	
SetTitleMatchMode, 1


;  SplashTextOn ,175 ,100, CPRS Booster, In Copy order loop ; 
 ; 	  sleep 500
 ; 	  SplashTextOff

return ;------------------------***********END of copy order screen



ordercheck: ;-------------------**************** START order check subroutine

		gosub youdoit


WinWaitNotActive, Order Check, , 20
;------ may have to stop here??
; How do we know if they went forward or backward? Is it that: next screen SHOULD be sign within a few secs if they
;   went forward? If not: they went back??

 	WinWait, Sign,, 2
	 If !WinExist("Sign") ; no sign screen: they went backward: kill loop
	 {

		if (debugging) 
		{	
		SplashTextOn ,150 ,100, CPRS Booster, THEY WENT BACKWARDS
		sleep 600
		SplashTextOff
		}
		quitloop = yes

	 }
	 else
	 	{
		if (debugging)
			{
			SplashTextOn ,150 ,100, CPRS Booster, THEY WENT FORWARD
			sleep 2000
			SplashTextOff
			}
		}	



		; WinWaitActive,VistA CPRS, , 10 ;----wait until they've closed the order check screen
		;--- great: now med is no longer active for alt renew
		
		;MouseMove, %Px%, %Py% ; going to have to click on that part of the screen
		;click
return ; -----------------************end of order check subroutine




Reviewsign: ;-----------------------************Start sign note
; winactivate, WinWaitClose, Review / Sign Changes

winactivate, Review / Sign Changes
sleep 40
ControlClick,TCaptionEdit1,Review / Sign Changes    ; this gets cursor in sign box

sleep 30
sendraw, %SigCode%
send {enter}
wesignedit := 1  ; this let's the unreleased and flagged order signing loop know if it was actually signed.

WinWaitClose, Review / Sign Changes, , 75   ; now , if we got here via fn, we are at second time through and we need to stop here after sig till this screen is gone

if (stepneeded=1) ; we've now manually hit F1 BUT we did so AFTER the curr process loop was ended on Review sign screen AND we need to resume that.
		{
			stepneeded:= 0 ; reset this to zero
			InNextPtStep:= 1 ; reset this to 1 so that we are now looking for the final two screens: pt selection or cur process 
			              ; and we won't stop processing prior.
		}

;  LOG HERE: fill in sig box

	; ************** create log entry 
	Rulenum = 9
	RuleString:= SigCode
	Gosub logit
	; **************end of log entry
Return ;---------------************END Review SIGN 

youtakeit:

		SplashTextOn ,175 ,100, CPRS Booster, You take it from here...
		sleep 700
		SplashTextOff

return

Logit:   ;******************Start LOGGING

 	if (loggingon = "yes") ; ---Varible at top of program can disable logging
	{

StringLen, Rulelen, RuleString
logentry:=  Rulenum . "," . Rulelen . "," . A_UserName . ","   A_MM .  "-" . A_DD . "-" . A_YYYY
FileAppend, %Logentry%`n, %logfilename%

	}

; Loop, read, %logfilename%, W:\INFORMATICS\AHK User Data\GlobalBoosterLog.txt
; {
    
;         FileAppend, %A_LoopReadLine%`n
; }



return  ;*************************end logging




;############################################################################################
;#################GET PATIENT INFO FROM CPRS################################################
;############################################################################################

Getpatientinfo:  

; gosub ActivateCPRS
WinGetText, SSVoogle, A  ; need to get patient info from CPRS
SensitiveInfo := ""  ; Initialize the variable to store sensitive information
PatientName := ""    ; Initialize the variable to store the patient's name
reformattedSSN :=""


; Use RegExMatch to find the first SSN in the SSVoogle variable
if (RegExMatch(SSVoogle, "\b\d{3}-\d{2}-\d{4}\b", firstSSN))
 {
    SensitiveInfoFound := true
    SensitiveInfo .= "SSN Found: " firstSSN "`n"


    reformattedSSN := StrReplace(firstSSN, "-")
	lastFour := SubStr(reformattedSSN, -3)  ; Get the last 4 characters

	; clipboard := reformattedSSN
	; clipboard :=SSVoogle	

    ; Find the position of the second occurrence of the SSN
    secondPos := InStr(SSVoogle, firstSSN, false,0) 
	; FoundPos := InStr(Haystack, Needle , CaseSensitive, StartingPos, Occurrence)
	;  If StartingPos is blank, 0 or negative, the search is conducted in reverse (right-to-left) beginning at that offset from the end.
	
	
	; Split the string into an array of lines
lines := StrSplit(SSVoogle, "`n")

; Get the last line which should be the patient name
NumBannerLines := lines.MaxIndex()
numbannerlines := NumBannerLines - 1
PatientName := lines[NumBannerLines]
	
			; Find the position of the open parenthesis ; get rid of (outpatient) and (inpatient)
			pos := InStr(PatientName, "(") ; Check if the open parenthesis was found 
			if (pos > 0) 
			{ ; Extract the portion of the string before the open parenthesis 
			PatientName := SubStr(patientname, 1, pos - 1) 
			} 		
; NOW: get DOB


			DOBindex := NumBannerLines - 1
			
			; Get the second to last line which should contain the date of birth
			DOBline := lines[DOBindex]
			
			; Extract the date of birth from the line, excluding the last 5 characters
			ptDOB := SubStr(DOBline, -17, 13)
			
			; Trim any extra spaces or characters around the date of birth
			ptDOB := Trim(ptDOB)
			

}
else
{

; MsgBox, 262144, CPRS Booster, Patient info Not Found
}



Return



;############################################################################################
;############################################################################################
;############################################################################################






;############################################################################################
;#################FIGURE OUT IF NEW PT SINCE LAST GOSUB#########################################
;############################################################################################


newPtStatus:   


gosub getpatientinfo ; need to figure out coming up if/when we're on new pt.
currentPatient := reformattedSSN 

; checks to see if during whatscreenamI looping we changed patients
if (startingLoopPatient != currentPatient) && (startingLoopPatient != "") && (currentPatient != "") 
{
newOrOld := "NEW"

; MsgBox, 262144, CPRS Booster, Starting: %startingLoopPatient% `n  Current: %currentPatient%  

}

; checks to see if BEFORE whatscreenamI started we were using !+n:: and captured patient prior to new screen where pt name cannot be captured.
if (Oldpatient != currentPatient) && (Oldpatient != "") && (currentPatient != "") 
{
newOrOld := "NEW"

; note: oldpatient is only has a value when coming from file new (during a gosub to whatscreenamI:)

}


return

;############################################################################################
;##############            END OF FIGURE OUT IF NEW PT   ############################################
;############################################################################################







^i:: ;---- ignore flag
gosub ActivateCPRS ; Floating bar drawing may take focus off

; let's get baseline patient id before we do anything
gosub getpatientinfo
StartIgnorepatient := reformattedSSN 


; Now send ignore alert command.
send !fv
sleep 50
send {enter}  ; accept ignore.
sleep 50

;beta 10-29-24
If WinExist("Copy Medication Orders")|| WinExist("Copy Orders")  ; can't change pts with this open

	{
	SplashTextOn ,150 ,100, CPRS Booster, The Copy Med Orders Window is Still Open
	sleep 3000
	SplashTextOff

	return ; terminate key action
	}



send !fn
sleep 200

; ignoreON := 1 ; set this variable so when we get to review/sign order screen we can click don't sign
startTime := A_TickCount

loop 
{
		IfWinExist, Currently Processing Notifications
			{
			gosub curprocess
			}
		else IfWinExist, Review / Sign Changes
			{
			winactivate, Review / Sign Changes
			 send {enter}  ; click option to skip signing order
			 sleep 400
			 }
		else IfWinExist, Patient Selection
			{
			break ; this is always the end of ingnore (? does cur process ever come AFTER THIS: assume no)
			}
		else
			{
			gosub getpatientinfo
			if (reformattedSSN != StartIgnorepatient)
				{
				break   ; if patient changed w/o going through patient selection screen: break.
				}
			}
	
	; Check if timeout period (7 seconds) has passed ; no matter what: stop loop at X seconds.
	if (A_TickCount - startTime > 7000)
	{
		; Exit the loop if timeout period has passed
		break
	}	
	
}	
		

/*
gosub !+n ;---- go to next pt to tee up orders

 ; we have a problem here when we selected mulitple orders: we get the do you want to stop processing window


*/
; ignoreOn := 0

		SplashTextOn ,175 ,100, CPRS Booster, Flagged order ignored...
		sleep 700
		SplashTextOff


	; ************** create log entry 
	Rulenum = 20
	RuleString:= ""
	Gosub logit
	; **************end of log entry
return

releaseit:  ;-------------------------START RELEASE KEY LOGIC

; STEPS TO ADD TO THIS SECTION
;  1. ADD release code here.  2. Add Release Variable to writeit and refresh  3. Change the defintion of the key itself  4. Change fxn pointer


If WinExist("Booster Settings") ;---- if they are already on this screen screen
{

winactivate, Booster Settings
 
return
}

if ctrla = 1
  {
 releaseme1 = checked
  }
 else
 {
 releaseme1 =
 }

if altn = 1
  {
 releaseme2 = checked
  }
 else
 {
 releaseme2 =
 }

if CtrlM = 1
  {
 releaseme3 = checked
  }
 else
 {
 releaseme3 =
 }

if CtrlP = 1
  {
 releaseme4 = checked
  }
 else
 {
 releaseme4 =
 }

if CtrlR = 1
  {
 releaseme5 = checked
  }
 else
 {
 releaseme5 =
 }

if Ctrls = 1
  {
 releaseme6 = checked
  }
 else
 {
 releaseme6 =
 }

if Ctrln = 1
  {
 releaseme7 = checked
  }
 else
 {
 releaseme7 =
 }


if HBO = 1 ; hide hyperdrive bar
  {
 releaseme8 = checked
  }
 else
 {
 releaseme8 =
 }

if FBO = 1
  {
 releaseme9 = checked
  }
 else
 {
 releaseme9 =
 }


if AutoDragon = 1
  {
 dragon1 = checked
  }
 else
 {
 dragon1 =
 }


instru := "
(
        Use checkboxes below to have Booster RELEASE these key combos.
        This means: key combo will no longer perform booster function but
        you can still assign associated Booster action to a function key.
)"

Gui, 6: Font, bold underline s13, Verdana  ; Set 13-point Verdana.

Gui, 6: Add, Text,y10, RELEASE KEYS:
Gui, 6: add, text,y10 x700, DRAGON NS:

Gui, 6: Font,norm s11, Verdana  ; Set 11-point Verdana.
Gui, 6: Add, Text, x10 y40  R4, %instru%
Gui, 6: Add, CheckBox, x650 y40 %dragon1% vAutoDragon, Auto-start Dragon with CPRS start?

Gui, 6: Add, CheckBox, x25 y110 %releaseme1% vCtrlA, Release Ctrl-A: Check this and Ctrl-A --> Select all
Gui, 6: Add, CheckBox, %releaseme3% vCtrlM, Release Ctrl-M: Check this and Ctrl-M --> Go to CPRS Meds tab
Gui, 6: Add, CheckBox, %releaseme7% vCtrlN, Release Ctrl-N: Check this and Ctrl-N --> Go to CPRS Notes tab
Gui, 6: Add, CheckBox, %releaseme2% vAltn, Release Alt-N: Check this and Alt-N --> CPRS 'Next' Shortcut
Gui, 6: Add, CheckBox, %releaseme4% vCtrlP, Release Ctrl-P: Check this and Ctrl-P --> Go to CPRS Problem List
Gui, 6: Add, CheckBox, %releaseme5% vCtrlR, Release Ctrl-R: Check this and Ctrl-R --> Go to CPRS Reports tab
Gui, 6: Add, CheckBox, %releaseme6% vCtrlS, Release Ctrl-S: Check this and Ctrl-S --> Go to CPRS Cover Sheet

Gui, 6: Font, bold underline s13, Verdana  ; Set 13-point Verdana.
Gui, 6: Add, Text,, 
Gui, 6: Add, Text,, ADJUST BOOSTER GRAPHICS APPEARING IN CPRS:

Gui, 6: Font,bold s11, Verdana  ; Set 11-point Verdana.
Gui, 6: Add, Text,,   Reposition The Floating Bars (Secure Messaging, etc):
Gui, 6: Font, norm s11, Verdana  ; Set 11-point Verdana.,


instru := "
(
     The horizontal control boxes will shift the bar left (negative #) or right (positive #) 
     by a certain number of pixels. So -5 goes a little left, while 50 goes a lot to the 
     right. Trial and error. Same concept for vertical: negative # down. Positive up.
    
)"

Gui, 6: Add, Text,, %instru% ; This just displays the text 

Gui, 6: Font,bold s11 Verdana  ; Set 11-point Verdana



instru := "
(
     Hyperdrive Bar (Secure Message Button, etc):              Floating Function Reminder Bar: 
)"

Gui, 6: Add, Text,, %instru% ; This just displays the text 

Gui, 6: Font,norm s11, Verdana  ; Set 11-point Verdana

instru := "
(
        Move Left (neg)/Right By How Much?                               Move Left (neg)/Right By How Much?
        Move Down (neg)/Up by How Much?                                Move Down (neg)/Up by How Much?
)"

Gui, 6: Add, Text,, %instru% ; This just displays the text 


Gui, 6: Add, Edit,x350 y525 w40 h19 vHBH, %HBH% ;this is is the actual input box, so we must attach a variable to it. IE: vRN 
Gui, 6: Add, Edit,x800 y525 w40 h19 vFBH, %FBH% ;this is is the actual input box, so we must attach a variable to it. IE: vRN 

Gui, 6: Add, Edit,x350 y545 w40 h19 vHBV, %HBV% ; This is the actual input box, so we must attach a variable to it.
Gui, 6: Add, Edit,x800 y545 w40 h19 vFBV, %FBV% ;this is is the actual input box, so we must attach a variable to it. IE: vRN 
Gui, 6: Add, CheckBox, x55 y590 %releaseme8% vHBO, Turn OFF Hyperdrive Bar (try above first)
Gui, 6: Add, CheckBox, x500 y590 %releaseme9% vFBO, Turn OFF Floating Fxn Bar (try above first)

; Gui, 6: Add, CheckBox, %releaseme8% vHBO, Turn OFF Hyperdrive Bar

; HBO2:= HBO ; load different variables to display the incoming value
;  FBO2:= FBO ; 



; Gui, 6: Add, CheckBox, %releaseme9% vFBO, Turn OFF Floating Function Bar (F key reminders)

; Gui, Add, Edit, x165 y+20 w225 h30 vMSA, %MSA1% ; This is the actual input box, so we must attach a variable to it. 
; Gui, Add, Edit, x165 y+20 w225 h30 vPharm1, %Pharm% ; This is the actual input box, so we must attach a variable to it.

Gui, 6: Add, Button,x50, OK ; Button to submit the information


Gui, 6:Show, x100 y10 w1000 h660, Booster Settings
return 

6GuiClose:
6ButtonOK: ; Execute the following actions when the button from the GUI OK is pressed
	Gui, 6: Submit ; Save all the information in the GUI (The variables)
	Gui, 6: Destroy ; Destroy the GUI to get it out of the way

gosub, writeit

; gosub, refreshdata  ;----need to refresh the working variables: Don't need this: variables are global already


return ; ************************------------END RELEASE KEY LOGIC

; msgbox, we are here  ; REMOVE THIS

SM: ; **********************************start of SECURE MESSAGING LOGIC

MousegetPos,SMX,SMY

If (hyperY >SMY) ; this just checks to see if someone really clicked this area
{
return
}

; if MYHEv open already we may need to close.
If Winexist("MyHealtheVet")
{
winclose, MyHealtheVet
}


				SplashTextOn ,300 ,100, CPRS Booster, Booster Activated...
		  		 sleep 500
		  	 	SplashTextOff


SMnewPerson:= InStr(SMUrl, ".myhealth.va.gov")
; msgbox Value %SNnewperson%  ; 0 means we don't have URL saved.


if (SMnewPerson = 0) ; we don't have a URL saved to disk
{


; #Include C:\Users\VHAMINBockA\OneDrive - Department of Veterans Affairs\AHK code\IncludeFiles\GetBrowserURL.AHK


instru := "
	(
Setup: You only have to do this once. It's easy!

Booster needs to find out which secure messaging site you use.

DO THIS NOW:
1. LEAVE THIS SCREEN ALONE (Don't Click OK yet)
2. OPEN Secure messaging via your normal route (ie CPRS Tools)
3. Do **NOT** CLICK the LOGIN button when you reach that page
4. Once you see the page with the LOGIN button, Click OK on THIS
   Booster Messaging Setup Screen. Sit back and I'll finish up.

that's it....

)"

messedctr:= 0
Youmessedup:
MsgBox, 262144, CPRS Booster: Messaging Setup, %instru%

If !WinExist("MyHealtheVet - Secure Messaging")

	{

		messedctr++
		if (messedctr > 2)
		{
		messedctr :=0 ; reset and we'll stop trying this loop
		}
		else
		{
		 SplashTextOn ,300 ,100, CPRS Booster, You didn't open Secure Messaging. Try again and THEN click Ok on Booster..
		  sleep 5000
	  	 SplashTextOff
		goto Youmessedup
		}
	}

winactivate, MyHealtheVet - Secure Messaging


SMUrl := GetActiveBrowserURL() ; this gets the URL


SMnewPerson:= InStr(SMUrl, ".myhealth.va.gov") ; check to see if We got it

	if (SMnewPerson = 0) ; Check again. Did we get it? 0 means we didn't get it
	{
	 Msgbox, 262144, CPRS Booster, Something didn't work `n .....not sure what...

	return
	}
	else ; we got it. Now write to disk
	{
	gosub, writeit

		  	 	SplashTextOn ,300 ,100, CPRS Booster, Got it! Next time I'll do the whole thing for you!
		  		 sleep 4000
		  	 	SplashTextOff
	gosub, refreshdata  ;----need to refresh the working variables
	winactivate, MyHealtheVet - Secure Messaging
	SetTitleMatchMode, 1
	Goto itsOpen

	}
}  ; END of  if (SMnewPerson = 0) ; we don't have a URL saved to disk


SetTitleMatchMode, 1

run, %SMUrl%

		  	 	SplashTextOn ,300 ,100, CPRS Booster, I'm logging into secure messaging. Hang on...
		  		 sleep 2000
		  	 	SplashTextOff

itsOpen:
SetTitleMatchMode, 2

WinWait, MyHealtheVet - Secure Messaging,, 30
smOn := 1
; Msgbox, 262144, done?, Done

clickoncolor(0x2E8540,10) ; CLICK on login button (wait up to 10 sec AFTER page loads for it)

; send {tab 5}
; send {enter}

imedopen:
WinWait, VA Identity and Access,, 7
If WinActive("VA Identity and Access")
{


	coords :=[]
coords := ColorSearch("VA Identity and Access", "0xE3C879", 3000 , "q2", "TR")


variableX := coords.screenX
	variableY := coords.screenY + 120
	mouseclick, left, %variableX%, %variableY%


	; clickoncolor(0x393939,5)

/*
	sleep 200
	global clicktoside := 1	
	clickoncolor(0xE2C675,10)
	
	if (smOn!=1)
	{
	sleep 30
	mouseclick, left   ; we need an EXTRA click for Imed consent... no idea why
	}
	
	smOn := 0
	sleep 300
	send {tab 2}
	sleep 50
	send {enter}
	
	sleep 200
	send {tab}
	sleep 50
	send {enter}
; clickoncolor(0xC5C5C5,10)

*/



/*
	MouseMove, 20, 800
	sleep 100
	mouseclick
	sleep 50
	send {tab 2}
	send {enter}
	
*/	
	
	}
else

	{
	; Msgbox, 262144, done, already logged in
	return
}


/*
 WinWait, VA Identity and Access Management System (IAM) ,, 1
 sleep 300
 send {tab 1}
 send {enter}
sleep 200
*/
; winactivate, MyHealtheVet - Secure Messaging
 
return ;**************************************End of Secure Messaging LOGIC


; -------------------------****************start automatic version update logic



CheckVersion:

FileReadLine, CurrentVersion, %FileVersion%, 1   ;reads line 1 of the file
CurrentVersion = %CurrentVersion%                       ;removes spaces and tabs if any
StringUpper, CurrentVersion, CurrentVersion        ;set CurrentVersion to uppercase for comparision
StringUpper, RunningVersion, A_ScriptName        ;set Running EXE to uppercase for comparision
If RunningVersion not contains %CurrentVersion%
    {

				SplashTextOn ,300 ,100, CPRS Booster, New Version! Updating Now...
		  		 sleep 3000
		  	 	SplashTextOff
  ;   MsgBox, New Version of CPRS Booster found - upgrading   ;MsgBox presents and OK for them to click or press enter

    ; MsgBox, 262145, CPRS Booster, New Version of CPRS Booster found - upgrading
    run, %BoosterRoot%CPRSBooster.exe
	  	 		
				SplashTextOn ,300 ,100, CPRS Booster, I'm reloading Booster/New Version.
		  		 sleep 3000
		  	 	SplashTextOff

	
    ExitApp
     exit
    }
Return



CheckVersionBETA:

FileReadLine, CurrentVersion, %FileVersionBETA%, 1   ;reads line 1 of the file
CurrentVersion = %CurrentVersion%                       ;removes spaces and tabs if any
StringUpper, CurrentVersion, CurrentVersion        ;set CurrentVersion to uppercase for comparision
StringUpper, RunningVersion, A_ScriptName        ;set Running EXE to uppercase for comparision

Return


;--------------------**************** end automatic version update logic

;############################################################################################
;########START EVEN MORE ADDITIONAL SIGNERS ##################################################
;############################################################################################

;-----------------Start GUI & logic for even more additional signers

extraadd:

gosub refreshdata
Gui 14: Destroy ; these are floating fxn bar
gui 7: destroy ;Destroy
gui 8: destroy
Gui, hide ;Destroy


If WinExist("Minneapolis VA Informatics - Even More Signers") ;---- if they are already on set up screen
{

winactivate, Minneapolis VA Informatics - Even More Signers
;MsgBox,0,CPRS Booster: Been there Done that, The help/setup screen is already open somewhere. How much help do you need? :) 
return
}

;-----------display setup/instructions screen

instru := "
(
Instructions: Fill out the fields below. Names of individuals (RN, MSA, etc) need to exactly match the format in CPRS additional signer: last,first (no spaces).

Skip any fields you won't need.
)"

gui9on:=1 ; this forces the jump link to the function screen to submit the data from GUI below (w/o Ok button)


Gui, 9: Font, s11, Verdana  ; Set Verdana.
Gui, 9: Add, Text, X5 Y5 w600 R4, %instru%
Gui, 9: Font
Gui, 9: Font, Underline cBlue s13, Verdana 
; Gui, 9: Add, Text, gAllHelp  w350 h30, How To Use CPRS Booster? CLICK HERE ; This just displays the text
; Gui, 9: Add, Text, gTroubleshooting  x630 y7 w350 h30, TROUBLESHOOTING: CLICK HERE ; This just displays the text


; Gui, 9: Add, Link, x600 y50, <a href="%helpvid%">VIDEO TUTORIAL (13 MIN): CLICK HERE</a>
Gui, 9: Add, Text, gopenfxnscreen x450 y90 w500 h30, Use the Function Keys to GO FASTER: CLICK HERE ; This just displays the text
Gui, 9: Font
Gui, 9: Font, s11, Verdana  ; Set Verdana.


Gui, 9: Font, s13, Verdana  ; Set 13-point Verdana.
Gui, 9: Add, Text, x12 y145 w120 h30, Provider 2 ; This just displays the text 
Gui, 9: Add, Text, x12 y+20 w100 h30, Person 1 ; This just displays the text 
Gui, 9: Add, Text, x12 y+20 w100 h30, Person 2 ; This just displays the text
Gui, 9: Add, Text, x12 y+20 w120 h30, Person 3 ; This just displays the text
Gui, 9: Add, Text, x12 y+20 w140 h30, Person 4 ; This just displays the text
Gui, 9: Add, Text, x12 y+20 w120 h30, Person 5 ; This just displays the text 
Gui, 9: Add, Text, x12 y+20 w120 h30, Person 6 ; This just displays the text
; Gui, 9: Add, Text, x12 y+20 w120 h30, Provider 1 ; This just displays the text 
; Gui, 9: Add, Text, x12 y+20 w120 h30, Provider 2 ; This just displays the text



;----------------display entry boxes (edit boxes)

Gui, 9: Font
Gui, 9: Font, s13, Verdana 
Gui, 9: Add, Edit, x165 y145 w225 h30 vMD2, %Prov2%  ;this is is the actual input box, so we must attach a variable to it. IE: vRN 
Gui, 9: Add, Edit, x165 y+20 w225 h30 vPerson1, %Person1% ; This is the actual input box, so we must attach a variable to it. 
Gui, 9: Add, Edit, x165 y+20 w225 h30 vPerson2, %Person2%  ; This is the actual input box, so we must attach a variable to it. 
Gui, 9: Add, Edit, x165 y+20 w225 h30 vPerson3, %Person3%  ; This is the actual input box, so we must attach a variable to it. 
Gui, 9: Add, Edit, x165 y+20 w225 h30 vPerson4, %Person4% ; This is the actual input box, so we must attach a variable to it. 
Gui, 9: Add, Edit, x165 y+20 w225 h30 vPerson5, %Person5% ; This is the actual input box, so we must attach a variable to it. 
Gui, 9: Add, Edit, x165 y+20 w225 h30 vPerson6, %Person6%  ; This is the actual input box, so we must attach a variable to it. 
; Gui, 9: Add, Edit, x165 y+20 w225 h30 vMD1, %Prov% ; This is the actual input box, so we must attach a variable to it. 
; Gui, 9: Add, Edit, x165 y+20 w225 h30 vMD4, %Pro% ; This is the actual input box, so we must attach a variable to it.

;-------------------text showing key PSEUDOHYPERLINKS
Gui, 9: Font, underline s11, Verdana  ; Set Verdana.
Gui, 9: Add, Text, x425 y125 w300 h30, Shortcuts That Use This: ; This just displays the text 
Gui, 9: Font
Gui, 9: Font,  s13, Verdana 

Gui, 9: Add, Text, x425 y145 w250 h30, Alt-P (ALT-ernate Provider)
Gui, 9: Add, Text, x425 y+20 w250 h30, Ctrl-1  ; Ctrl-1 ; pseudohyperlink
Gui, 9: Add, Text, x425 y+20 w250 h30, Ctrl-2 ; Ctrl-M, Ctrl-B,Ctrl-R ; pseudohyperlink
Gui, 9: Add, Text, x425 y+20 w250 h30, Ctrl-3 ; Ctrl-F (Farmacist:P taken) ; pseudohyperlink
Gui, 9: Add, Text, x425 y+20 w250 h30, Ctrl-4 ; Ctrl-S ; pseudohyperlink
Gui, 9: Add, Text, x425 y+20 w250 h30, Ctrl-5 ; pseudohyperlink
Gui, 9: Add, Text, x425 y+20 w250 h30, Ctrl-6 ; pseudohyperlink

;-----------------------------------------Show function key assignment on main GUI
Gui, 9: Font
Gui, 9: Font, underline s11, Verdana  ; Set Verdana.
Gui, 9: Add, Text, x710 y125 w300 h30, Assigned Function Key(s): ; This just displays the text 
Gui, 9: Font
Gui, 9: Font, Underline cBlue s13, Verdana


; ---- |Add RN1|Add RN2|Add MSA|Add BOTH|Add PHARM|Unflag|Next Patient|Make Addendum|Add PROV1|Add PROV2|Phone Clinic|F2F Clinic|

fctlbl := HasVal(fxn, "Add PROV2")
Gui, 9: Add, Text, gopenfxnscreen x710 y145 w300 h30, %fctlbl% ; pseudohyperlink
fctlbl := HasVal(fxn, "Add Person1")
Gui, 9: Add, Text, gopenfxnscreen x710 y+20 w300 h30, %fctlbl% ; pseudohyperlink
fctlbl := HasVal(fxn, "Add Person2")
Gui, 9: Add, Text, gopenfxnscreen x710 y+20 w300 h30, %fctlbl% ; pseudohyperlink
fctlbl := HasVal(fxn, "Add Person3")
Gui, 9: Add, Text, gopenfxnscreen x710 y+20 w300 h30, %fctlbl% ; pseudohyperlink
fctlbl := HasVal(fxn, "Add Person4")
Gui, 9: Add, Text, gopenfxnscreen x710 y+20 w300 h30, %fctlbl% ; pseudohyperlink
fctlbl := HasVal(fxn, "Add Person5")
Gui, 9: Add, Text, gopenfxnscreen x710 y+20 w300 h30, %fctlbl% ; pseudohyperlink
fctlbl := HasVal(fxn, "Add Person6")
Gui, 9: Add, Text, gopenfxnscreen x710 y+20 w300 h30, %fctlbl% ; pseudohyperlink

; fctlbl := HasVal(fxn, "Add PROV1")
; Gui, 9: Add, Text, gopenfxnscreen x710 y+20 w300 h30, %fctlbl% ; pseudohyperlink
; fctlbl := HasVal(fxn, "Add PROV2")
; Gui, 9: Add, Text, gopenfxnscreen x710 y+20 w300 h30, %fctlbl% ; pseudohyperlink


Gui, 9: Add, Button, x2 y620  w40 h30 , OK ; Button to submit the information


;-------------------------end of help links

Gui, 9: Show, x100 y0 w1000 h650, Minneapolis VA Informatics - Even More Signers ; Display the GUI, 9: x and y tell where to show the window at on the screen and h and w tell what size to make it

return ; this is the return at end of GUI

9GuiClose:
   Gui, 9: Destroy ; Destroy the GUI to get it out of the way
  lastwin:= "notCPRS" ; make the floating help bar pop back up with next left click

return

;----------------Start of OK button processing on Help and Setup screen

9ButtonOK: ; Execute the following actions when the button from the GUI OK is pressed
Gui, 9: Submit ; Save all the information in the GUI (The variables)
Gui, 9: Destroy ; Destroy the GUI to get it out of the way
gosub, writeit
gosub, refreshdata  ;----need to refresh the working variables

Return ; End of add extra add signers




;############################################################################################
;########   END OF EVEN MORE ADDITIONAL SIGNERS          #####################################
;############################################################################################


;############################################################################################
;#######################First time set up oneclick note instructions####################################
;############################################################################################

notesetupinfo:


		 if (strlen(NoteFavsArray[1]) < 4)   ;never set up before START SECTION
		 {
 
			instru := "
(
One Click New Notes: What can they do for you?

OPEN THE NOTE TITLE of your choice...


  ... with the CLICK OF A BUTTON (LOWER BOOSTER TOOLBAR)
  

No matter which CPRS tab you start from...


- Setup in less than 2 min. CLICK OK TO SETUP NOW.


)"


		MsgBox, 262145, CPRS Booster One Click New Notes, %instru%

			
			IfMsgBox, Cancel    ;abort first time setup
			{
			return
			}

		SplashTextOn ,150 ,100, CPRS Booster, Importing Your Favorite Note Titles: Hang on!
		sleep 1600
		SplashTextOff

		gosub importtitles
		
		instru := "
(

- Next you'll pick the note titles to assign to Booster buttons

- You should assign your MOST COMMONLY used note title 
  to the SPEED NOTE 1 slot
  
- You should assign your SECOND MOST COMMONLY used note title 
  to the SPEED NOTE 2 slot. 
  
  NOTE: the Dragon command 'dot letter' will also open SPEED
  NOTE 2... so if you use patient results letters: put that in
  the #2 slot.

)"
		
		MsgBox, 262144, Assign Favorite Notes to Booster Buttons, %instru%
		
		instru := "
(

One last tip: you should assign each note title to a LOCATION

This lets Booster fill out that annoying 'choose location' step for you.

)"
		
		MsgBox, 262144, One Last thing, %instru%		
	

	
		}  ; END of first time setup = import fav notes from CPRS
		
			
		
gosub autonote ; this happens first time or not: anytime we setup something


return



;############################################################################################
;######################################End of first time set up one click Notes########################################
;############################################################################################







;############################################################################################
;###############    START OF AUTO CREATE PROGRESS NOTE  GUI      #############################
;############**********See also importtitles Section***######################################################


autonote:

gosub refreshdata
Gui 14: Destroy ; these are floating bars
gui 7: destroy ; Destroy
gui 8: destroy
Gui, Destroy


If WinExist("Minneapolis VA Informatics - Make New Note In CPRS") ;---- if they are already on set up screen
{

winactivate, Minneapolis VA Informatics - Make New Note In CPRS
;MsgBox,0,CPRS Booster: Been there Done that, The help/setup screen is already open somewhere. How much help do you need? :) 
return
}

;-----------display setup/instructions screen

instru := "
(
CREATE A NEW NOTE (ie clinic note, results letter..) with ONE click (or use Dragon and speak it)

Fill in the fields below for as many note titles as you'd like. 

)"

gui9on:=1 ; this forces the jump link to the function screen to submit the data from GUI below (w/o Ok button)


gui, 19: Font, s11, Verdana  ; Set Verdana.
gui, 19: Add, Text, X5 Y5 w1000 R6, %instru%
gui, 19: Font
gui, 19: Font, Underline cBlue s13, Verdana 

gui, 19: Font
gui, 19: Font, s11, Verdana  ; Set Verdana.


gui, 19: Font, s13, Verdana  ; Set 13-point Verdana.
gui, 19: Add, Text, x12 y145 w120 h30, Speed Note 1 ; This just displays the text 
gui, 19: Add, Text, x12 y+20 w120 h30, Speed Note 2 ; This just displays the text 
gui, 19: Add, Text, x12 y+20 w120 h30, Speed Note 3 ; This just displays the text
gui, 19: Add, Text, x12 y+20 w120 h30, Speed Note 4 ; This just displays the text
gui, 19: Add, Text, x12 y+20 w140 h30, Speed Note 5 ; This just displays the text
gui, 19: Add, Text, x12 y+20 w120 h30, Speed Note 6 ; This just displays the text 


;----------------display entry boxes (edit boxes)


gosub dropdownnotelist


notelist := notelist . "  |" . "Title Missing? Hit 'Reimport' Button"


gui, 19: Font
gui, 19: Font, s10, Verdana 

; if one note title name is a subset of another: we have a problem

ReplacedStr := StrReplace(notelist, notetitle1 . "|" , notetitle1 . "||") ;----THis modifies the dropdown options to select a default.
gui, 19: Add, DropdownList, x136 y145 w268 vnotetitle1, %ReplacedStr%

ReplacedStr := StrReplace(notelist, notetitle2 . "|" , notetitle2 . "||") ;----THis modifies the dropdown options to select a default.
gui, 19: Add, DropdownList, x136 y+27 w268 vnotetitle2, %ReplacedStr%

ReplacedStr := StrReplace(notelist, notetitle3 . "|"  , notetitle3 . "||") ;----THis modifies the dropdown options to select a default.
gui, 19: Add, DropdownList, x136 y+27 w268 vnotetitle3, %ReplacedStr%

ReplacedStr := StrReplace(notelist, notetitle4 . "|" , notetitle4 . "||") ;----THis modifies the dropdown options to select a default.
gui, 19: Add, DropdownList, x136 y+28 w268 vnotetitle4, %ReplacedStr%

ReplacedStr := StrReplace(notelist, notetitle5 . "|" , notetitle5 . "||") ;----THis modifies the dropdown options to select a default.
gui, 19: Add, DropdownList, x136 y+28 w268 vnotetitle5, %ReplacedStr%

ReplacedStr := StrReplace(notelist, notetitle6 . "|"  , notetitle6 . "||") ;----THis modifies the dropdown options to select a default.
gui, 19: Add, DropdownList, x136 y+27 w268 vnotetitle6, %ReplacedStr%

/*
gui, 19: Add, Edit, x165 y145 w225 h30 vnotetitle1, %notetitle1%  ;this is is the actual input box, so we must attach a variable to it. IE: vRN 
gui, 19: Add, Edit, x165 y+20 w225 h30 vnotetitle2, %notetitle2% ; This is the actual input box, so we must attach a variable to it. 
gui, 19: Add, Edit, x165 y+20 w225 h30 vnotetitle3, %notetitle3%  ; This is the actual input box, so we must attach a variable to it. 
gui, 19: Add, Edit, x165 y+20 w225 h30 vnotetitle4, %notetitle4%  ; This is the actual input box, so we must attach a variable to it. 
gui, 19: Add, Edit, x165 y+20 w225 h30 vnotetitle5, %notetitle5% ; This is the actual input box, so we must attach a variable to it. 
gui, 19: Add, Edit, x165 y+20 w225 h30 vnotetitle6, %notetitle6% ; This is the actual input box, so we must attach a variable to it. 

; gui, 19: Add, Edit, x165 y+20 w225 h30 vnotetitle6, %notetitle6%  ; This is the actual input box, so we must attach a variable to it. 

*/
; associated clinic name column:

gui, 19: Font, underline s11, Verdana  ; Set Verdana.
gui, 19: Add, Text, x425 y120 w300 h30, Location For Note: ; This just displays the text 

gui, 19: Add, Text, x136 y120 w290 h27, The Note Title for Quick Access: ; This just displays the text 
Gui, 19: Font
gui, 19: Font,  s10, Verdana 

loclist :=""
instru := " "

if (strlen(f2fclinic) < 4 || strlen(phoneclinic) < 4 || strlen(vvc) < 4) ; not all slots full
{
instru := "     You can add more locations:|            on Ctrl-H screen| Use F2f/phone/VVC clinic slots "
}


loclistfxn(f2fclinic) ; adds each clinic (if present) to list
loclistfxn(phoneclinic)
loclistfxn(vvc)

loclist := loclist . instru ; add text to end of list if needed (list not full of locations)


;############################################################################################
;##################function to build the LOCATION drop down list on Gui 19###################################################
;############################################################################################


loclistfxn(x)
{

	if (strlen(x) > 4)
	{
	x := "|" . x . "|" 
	global loclist :=  global loclist .  x 
	loclist := strreplace(loclist, "||", "|") ; at this point nothing should have double pipe
	
	}
}

;############################################################################################
;#################end function################################################
;############################################################################################


ReplacedStr := StrReplace(loclist, "|" . converttoStandardloc(locNote1) . "|" , "|" . converttoStandardloc(locNote1) . "||") ;----THis modifies the dropdown options to select a default.
gui, 19: Add, DropdownList, x415 y145  w260 vlocNote1, %ReplacedStr%


ReplacedStr := StrReplace(loclist, "|" . converttoStandardloc(locNote2) . "|" , "|" . converttoStandardloc(locNote2) . "||")
gui, 19: Add, DropdownList, x415 y+27  w260 vlocNote2, %ReplacedStr%

ReplacedStr := StrReplace(loclist, "|" . converttoStandardloc(locNote3) . "|" , "|" . converttoStandardloc(locNote3) . "||")
gui, 19: Add, DropdownList, x415 y+27  w260 vlocNote3, %ReplacedStr%

ReplacedStr := StrReplace(loclist, "|" . converttoStandardloc(locNote4) . "|" , "|" . converttoStandardloc(locNote4) . "||")
gui, 19: Add, DropdownList, x415 y+28  w260 vlocNote4, %ReplacedStr%

ReplacedStr := StrReplace(loclist, "|" . converttoStandardloc(locNote5) . "|" , "|" . converttoStandardloc(locNote5) . "||")
gui, 19: Add, DropdownList, x415 y+28  w260 vlocNote5, %ReplacedStr%

ReplacedStr := StrReplace(loclist, "|" . converttoStandardloc(locNote6) . "|" , "|" . converttoStandardloc(locNote6) . "||")
gui, 19: Add, DropdownList, x415 y+27  w260 vlocNote6, %ReplacedStr%

;############################################################################################
;######################template # column################################################
;############################################################################################

templist := "None|1|2|3|4|5|6|"



Gui, 19: Font, cblue underline s10, Verdana
Gui, 19: Add, Text, x660 Y100 w500 ggui23 , What`'s a Template #?
gui, 19: Font
gui, 19: Font, underline s10, Verdana  ; Set Verdana.
gui, 19: Add, Text, x690 y125 w300 h30, Template #

 gui, 19: Font
 gui, 19: Font,  s10, Verdana 
 ReplacedStr := StrReplace(templist, tempnote1 , tempnote1 . "|") ;----THis modifies the dropdown options to select a default.

gui, 19: Add, DropdownList, x690 y145  w60 vtempNote1, %ReplacedStr%

ReplacedStr := StrReplace(templist, tempnote2 , tempnote2 . "|")
gui, 19: Add, DropdownList, x690 y+27  w60 vtempNote2, %ReplacedStr%

ReplacedStr := StrReplace(templist, tempnote3 , tempnote3 . "|")
gui, 19: Add, DropdownList, x690 y+27  w60 vtempNote3, %ReplacedStr%

ReplacedStr := StrReplace(templist, tempnote4 , tempnote4 . "|")
gui, 19: Add, DropdownList, x690 y+28  w60 vtempNote4, %ReplacedStr%

ReplacedStr := StrReplace(templist, tempnote5 , tempnote5 . "|")
gui, 19: Add, DropdownList, x690 y+28  w60 vtempNote5, %ReplacedStr%

ReplacedStr := StrReplace(templist, tempnote6 , tempnote6 . "|")
gui, 19: Add, DropdownList, x690 y+27  w60 vtempNote6, %ReplacedStr%

;############################################################################################
;######################dragon info column################################################
;############################################################################################


;-------------------text showing key PSEUDOHYPERLINKS
gui, 19: Font, underline s10, Verdana  ; Set Verdana.
gui, 19: Add, Text, x800 y125 w300 h30, How to Open Note (LOWER Bstr toolbar): ; This just displays the text 
; gui, 19: Font
; gui, 19: Font,  s9, Verdana 
; gui, 19: Add, Text, x800 y120 w300 h30, (LOWER Booster toolbar):
 gui, 19: Font
 gui, 19: Font,  s10, Verdana 

gui, 19: Add, Text, x800 y145 w290 h30,  Quick Button #1 AND 'New Notes' Button
gui, 19: Add, Text, x800 y+20 w290 h30,  Quick Button #2 AND 'New Notes' Button  
gui, 19: Add, Text, x800 y+20 w250 h30,  'New Notes' Button
gui, 19: Add, Text, x800 y+20 w250 h30,  'New Notes' Button
gui, 19: Add, Text, x800 y+20 w250 h30,  'New Notes' Button
gui, 19: Add, Text, x800 y+20 w250 h30,  'New Notes' Button 


;-----------------------------------------Show function key assignment on main GUI
gui, 19: Font
gui, 19: Font, underline s10, Verdana  ; Set Verdana.
gui, 19: Add, Text, x1100 y125 w300 h30, Dragon: ; This just displays the text 
gui, 19: Font
gui, 19: Font,  s10, Verdana 


gui, 19: Add, Text, x1100 y145 w300 h30, 'Dot Note 1' OR 'Dot Main Note'
gui, 19: Add, Text, x1100 y+20 w300 h30, 'Dot Note 2' OR 'Dot Letter'
gui, 19: Add, Text, x1100 y+20 w300 h30, 'Dot Note 3' 
gui, 19: Add, Text, x1100 y+20 w300 h30, 'Dot Note 4' 
gui, 19: Add, Text, x1100 y+20 w300 h30, 'Dot Note 5' 
gui, 19: Add, Text, x1100 y+20 w300 h30, 'Dot Note 6' 

gui, 19: Font
gui, 19: Font,  s11, Verdana  ; Set Verdana.

gui, 19: Add, Button, x2 y490  w50 h30 , OK ; Button to submit the information
gui, 19: Add, Button, x800 y490  w300 h30  greimportbutton , REIMPORT Note Titles From CPRS

;-------------------------end of help links

gui, 19: Show, x30 y0 w1330 h550, Minneapolis VA Informatics - Make New Note In CPRS ; Display the gui, 19: x and y tell where to show the window at on the screen and h and w tell what size to make it

return ; this is the return at end of GUI

19GuiClose:
   gui, 19: Destroy ; Destroy the GUI to get it out of the way
  lastwin:= "notCPRS" ; make the floating help bar pop back up with next left click

return

reimportbutton:
   gui, 19: Destroy ; Destroy the GUI to get it out of the way
  lastwin:= "notCPRS" ; make the floating help bar pop back up with next left click
gosub gui20

return

;----------------Start of OK button processing on Help and Setup screen

19ButtonOK: ; Execute the following actions when the button from the GUI OK is pressed
gui, 19: Submit ; Save all the information in the GUI (The variables)
Gui, 19: Destroy ; Destroy the GUI to get it out of the way

; we need to convert to standard phone clinic/f2f names first b4 disk write.


locnote1 := converttoStandardloc(locnote1)
locnote2 := converttoStandardloc(locnote2)
locnote3 := converttoStandardloc(locnote3)
locnote4 := converttoStandardloc(locnote4)
locnote5 := converttoStandardloc(locnote5)
locnote6 := converttoStandardloc(locnote6)

gosub, writeit

return



;############################################################################################
;#################function to take clinic names from GUI and convert to pointer AND VICE VERSA: toggles back and forth######################################
;############################################################################################

converttoStandardloc(fullname) 
{
global f2fclinic
global phoneclinic
global vvc

; this part compressed actual names (from drop down) back to pointer
 if (fullname = f2fclinic)
	return "F2F" 
 if (fullname = phoneclinic)
	return "phone"
 if (fullname = vvc)
	return "VVC"

; this part expands pointer names back to actual
 if (fullname = "F2F")
	return f2fclinic 
 if (fullname = "phone")
	return phoneClinic
 if (fullname = "vvc")
	return vvc

}

;############################################################################################
;############################end fxn###############################################
;############################################################################################







dropdownnotelist:   ; this is the Setupscreen dropdown FOR NOT TITLES NOT locations &  NOT the fxnbar dropdown

; notelist := NoteFavsArray[1] . "|" . NoteFavsArray[2] . "|" . NoteFavsArray[3] . "|" . NoteFavsArray[4] . "|" . NoteFavsArray[5] . "|" . NoteFavsArray[6] . "|" . NoteFavsArray[7] . "|" . NoteFavsArray[8] . "|" . NoteFavsArray[9 ] . "|" . NoteFavsArray[10] . "|" 
notelist := ""

loop, 10
{
	
		if (strlen(NoteFavsArray[A_index])> 3)
		{
		
		notelist := NoteFavsArray[A_Index] . "|" . notelist
		}
		else	
		{
		break ; if a blank value: stop loop
		}
}


return


reimport:
   gui, 19: Destroy 
   gosub gui20

instru := "
(
CPRS: Tools menu--->Options--->Notes-->Document Titles


)"


MsgBox, 262144, CPRS Booster, %instru%

; https://web.microsoftstream.com/video/404dd44c-07bf-451f-8115-5a0501d4e4e8?channelId=1527ec07-e93e-4321-996e-336cfb24fdbb
return ; end reimport


Return ; End of autonote


;############################################################################################
;###############    END OF AUTO CREATE PROGRESS NOTE        ###############################
;############################################################################################


;############################################################################################
;#################GUI To REIMPORT NOTE TITLES: GUI 20##########################################
;############################################################################################
gui20:

my_picturefile =%BoosterRoot%Pictures\CPRSFavoriteTitles.PNG
Gui, 20: Add, Picture,w1070 h-1 , %my_picturefile%
Gui, 20: Font, CBlack s10, Verdana  ; Set Verdana
Gui, 20: Add, Button,x50 y330 w500  gfinalreimport , I`'M READY: REIMPORT Titles From CPRS 
Gui, 20: Add, Button,x50 y+45 w500 gupdatefavs , I NEED TO UPDATE my CPRS Favorite Titles First: Help me
; Gui, 20: Add, Button,x50 y+30 w500  gnoidea, I have NO IDEA what you`'re talking about: show me a short video
Gui, 20: Add, Button,x50 y+45 w500 g20Guiclose , Uh...let`'s forget the whole thing
Gui, 20: Show, x150 y100 w1100 h550 , Booster: Import Note Titles ; Display the GUI, x and y tell where to show the window at on the screen and h and w tell what size to make it


return ; return for Gui 20


20GuiClose:
 Gui, 20: Destroy ; Destroy the GUI to get it out of the way
return


finalreimport:
Gui, 20: Destroy
gosub importtitles

return


noidea:

SplashTextOn ,150 ,100, CPRS Booster, Video not ready yet
sleep 1000
SplashTextOff
return

;############################################################################################
;#####################END REIMPORT NOTE TITLE GUI##########################################
;############################################################################################


;############################################################################################
;###############################GUI 22#######HELP me UPDATE my CPRS note favs ##########################
;############################################################################################


updatefavs:


Gui, 22: Font, s13, Verdana  ; Set Verdana
Gui, 22: +AlwaysOnTop
Gui, 22: Add, Text, X5 Y20 w500  , SETTING CPRS NOTE FAVORITES: `n`n Watch video OR read instructions below `n
Gui, 22: Font, cblue underline s11, Verdana
Gui, 22: Add, Text, X5 Y80 w500 gnoteimportvideo , CLICK HERE to watch a video (4.5 min) on CPRS Note Favorites

Gui, 22: Add, Text, X5 Y120 w500 ggui24 , CLICK HERE to see printed instructions on CPRS Note Favorites

Gui, 22: Add, Button,x50 y650 w100 , OK ; Button to submit the information
Gui, 22: Show, x45 y25 w600 h400 , CPRS: TELL CPRS WHICH NOTE TITLES YOU LIKE ; Display the GU
return ; return for Gui 22

22GuiClose:
 Gui, 22: Destroy ; Destroy the GUI to get it out of the way
Return

22ButtonOK:
Gui, 22: Destroy ; Destroy the GUI to get it out of the wayCa
return


return 


noteimportvideo:
SplashTextOn ,150 ,100, CPRS Booster, Hang on Getting Video
sleep 800
SplashTextOff
helpvid :=  "https://web.microsoftstream.com/video/404dd44c-07bf-451f-8115-5a0501d4e4e8?channelId=1527ec07-e93e-4321-996e-336cfb24fdbb&referrer=https:%2F%2Fdvagov.sharepoint.com%2F"
Run %helpvid%

 return


;############################################################################################
;###################################END gui 22#####################################################
;############################################################################################

;############################################################################################
;########################start gui 23: picture explaining Template Numbers####################
;############################################################################################


gui23:

my_picturefile =%BoosterRoot%Pictures\templatenumber.PNG
Gui, 23: Add, Picture,w400 h-1 , %my_picturefile%
Gui, 23: Show, x500 y150 w415 h400 , CPRS: What`'s a Template Number? ; Display the GU
return ; return for Gui 23

23GuiClose:
 Gui, 23: Destroy ; Destroy the GUI to get it out of the way
Return


;############################################################################################
;################################End GUI 23###########################################
;############################################################################################



;############################################################################################
;########################start gui 24: How Update CPRS favorite notes####################
;############################################################################################


gui24:
 Gui, 22: Destroy

my_picturefile =%BoosterRoot%Pictures\HowChangeCPRSFavs.PNG
Gui, 24: Add, Picture,w1000 h-1 , %my_picturefile%
Gui, 24: Show, x100 y50 w1115 h600 , CPRS Favorite Note Titles ; Display the GU
return ; return for Gui 24

24GuiClose:
 Gui, 24: Destroy ; Destroy the GUI to get it out of the way
Return


;############################################################################################
;################################End GUI 24###########################################
;############################################################################################

;############################################################################################
;###############################Gui 25: personal profile for national dot library######################################
;############################################################################################

;**********I THINK THIS LATER BECAUSE GUI35 not 25; this is blank


;############################################################################################
;################################END gui 25#####################################################
;############################################################################################


getprocesses() ; *********************fxn to find if Onedrive actively running
{
wegotone := 0

for proc in ComObjGet("winmgmts:").ExecQuery("Select * from Win32_Process")
	{
		if (proc.name = "OneDrive.exe" and  StrLen(proc.CommandLine) > 2)
		{
		wegotone := 1
		}	

	}

   If (wegotone = 1)
	{
	; MsgBox, 262144, CPRS Booster, We got OneDrive
	answer2 := 1
	}
	else
	{
	answer2 := 0
	}

return %answer2%
}   ; -------------------**************end of fxn to look for OneDrive Running


;############################################################################################
;########################DRAGON BUTTON GUI######################################
;############################################################################################



draggui:
instru := "
(
                                                 DRAGON and BOOSTER: Use them together!

Do you Use Dragon Naturally Speaking?

          Dragon has been supercharged with new built-in Booster commands.
		  NO SET UP NECESSARY: START NOW!
		  
		  All of the dragon commands start with the word 'dot'
		  
If you have both Dragon and Booster running, turn on the dragon microphone and:
)"

Gui, 10: Font, s11, Verdana  ; Set Verdana.
Gui, 10: Add, Text, X5 Y5 w600 R12, %instru%

Gui, 10: Font, cblue underline s11, Verdana
Gui, 10: Add, Text, gdragonmail x700 y40 w200 h60, Don't use Dragon? Make your life easier: click here to get it!
Gui, 10: Font, cblack underline s11, Verdana
Gui, 10: Add, Text, x700 y150 w200 h90, {Note: IF you disabled certain Booster key combos (ie CTRL-A, etc): Those commands will not work with Dragon}.
; Gui, 10: Add, Text, gAllHelp  w350 h30, How To Use CPRS Booster? CLICK HERE ; This just displays the text
; Gui, 10: Add, Text, gTroubleshooting  x630 y7 w350 h30, TROUBLESHOOTING: CLICK HERE ; This just displays the text
Gui, Font



;-------------------text showing key PSEUDOHYPERLINKS
Gui, 10: Font, underline s11, Verdana  ; Set Verdana.

Gui, 10: Add, Text, x50 y200 w300 h30, Say to Dragon: ; This just displays the text 
Gui, 10: Font
Gui, 10: Font,  s11, Verdana 

Gui, 10: Add, Text, x50 y220 w400 h18, Dot Sign-------------------Signing------------>

Gui, 10: Add, Text, x50 y+10 w400 h18, Dot Addendum ----------Addendum---------->
Gui, 10: Add, Text, x50 y+10 w400 h18, Dot Edit ---------------Edit Note----------->
Gui, 10: Add, Text, x50 y+10 w400 h18, Dot Spell Check ----Spell Check Note ------->
Gui, 10: Add, Text, x50 y+10 w400 h18, Dot Additional-----------Add Signer----------->
Gui, 10: Add, Text, x50 y+10 w400 h18, Dot MSA ----------------Add Signer----------->  ; Ctrl-1 ; pseudohyperlink
Gui, 10: Add, Text, x50 y+10 w400 h18, Dot Nurse --------------Add Signer-----------> ; Ctrl-M, Ctrl-B,Ctrl-R ; pseudohyperlink
Gui, 10: Add, Text, x50 y+10 w400 h18, Dot Pharm -----------Add Signer-----------> ; Ctrl-F (Farmacist:P taken) ; pseudohyperlink
Gui, 10: Add, Text, x50 y+10 w400 h18, Dot Provider--------------Add Signer----------->


Gui, 10: Add, Text, x50 y+10 w400 h18, Dot Next-------------Advance to Next Pt-------> ; Ctrl-S ; pseudohyperlink

Gui, 10: Add, Text, x50 y+10 w400 h18, Dot Flag ------------------Flag: Flagging-------> ; pseudohyperlink
Gui, 10: Add, Text, x50 y+10 w400 h18, Dot Unflag ---------------Flag: Unflagging-----> ; pseudohyperlink
Gui, 10: Add, Text, x50 y+10 w400 h18, Dot Ignore ---------------Flag: Ignore--------->

Gui, 10: Add, Text, x50 y+10 w400 h18, Dot CPRS---------------Start----------------->
;-----------------------------------------Show function key assignment on main GUI
Gui, 10: Font
Gui, 10: Font, underline s11, Verdana  ; Set Verdana.
Gui, 10: Add, Text, x400 y200 w300 h30, Booster Will: ; This just displays the text 
Gui, 10: Font
Gui, 10: Font,  s11, Verdana 



Gui, 10: Add, Text, x400 y220 w250 h18, Activate Booster signing function
	
Gui, 10: Add, Text, x400 y+10 w250 h18, Make an Addendum
Gui, 10: Add, Text, x400 y+10 w250 h18, Edit Note
Gui, 10: Add, Text, x400 y+10 w250 h18, CPRS Spellcheck



Gui, 10: Add, Text, x400 y+10 w600 h18, Add an additional signer NOT saved by Booster (someone else)
Gui, 10: Add, Text, x400 y+10 w250 h18, Add MSA ; Ctrl-1 ; pseudohyperlink
Gui, 10: Add, Text, x400 y+10 w250 h18, Add Nurse ; Ctrl-M, Ctrl-B,Ctrl-R ; pseudohyperlink
Gui, 10: Add, Text, x400 y+10 w250 h18, Add Pharmacist
Gui, 10: Add, Text, x400 y+10 w250 h18, Add Provider ; Ctrl-F (Farmacist:P taken) ; pseudohyperlink

Gui, 10: Add, Text, x400 y+10 w250 h18, Go to next patient ; Ctrl-S ; pseudohyperlink

Gui, 10: Add, Text, x400 y+10 w600 h18, Flag an order: but not to a specific person saved in Booster (you type name) ; pseudohyperlink
Gui, 10: Add, Text, x400 y+10 w250 h18, Unflag flagged orders ; pseudohyperlink
Gui, 10: Add, Text, x400 y+10 w600 h18, Ignore flag when someone else is also flagged to order

Gui, 10: Add, Text, x400 y+10 w250 h18, Start CPRS
Gui, 10: Add, CheckBox, x300 y+10 checked vDragStrt, Have Booster automatically start Dragon (if installed) when it starts CPRS?

Gui, 10: Add, Button, x2 y620  w40 h30 , OK ; Button to submit the information


;-------------------------end of help links

Gui, 10: Show, x100 y30 w1000 h650, Dragon and Booster: Better Together! ; Display the GUI, 10: x and y tell where to show the window at on the screen and h and w tell what size to make it

return ; this is the return at end of GUI

10GuiClose:
   Gui, 10: Destroy ; Destroy the GUI to get it out of the way
  ; lastwin:= "notCPRS" ; make the floating help bar pop back up with next left click

return

;----------------Start of OK button processing on Help and Setup screen

10ButtonOK: ; Execute the following actions when the button from the GUI OK is pressed
 Gui, 10: Submit ; Save all the information in the GUI (The variables)
Gui, 10: Destroy ; Destroy the GUI to get it out of the way
;  msgbox %DragStrt% 
; lastwin:= "notCPRS" ; make the floating help bar pop back up with next left click
Return ; End of add extra add signers

return


dragonmail:


	SplashTextOn ,300 ,100, CPRS Booster, Hang on: I'm writing an email for you! 
	sleep 2000
	SplashTextOff

mailreceip := "MSR "
mailreceip .= Visn
mailreceip .= " ADMIN"


mailsub := SiteCode . ": I'd like Dragon installed."
mailbody := "Hello, I'm interested in having Dragon Installed. "
mailbody :=  mailbody  . "You can IGNORE this email if you are not a Dragon admin for: "  .  SiteCode 

moremail := "
(


My username is: 
)"
mailbody :=  mailbody  . moremail . A_UserName

moremail := "
(


To see my name, email address, department and location: please look above at this email where my name is shown. 

Use your mouse to hover over my name  and THEN--> RIGHT click --> Open contact card

Thanks!

)"
mailbody :=  mailbody  . moremail 
MailItem := ComObjCreate("Outlook.Application").CreateItem(0)
MailItem.Recipients.Add(mailreceip)
; MailItem.attachments.add("c:\test.pdf")
MailItem.Subject := mailsub
MailItem.body := mailbody
MailItem.display



	MsgBox, 262145, CPRS Booster, Just click send on the email I wrote for you. Someone will contact you to set up dragon.

return




;----------------------------------------******************END DRAGON BUTTON GUI



netcheck:   ; --------*********************----------------------CHECK TO SEE IF ON VA NETWORK AND LOOP UNTIL WE ARE
IfNotExist, %BoosterRoot%CPRSBooster.exe
{
MsgBox, 262145, CPRS Booster, You may not be connected to VA network. If not, connect first and then click OK here.

}

return   ; ------------------------------END OF VA NETWORK check



installone: ; ----------------------START: OPEN OR INSTALL ONE DRIVE

filename := onedriveBoosterFilename ; set the working filename for booster to the needed Onedrive booster file

	SplashTextOn ,300 ,100, CPRS Booster, HANG ON (don't touch anything)...OneDrive Needs To Be Started On This Computer
	sleep 1000
	SplashTextOff

send {Lwin}
sleep 300
send onedrive
sleep 800
send {enter}
sleep 3000

IfWinExist, OneDrive - Department of Veterans Affairs   ;    installation not needed :just needed to run
{

return
}

WinWait, Microsoft OneDrive, , 15 ; 7 seconds is not enough. Not finding registration screen
winactivate, Microsoft OneDrive



instru := "
	(
***Finish One Drive Set up: Type in your VA email address and hit SIGN IN.

***THEN: Click the next button SEVERAL TIMES until set up is COMPLETE.

**THEN come back here when One Drive is running and press OK

)"



instru2 := "
	(
***It doesn't look like One Drive was installed 
   on this computer

***Booster will close. Re-launch Booster once
OneDrive is running***

)"

instru3 := "
	(
***It looks like OneDrive Set up is not complete.

*** Finish the OneDrive setup screens (about 6 of them)
    and THEN click OK here.


)"

IfWinExist, Microsoft OneDrive ; this means user is using a 'new' computer and needs to register onedrive w/that computer.
{
MsgBox, 262145, CPRS Booster, %instru% ; user should NOT proceed past here until registration done.

;
	IfWinExist, Microsoft OneDrive ; user clicked that registration is done but window still open <> the drive itself.
	{
	MsgBox, 262145, CPRS Booster, %instru3% ; user should NOT proceed past here until registration done.

;
	}



;   *********now we check to see if successfully registered on this comp: if so, C drive directory should be there


; BETA IfNotExist, C:\Users\%A_UserName%\OneDrive - Department of Veterans Affairs\CPRSBooster

; IfNotExist, %userprofile%\OneDrive - Department of Veterans Affairs\CPRSBooster
IfNotExist, %onedrive%\CPRSBooster
{
    MsgBox, 262145, CPRS Booster, %instru2%
    exitapp
}



}
; ****WE need some logic here to either shut down the open drive window if there OR detect install screens

; winclose, OneDrive - Department of Veterans Affairs

return ; --------------------------------end of install one drive


LookforOne:
			tryonecounter := 0
			Reinstall:

 			if (getprocesses() = 0) ; ONE DRIVE NOT ACTIVE ; CALLS a function located toward end of script
			{
			failedfirst := 1 ; first time through was a failure so will change user messaging second time through
			SplashTextOn ,300 ,100, CPRS Booster, DON'T TOUCH: I need to start OneDrive
			sleep 1000
			  SplashTextOff
			gosub installone ; let's get onedrive going on this comp (will either launch and/or install)
			sleep 100
			}

			if (getprocesses() = 0) ; ONE DRIVE NOT ACTIVE EVEN AFTER we tried above ;  WE are ALWAYS looking TWICE
			{

			sleep 300
			SplashTextOn ,300 ,100, CPRS Booster, Hmmm: OneDrive Still not installed or running. Let's try again...
			Sleep 2000
			  SplashTextOff
					
				tryonecounter++
						If tryonecounter <2
						{
						goto reinstall
						}
						else ; we've tried several times to start it and failed.
						{
instru := "
	(
Booster can't find needed disk drives.

****NOTE TO CITRIX USERS******: 
If you are using CITRIX (CAG)
to connect remotely: switch to 'Azure'. See
Ctrl-H---> troubleshooting: section on Citrix.
********

If YOU can start your OneDrive, please
do it and THEN click OK below....

(If you can't do it: click OK now)


)"


						MsgBox, 262144, CPRS Booster: No Drives, %instru% ; Ask user to try


instru := "
	(
Booster can't find needed disk drives.

May not save/use your settings.

Information entered in Ctrl-H will not
be saved for future Booster use.

)"
						if (getprocesses() = 0) ; ONE DRIVE NOT ACTIVE EVEN AFTER User tries
							{
							MsgBox, 262144, CPRS Booster: No One Drive: may limit some functions

							}			
							else ; user managed to do it!
							{	
							gosub GotOneStarted	
							}
						
							

						}
	
			}
		else ; We DID get ONE drive started
			{
			gosub GotOneStarted	; YEAH BUT that doesn't mean it's registered on this computer: they may get new user prompt
			}



return ; ------------------------------------END of LOOKING for OneDrive (and gosubing installonedrive if not there)




GotOneStarted: ;-------------------------Subroutine to give message that we managed to get one drive started

 if	(failedfirst = 1)  ; first time through was a failure so will change user messaging second time through
				{
				SplashTextOn ,300 ,100, CPRS Booster, Good to GO! You are Boosted!
				Sleep 2000
			 	 SplashTextOff
				failedfirst := 0 ; reset
				}

return ; END of got one started message

GetFocusedControlClassNN( )
{
GuiWindowHwnd := WinExist("A")		;stores the current Active Window Hwnd id number in "GuiWindowHwnd" variable
				;"A" for Active Window

ControlGetFocus, FocusedControl, ahk_id %GuiWindowHwnd%	;stores the  classname "ClassNN" of the current focused control from the window above in "FocusedControl" variable
						;"ahk_id" searches windows by Hwnd Id number

return, FocusedControl
}

 ; ****************************** date increment function
dateincrement(increment,dte)
{
EnvAdd dte, %increment%,days            ; Increment this variable by diff days until sunday
FormatTime toDay_Readable, %dte%, ShortDate ; THIS IS THE NEXT sunday in a simplified date format
return toDay_Readable

}
; ********************************end of date increment function




getOrderStart: ; *******************This gets us to the top of the order tab left nav

winactivate VistA
sleep 100
 ordertrycount := 1
  getordertab:
  sleep 500 ; we should have the correct pt now.
  send ^o  ; go to orders tab
  sleep 120
  send +{tab 2}
  sleep 200
  send {pgup 5}
  sleep 200


fc := GetFocusedControlClassNN()


; msgbox %fc%

  ; SplashTextOn ,300 ,100, CPRS Booster, Focused %fc%
 ;  Sleep 1000
  ; SplashTextOff
  ;  goto tryitagain
  sleep 500

if (fc != "TORListBox1") && (fc != "TTabControl3")
{
  ordertrycount++
  SplashTextOn ,300 ,100, CPRS Booster, Didn't make it off order home
  Sleep 2000
  SplashTextOff

;  msgbox %fc%
  ;  goto tryitagain
    
   If ordertrycount < 3 
	{
	goto getordertab ; (loop trying to get to order 2 times)
	}
	else
	{
	 exit ; FIX THIS eventually: ? go to next pt
	}
}
else
{
 SplashTextOn ,300 ,100, CPRS Booster, GO! Press Down arrow repeatedly!
 Sleep 1000
  SplashTextOff
}


return ; ***************************** end of order start




;############################################################################################
;########################start testing area###########################################
;############################################################################################



	
  /*  ; BETA must activate

	; -------CPRS HAS to be OPEN for this hotkey to work
	^z::  ;----------------------ctrl-shift Z------*********************TESTING Key
	gosub DM1_CheckColorTimer

Return
 */   ; BETA must activate

;############################################################################################
;#####################end testing area###########################################
;############################################################################################





newmenu: ; -------------------------***********start navigation to top of any new menu

SetTitleMatchMode, RegEx


WinWait, Location for Current Activities|%menuname% ,, 5

		; MsgBox, 262145, CPRS Booster, variable %menuname%


		; 	MsgBox, 262145, CPRS Booster, screen  %XXOO%


IfWinExist, Location for Current Activities
{
gosub currentlocation
; sleep 800

}
		;   *** this logic gets to top left of any new menu

WinWait, %menuname% ,, 10 ; wait again in case we ended up on the encounter screen

WinGetTitle, XXOO ; check to see if we made it to the correct menu.
If (XXOO != menuname)  ; This isn't going to work if Menu name is only a portion

{


    SplashTextOn ,300 ,100, CPRS Booster, Didn't make it: we're on %XXOO%  
    Sleep 2000
    SplashTextOff
     exit
return

}

; sleep 100
; send {left 4}
; sleep 50
; send {pgup 3}
; sleep 50

return ; ----------------------------------------****end new menu navigation


;-----------------**********Code to set VISN based on User SiteCode in their Username




BED:
BHS:
BOS:
CON:
MAN:
NHM:
PRO:
TOG:
V01:
Visn := "V01"
CprsStartwarn := 0
Return

ANN:
BAC:
DAN:
DET:
IND:
NIN:
V11:
SAG:
Visn := "V11"
Return

CIN:
CLE:
CLL:
COS:
DAY:
V10:
Visn := "V10"
Return

CHS:
HIN:
IRO:
MAD:
MIW:
NCH:
TOM:
V12:
Visn := "V12"
Return

CMO:
KAN:
LEA:
MRN:
POP:
STL:
TOP:
WIC:
V15:
Visn := "V15"
if SiteCode contains TOP,top
	{
	SiteCode = EKHT
	}
  else
if SiteCode contains LEA,lea
	{
		SiteCode = EKHL
	}
Return

ALX:
BIL:
FAV:
HOU:
JAC:
LIT:
NOL:
SHR:
MUS:
V16:
Visn := "V16"
Return

CTX:
NTX:
STX:
VCB:
V17:
Visn := "V17"
Return

ABQ:
AMA:
BIG:
ELP:
PHO:
PRE:
TUC:
V18:
Visn := "V18"
Return

CHY:
DEN:
ECH:
FHM:
GRJ:
OKL:
SHE:
SLC:
V19:
Visn := "V19"
if SiteCode contains DEN,den
	{
	SiteCode = ECH
	}
Return

ALN:
BAN:
BAT:
BUF:
CAN:
HVH:
SYR:
WNY:
V02:
Visn := "V02"
CprsStartwarn := 0
Return

ANC:
BOI:
POR:
PUG:
ROS:
SPO:
WCO:
WWW:
V20:
Visn := "V20"
Return

FRE:
HON:
MAC:
PAL:
REN:
SFC:
V21:
Visn := "V21"
Return

LAN:
LOM:
LON:
SDC:
WLA:
GLA:
LAS:
; V18:
V22:

if SiteCode contains GLA,gla,LAN,lan
	{
	SiteCode = WLA
	}


Visn := "V22"

Return

BHH:
CIH:
DES:
FAR:
FTM:
GRI:
HOT:
IOW:
KNX:
LIN:
MIN:
OMA:
STC:
SUX:
V23:
Visn := "V23"
if SiteCode contains GRI,gri,LIN,lin,OMA,oma
	{
	SiteCode = NWI
	}
else
if SiteCode contains FTM,ftm,HOT,hot
	{
		SiteCode = BHH
	}
Return

BRK:
CAS:
NJH:
EAS:
LYN:
MOR:
NOP:
BRX:
NYH:
V03:
Visn := "V03"
CprsStartwarn := 0
Return

ALT:
BUT:
COA:
ERI:
LEB:
PHI:
PTH:
WBP:
WIM:
V04:
Visn := "V04"
CprsStartwarn := 0
Return

BAL:
BEC:
CLA:
HUN:
MWV:
PER:
WAS:
V05:
Visn := "V05"
CprsStartwarn := 0
Return

ASH:
DUR:
FNC:
HAM:
RIC:
SAM:
SBY:
V06:
Visn := "V06"
Return

ATG:
AUG:
BIR:
CAV:
CHA:
CMS:
DUB:
TUA:
V07:
Visn := "V07"
Return

BAY:
MIA:
NFL:
ORL:
SAJ:
TAM:
WPB:
V08:
Visn := "V08"
Return

LEX:
LOU:
MEM:
MOU:
NAS:
TVH:
V09:
Visn := "V09"
Return

;############################################################################################
;############################################################################################
;################################END OF BOOSTER ##############################################
;############################################################################################
;#################################*****START OF Bst DOT PHRASER################################
;############################################################################################
;############################################################################################
;############################################################################################

 #if
BoosterDotPhraser: ; ALL DOT PHRASER CODE IS A SUBROUTINE CALLED FROM AUTOEXECUTE BOOSTER SECTION


			Menu, Tray,  Icon, %BoosterRoot%dotphraseicon2.ico

			; onedrivelocalDot = C:\Users\%A_UserName%\OneDrive - Department of Veterans Affairs\CPRSBooster\DotPhrases\ ; This will be created first time through even w/o CTRLH

			 try 
					
					{
						IfNotExist, u:\CPRSBooster\DotPhrases
						{
						FileCreateDir, u:\CPRSBooster\DotPhrases
						
						}
					}


				; Make onedrive dir prn:

				try
				{
					; IfNotExist, %userprofile%\OneDrive - Department of Veterans Affairs\CPRSBooster\DotPhrases
					IfNotExist, %onedrive%\CPRSBooster\DotPhrases
					{
						; FileCreateDir, %userprofile%\OneDrive - Department of Veterans Affairs\CPRSBooster\DotPhrases
						FileCreateDir, %onedrive%\CPRSBooster\DotPhrases
					}
				}
				


			 gosub loadthem 
			gosub dplist ; 

			winminimize, Booster Dot Phrases: Your Dot Phrases

			SplashTextOn ,150 ,100, CPRS Booster, Booster Dot Phrases Loaded!
			sleep 1500
			SplashTextOff
			sleep 30
			winminimize, Booster Dot Phrases: Your Dot Phrases

return ; end of boosterdotphraser launch subroutine 

;###############################subroutine for GUI to MAKE NEW DOTPHRASE or edit     ###########################
GuiNewDot:
; suspend, on ; disable hotstrings while hotstring editor is open.

OnMessage(0x100, "WM_KEYDOWN")


if (getprocesses() <>  1) ; ********looks for OneDrive
	{
	
	MsgBox, 262144, CPRS Booster, It looks like your OneDrive isn't running. New Dot Phrases May Not be Saved. I will try to start it.
	gosub installone

	}


Gui, 11: Font, s11, Verdana  ; Set Verdana


; Gui, 11: Add, Text, X5 Y5 w600 R15, %instru%

Gui, 11: Font, cBlue underline s12, Verdana
Gui, 11: Add, Text, gdotdesc x10 y20 w400 R2, How to use dot phrases? Click here
Gui, 11: Font, cblack underline s12, Verdana
Gui, 11: Add, Text,  x400 y20 w400 R2, ***DO NOT save PIV codes/passwords***
Gui, 11: Add, Text,  x400 y40 w400 R2, ***   DO NOT save patient info    ***
Gui, 11: Font, Norm
Gui, 11: Font, CBlack s11, Verdana  ; Set Verdana
Gui, 11: Add, Text,x10  w470 R1 , What is the dot phrase/trigger text you will use (like .exam ):
Gui, 11: Add, Edit,x12 w200 h20 limit25 vdptrig , %dptrigdisplay%
Gui, 11: Add, Text,y+15 x50  w550 R1 , (Optional) Short description of this dot phrase (will help you organize later):
Gui, 11: Add, Edit,x50 w200 h20  limit25 vdpdesc	, %dpdesc%
Gui, 11: Add, Text,y+15 x50  w750 R1 , (Optional) Category (you define) of this dot phrase (helps later). Like 'exam shortcuts' or 'phone#s':
Gui, 11: Add, Edit,x50 w200 h20  limit15 vdpcat	, %dpcat%
Gui, 11: Add, Text,x10 y+15  w400 R1 , Enter the text you want inserted (the full text):
Gui, 11: Add, Edit, x10 w700 h200 vdotphrase, %dpdp%

Gui, 11: Add, Button,x50 y510 w100 , OK ; Button to submit the information
Gui, 11: Add, Button,x170 y510 w100 , Cancel ; Button to submit the information
Gui, 11: Add, Button,x500 y510 w200 , DELETE THIS Dot Phrase ; Button to submit the information
Gui, 11: Show, x345 y25 w800 h550 , Booster Dot Phrases - Edit/New ; Display the GUI, x and y tell where to show the window at on the screen and h and w tell what size to make it
return ; return for Gui 11

return ; return for GuiNewDot: subroutine

;###############################end of GuiNewDot Subroutine	     ###########################




11ButtonCancel: 
 Gui, 11: Destroy ; Destroy the GUI to get it out of the way
gosub clearDpVariables
gosub dplist
return

11GuiClose:
 Gui, 11: Destroy ; Destroy the GUI to get it out of the way
 gosub clearDpVariables
 gosub dplist
 
return 

11ButtonDELETETHISDotPhrase:
  Gui, 11: Submit ; Save all the information in the GUI (The variables)
 Gui, 11: Destroy ; Destroy the GUI to get it out of the way

 if (wecamefromlistview = 1) ; ie we are editing a dp: file name will change; delete old file to avoid dups
{
wecamefromlistview := 0 ; reset
gosub deleteDp
} ; IF we didn't come from Listview: they never created it first to delete it (nothing to delete); discard.
 
 gosub clearDpVariables
 
 gosub dplist
 winminimize, Booster Dot Phrases: Your Dot Phrases
return

11ButtonOK:
   Gui, 11: Submit ; Save all the information in the GUI (The variables)
   
	lendot := strlen(dptrig)
/*
MsgBox, 262144, CPRS Booster, %lendot%
		Gui, 11: Destroy 
		 gosub dplist
		winminimize, Booster Dot Phrases: Your Dot Phrases
return
*/


if (lendot < 2) ; if they entered a blank dot phrase: do not save it.
		{
		
		Gui, 11: Destroy ; Destroy the GUI to get it out of the way
		SplashTextOn ,350 ,100, CPRS Booster, You tried to save an invalid dotphrase.`n Must be at least 2 characters long. `n Not Saved.
		sleep 3000
		SplashTextOff
		gosub clearDpVariables
		 gosub dplist
		winminimize, Booster Dot Phrases: Your Dot Phrases
		return ; skip the rest
		}

  
 Gui, 11: Destroy ; Destroy the GUI to get it out of the way
 
 if (wecamefromlistview = 1) ; ie we are editing a dp: file name will change; delete old file to avoid dups
{
wecamefromlistview := 0 ; reset
filetodelete := onedrivelocalDot . fname ; fname is set in listview

filedelete, %filetodelete%

} 

 gosub makedotFilename
 gosub writeitDot ; variables are cleared in here but NOT the filename of newly created dp
 loadonlyone = 1 ; we now need to load just this new one as an active hotstring (not just save to disc for future)
 fname :=  dotfilename



if writeerror <> 1
	{ 
	SplashTextOn ,150 ,100, CPRS Booster, Dot Phrase created! Ready to use!
	sleep 1500
	SplashTextOff
	 gosub clearDpVariables
	  gosub loadthem
	 writeerror = 0 ; reset
	 }
 
  gosub dplist
 winminimize, Booster Dot Phrases: Your Dot Phrases
 
 return ; end GUI 11
 
 
dotdesc:
instru := "
(
Don't type the same text over and over: use 'dot phrases'. 
The dot phrase is so named because you define some shortcut
or trigger text that you type and Booster will automatically
(AS YOU TYPE) replace that shortcut text with a longer block
of text you want. The shortcut text is often called a 
'dot phrase' because people frequently define the trigger text to
start with a period (a 'dot') and then no space and a trigger
word. So the trigger text might be .exam : and that might 
insert the text describing a full physical exam. A trigger 
could be even shorter .e  or **e or something you wouldn't 
normally type but that you want replaced with a longer body of
text. In fact the trigger can just be a word that you always 
want replaced with another word.

OF NOTE: Booster is always watching for you to type a dot phrase
like .exam ... so every time you type .exam it will automatically,
on the spot, replace that with the full dot phrase. This process
works in ANY program you might be using including Outlook, MS Word, Teams, Secure messaging....

)"


Gui, 13: Font, s13, Verdana  ; Set Verdana
Gui, 13: Add, Text,x10  w600 R30 , %instru%
Gui, 13: Show, x345 y25 w650 h450 , What's a Dot Phrase? ; Display the GUI, x and y tell where to show the window at on the screen and h and w tell what size to make it
return ; return for Gui 13

return ; return for dotdesc



13GuiClose:
 Gui, 13: Destroy ; Destroy the GUI to get it out of the way

return

 
 howshare:
 
instru := "
(
Don't reinvent the wheel. Share your Dot Phrases!

How?

Your Dot phrases are on your 'OneDrive', in 
the 'CPRS Booster/Dot Phrases' Directory. 
Each dot phrase has its own file. The 
name of the file helps you see which dot
phrase is within. 

To share: attach the relevant files to an 
email and send them to person with whom you're
sharing. The recipient then copies those
dot phrase files to their 'CPRS Booster/Dot
Phrases' Directory.

They MUST THEN double click on Booster 
desktop icon to reload. All done. 

Note: OneDrive can be found like this:
Look for the clock/date at bottom right
of windows. About 1 inch to the left of
that is a little blue cloud icon. Double-
click on that to open OneDrive.

Confused: skip it for now. We're working
on an easier sharing method.

)"


Gui, 16: Font, s13, Verdana  ; Set Verdana
Gui, 16: Add, Text,x10  w600 R30 , %instru%
Gui, 16: Show, x345 y25 w500 h750 , Share/Receive Dot Phrases? ; Display the GUI, x and y tell where to show the window at on the screen and h and w tell what size to make it
return ; return for Gui 16

return ; return for howshare:



16GuiClose:
 Gui, 16: Destroy ; Destroy the GUI to get it out of the way

return

 

 

makedotFilename:

;####################REMOVE ILLEGAL FILENAME CHARACTERS##############################################################################
fndptrig := removeIllegalFileName(dptrig) ; remove illegal charaters before filename
fndpdesc := removeIllegalFileName(dpdesc)
fndpcat := removeIllegalFileName(dpcat)
fndotphrase := removeIllegalFileName(dotphrase)

;########################SHORTEN STRINGS FOR FILENAME USE##########################################################################
shortfndptrig := SubStr(fndptrig,1, 25) ; shorten before filename; THIS IS A PROB: NOT SHOWING ALL
shortfndpdesc := SubStr(fndpdesc,1, 20)
shortfndpcat:= SubStr(fndpcat,1, 15)
shortfndotphrase  := SubStr(fndotphrase ,1, 35)

;############MAKE ACTUAL FILENAME######################################################################################
dotFilename := "Desc = " . shortfndpdesc . "; Dotphrase = " . shortfndptrig . "; Fulltext = " . shortfndotphrase . "; Cat = " . shortfndpcat .  "; Authr = " . A_UserName  . ".bstr"

return
 
 
removeIllegalFileName(x)
{
 x := StrReplace(x,"<", "{less}")    ;STRIP OUT ILLEGAL CHARACTERS
 x := StrReplace(x,">", "{greater}")    ;STRIP OUT ILLEGAL CHARACTERS
 x := StrReplace(x,":", "{colon}")    ;STRIP OUT ILLEGAL CHARACTERS
 x := StrReplace(x,"""", "{quote}")    ;STRIP OUT ILLEGAL CHARACTERS
 x := StrReplace(x,"/", "{fslash}")    ;STRIP OUT ILLEGAL CHARACTERS
 x := StrReplace(x,"\", "{bslash}")    ;STRIP OUT ILLEGAL CHARACTERS
 x := StrReplace(x,"|", "{pipe}")    ;STRIP OUT ILLEGAL CHARACTERS
 x := StrReplace(x,"?", "{qstmrk}")    ;STRIP OUT ILLEGAL CHARACTERS
 x := StrReplace(x,"*", "{star}")    ;STRIP OUT ILLEGAL CHARACTERS
 x := StrReplace(x,";", "{semi}")    ; This is NOT illegal BUT is used as the delimiter when parsing the filename
 x := StrReplace(x,"`t", "")    ;STRIP OUT ILLEGAL CHARACTERS; tab
 x := StrReplace(x,"`n", "")    ;STRIP OUT ILLEGAL CHARACTERS; line break
return %x%
}
 
 ;############Inside the actual data file, the DP has to be on one line##############################################
compressDotP(dp)
{
 dp := StrReplace(dp,"`t", "{tab}")    ;STRIP OUT ILLEGAL CHARACTERS; tab
 dp := StrReplace(dp,"`n", "{Lbreak}")    ;STRIP OUT ILLEGAL CHARACTERS; line break
return %dp%
}

  ;############Write the DotPhrase to a file ###################################################
  ;############### NOTE: this does NOT create the dot phrase in active memory: need to load  ###########################
 writeitDot:
/*

gosub netcheck

 ;--- start writing: one copy to each location

	;-----***WRITE TO U****
	IfExist, U:\   ; **************** If there is a U drive write a copy there.
	{
	filename = u:\CPRSBooster\CPRSData.txt
	gosub writingdetails2
	} 

	;-----***WRITE TO ONE********
	if (getprocesses() = 1) ; ONE DRIVE IS ACTIVE ; CALLS a function located toward end of script
	
	{

	filename = %onedriveBoosterFilename% 
        gosub writingdetails2
	}	
*/
 

 
; writingdetails2: ;-------****************took this out of writeit sub routine b/c gonna write twice: once to U and Once to OneDrive if both extant

dotfinalfilename := onedrivelocalDot . dotFilename 

; StringLen, Length, dotfinalfilename
; MsgBox, The length of the string is %Length%.

file := FileOpen(dotfinalfilename,"w `n")   ;-------******************WRITING DATA TO FILE
;                  ----------------the variable names from the form are case sensative: ORDER MATTERS BELOW

if !IsObject(file)
{
 writeerror = 1 
	gosub writefail
    gosub clearDpVariables
	return
}


file.writeline(compressDotP(dpdesc))
file.writeline(compressDotP(dptrig))
file.writeline(compressDotP(dotphrase))
file.writeline(compressDotP(dpcat))
file.writeline(A_UserName)
file.writeline(A_Now)


file.close()

gosub clearDpVariables ;

return ; -------------------************end of write details
 ;############End dot Phrase Write to File###################################################
 
 
 ;############################################################################################
;###########GUI 17: explain write failure dotp###############################################
;############################################################################################
writefail:

instru := "
(
COULD NOT create dot phrase.

Why?

Booster needs to write to a directory on your C drive which is MISSING.

Solution:

After you close this screen, Booster will open an email and write
the details into the email. DO NOT send the email. You need to COPY
the text into an IT help desk ticket: then discard the email draft. 

)"


Gui, 17: Font, s13, Verdana  ; Set Verdana
Gui, 17: Add, Text,x10  w800 R30 , %instru%
Gui, 17: Show, x345 y25 w650 h450 , Can't Save Dot Phrase ; Display the GUI, x and y tell where to show the window at on the screen and h and w tell what size to make it
return ; return for Gui 17

return ;  for writefail



17GuiClose:
 Gui, 17: Destroy ; Destroy the GUI to get it out of the way
gosub Cdrivemail
return

 
 
 ;############################################################################################
;#######################create  email for Cdrive user wrong####################################################
;#########################################################################################

 Cdrivemail:


	SplashTextOn ,300 ,100, CPRS Booster, Hang on: I'm writing an email for you! 
	sleep 2000
	SplashTextOff




mailsub := "DO NOT send this email: copy text to IT help ticket."
mailbody := "Hello, My username on my C drive is not correct and not syncing with OneDrive. "
 
mailbody := "
(
Hello, My username on my C drive is not correct and is NOT syncing with OneDrive.

A program I use (CPRS Booster) is trying to write to this directory but cannot find it:

)"

mailbody :=  mailbody  . onedriveRoot

moremail := "
(


My current username is :

)"
mailbody :=  mailbody  .  moremail . A_UserName
MailItem := ComObjCreate("Outlook.Application").CreateItem(0)
; MailItem.Recipients.Add(mailreceip)
; MailItem.attachments.add("c:\test.pdf")
MailItem.Subject := mailsub
MailItem.body := mailbody
MailItem.display
 
 MsgBox, 262145, CPRS Booster, Copy text in this email into a help desk ticket.

 
 Return ; end of Cdrivemail
 ;############################################################################################
;####################################end c drive email########################################################
;############################################################################################

 
 
 
 
  ;############Start: CLEAR DOT VARIABLES###################################################
  ; the variables need to be cleared when not actively saving b/c they are used to prepopulate new dp screen for editing
clearDpVariables:

 dpdesc := ""
 dptrigdisplay := ""
dpdp := ""
dpcat := ""
dptrig :=""
return
  
   ;############End: Clear DOt Varibles###################################################
 
 
 ;############################### THIS LOADS Current dot phrases    ###########################
Loadthem:
		;########################Loops Through all files in directory    ##################################


	if (getprocesses() <>  1) ; ********looks for OneDrive
	{
		SplashTextOn ,300 ,150, CPRS Booster, OneDrive not running. Your dot phrases may not work. I'm going to try to start OneDrive.
		sleep 3500
		SplashTextOff
		Gosub LookforOne
			
		IfWinExist, OneDrive - Department of Veterans Affairs
		{
		winclose OneDrive - Department of Veterans Affairs
		}

	}
if (loadonlyone = 1) ; are we just loading one file (to edit/delete) or all of them?
		{
		loopfiles := onedrivelocalDot . "\" . fname

		}
		else
		{
		loopfiles := onedrivelocalDot  .  "\*.*"
		}

 Loop, %loopfiles%

{


;############################################################################################
;#######################If prior file was invalid: delete here##############################
;############################################################################################

	if (removefile = 1) 
	{
   filedelete, %filepathtodelete% ; wipe this file out.
	removefile := 0
	}
;############################################################################################
;###################end delete invalid from last loop#######################################
;############################################################################################


	dotFullReadPath := onedrivelocalDot . A_LoopFileName

	; msgbox %dotFullReadPath%
	
	 ;########################reads in all lines from any one file    #################################
	  Loop, Read, %dotFullReadPath%

		{
		
		  ; msgbox %A_Index%
				 if (A_Index = 1) 
					{
					
						dpdesc  := A_LoopReadLine ; this is not reading the title but actually the data
						; msgbox %dpdesc%
					}
				 if (A_Index = 2) 
					{
					
					
						dptrig  := A_LoopReadLine ; this is not reading the title but actually the data
						 dptrigdisplay := A_LoopReadLine ; dptrig is going to be modified below with :X:
						 lendot := strlen(dptrig)
						 
						 if (lendot< 2) ; not a valid dot p
						 {
						 
						filepathtodelete := dotFullReadPath ; hold this path
						removefile := 1 ; set this to one. can't delete now b/c currently reading.

						 filedelete, %dotFullReadPath% ; wipe this file out.
						 goto dontmakeit ; not a valid dot phrase
						 }
						 
						 ; msgbox %dptrig%
					}
					
					
				if (A_Index = 3) 
					{
					
						dpdp := A_LoopReadLine ; this is not reading the title but actually the data BUT we did compress to 
												; one line so we must decompress to multiline
						 
						 dpdp := DecompressDotP(dpdp)
						 
						 ; msgbox %dpdp%
					}
					
				if (A_Index = 4) 
					{
						dpcat := A_LoopReadLine ; this is not reading the title but actually the data
					}
		}  ; end of reading a single file

;######################## This is where the magic happens and x type hotstring: calls a function (can pass parameter   ###################



dptrig := ":X:" . dptrig
 ; msgbox %dptrig% as trigger right b4 HS defintion
	


;########################  This actually builds the hotstring: which in this cases calls a fxn  ##################################

try
{
		Hotstring(dptrig,Func("pasteDp").Bind(dpdp),"on") ; this hotstring defintion actually calls a function (that all
									; hotstring we use will call) BUT passes the dotphrase as a parameter for pasting.
}
dontmakeit: ; jump to here and skip making dot phrases for invalid ones.



}

	if (loadonlyone = 1) ; if we were just loading a single dot phrase via double click on list
		{
			loadonlyone := 0 ; reset this. We DON'T want to clear variables b/c were going to pre-pop the new dp screen
		}
		else
		{
		gosub clearDpVariables ; unless editing single phrase: we want to clear these once loaded and hotstrings made
		}

Return ; THIS is the end of the loadthem subroutine	

 ;############Inside the actual data file, the DP has to be on one line.. BUT we need convert back to MULTILINE##############################
DecompressDotP(dp)
{
 dp := StrReplace(dp,"{tab}","`t")    ;put back tabs
 dp := StrReplace(dp,"{Lbreak}","`n")    ;put back line breaks
return %dp%
}
;######################## end decompress   ##################################


;  trig := "::kk"
; dphrase := "Karolyn,`n"
/*

dphrase := "
(
Don't type the same text over and over: use 'dot phrases'. The dot phrase is 
so named because you define some shortcut or trigger text that you type and


)"


; hotstring(trig, dphrase)

trig := ":X:kk" ; an X hotstring
; Hotstring(trig,"pasteDp")    ; Calls the function pasteDp()


	; we should be able to loop around the line below as we load all hotstring files: that will instantiate all of the hotstrings



; dpOneline := StrReplace(dphrase, "`n" , "|" )
; dpOneline := StrReplace(dpOneline, "`t" , "{tab}" )

; msgbox %dpOneline%

*/



pasteDp(x)
{

oldclip := clipboardAll ; hold users current clip before we use clip

if (winactive("Booster Dot Phrases - Edit/New") or global suspenddp = 1)
		{
		thk := SubStr(A_thishotkey, 4) . " "
		sendraw %thk%
	   ;  splashTextOn ,150 ,100, CPRS Booster, Dot Phrases Disable When Edit Screen Open.
		; sleep 2000
		; SplashTextOff

		}
		else
		{
	
		sleep 100
		clipboard := x
	
		; MsgBox, 262144, CPRS Booster, %clipboard%
		     sleep 350 ; this is a giant pain; too short fails to get to clipboard
		  send  ^v
		
			sleep 1200
		clipboard := oldclip
	
		}
		

}


;############################### END Hotstring LOAD    ###########################



;############################### Create ListView of dotphrases    ###########################


dplist: ; START dp list sub routine

; should be able to load all the include files in the dotphrase directory. Then if someone creates a new dotphrase during running: we 
       ; can (1) change file or write new one but also (2) change or add the hotstring directly in the program w/o include reload.

; onedrivelocalDot = C:\Users\%A_UserName%\OneDrive - Department of Veterans Affairs\CPRSBooster\DotPhrases\ ; This will be created first time through even w/o CTRLH

gosub clearDpVariables


gui, 12: destroy ; just in case we have one of these
Gui, 12:  Font, s10, Verdana 
Gui, 12:  Font, Bold
Gui, 12:  Add, Text,x350, Booster dot phrases work in ANY program -- not just CPRS
Gui, 12:  Font, Norm	

; Create the ListView with two columns, Name and Size:

Gui, 12:  Add, ListView, x50 y+20 r23 w1000 altsubmit vMyFileList gMyListView checked,Share?|   Dot Phrase      |Full Text  (The text that is inserted)            | Category        |  Description                |          Author      | fn

; Gather a list of file names from a folder and put them into the ListView:
; msgbox %onedrivelocalDot%*.*

Loop, %onedrivelocalDot%*.*
 {
; we need to parse the filename

;			************loop within the file finding loop. Internal loop parses the filename of each file.

	FNametoParse :=	A_LoopFileName
	
	;############################### We want to put most Fn illegal back here to get column length correct ###########################
   ; FNametoParse := PutIllegalBack(FNametoParse) ; must WAIT until later to put semicolon back b/c it's the delimiter

	
	;######################## We are parsing the filename with semicolon delimiter   ##################################
	Loop, parse, FNametoParse, `;    
			{
				; MsgBox, block number %A_Index% is %A_LoopField%.
				
				 if (A_Index = 1) 
					{
					dpdesc := PutIllegalBack(A_LoopField)
					dpdesc := SubStr(dpdesc, 8, 50 )
				
				 	;msgbox %dpdesc%
					}
					
				 if (A_Index = 2) 
					{
					dptrig := PutIllegalBack(A_LoopField)
					dptrig := SubStr(dptrig, 14, 30 )
					
					 ;msgbox %dptrig%
	
					}
					
				 if (A_Index = 3) 
					{
					
					dpdp := PutIllegalBack(A_LoopField)
					dpdp := SubStr(dpdp, 13, 70 )
		
					 ;msgbox %dpdp%
					}
					
				 if (A_Index = 4) 
					{

					dpcat := PutIllegalBack(A_LoopField)
					dpcat := SubStr(dpcat, 8, 30 )
				
					; msgbox %dpcat%
					; dpcat := PutIllegalBack(dpcat)
			
					}
				if (A_Index = 5) 
					{

					dpAuth := SubStr(A_LoopField, 13,8)
				
					}
					
				
			}
Gui, 12: default

paddedDptrig := "  " . dptrig

    LV_Add("",,paddeddptrig,dpdp,dpcat,dpdesc,dpAuth,A_LoopFileName)
	
	
	}  ; end of loop through all files in directory

; LV_ModifyCol()  ; Auto-size each column to fit its contents.
; LV_ModifyCol(2, "Integer")  ; For sorting purposes, indicate that column 2 is an integer.
LV_ModifyCol(1, "AutoHdr")
LV_ModifyCol(2, "AutoHdr")
LV_ModifyCol(3, "AutoHdr")
LV_ModifyCol(4, "AutoHdr")
LV_ModifyCol(5, "AutoHdr")
LV_ModifyCol(6, "AutoHdr")
LV_ModifyCol(7, 0) 



; Display the window and return. The script will be notified whenever the user double clicks a row.

Gui, 12:  Add, Text,x50 y530 , To EDIT/DELETE: Right Click OR Double click on item above
Gui, 12:  Add, Text,, To SORT dot phrases above click on a column header. 
Gui, 12:  Add, Button, x50 y600  w200 h30 , Create New Dot Phrase!

if (global suspenddp = 1)
	{
	Gui, 12:  Add, Button, x870 y600  w200 h30, Reactivate All Dot Phrases
	}
	else
	{
	Gui, 12:  Add, Button, x870 y600  w200 h30 , Suspend All Dot Phrases
	}

Gui, 12:  Add, Button, x870 y640  w200 h30 gRestoreDP , Restore Missing Dot Phrases
Gui, 12:  Add, Button, x350 y600  w400 h30 gNatDPlib , **NATIONAL DOT PHRASE LIBRARY**


Gui, 12: Font, cBlue underline s10, Verdana
Gui, 12: Add, Text, gopenVideoscreen x870 y550 w400 R2, What the heck is a dot phrase?
Gui, 12: Font, Norm


Gui, 12:  Show, x50 y50 w1100 h685, Booster Dot Phrases: Your Dot Phrases
return ; gui 12 return

return ; dplist gosub return


;############################################################################################
;#################RESTORE MISSING DP from (1) Desktop Archive###########################################
;#####################(2) C users directory#######################################################################

RestoreDp:
	
EnvGet, userprofile, USERPROFILE
backupRoot := A_Desktop "\CPRSBoosterBackup"
dataBackupFolder := backupRoot "\Datafilebackup"
dotPhrasesBackupFolder := backupRoot "\DotPhrasesBackup"
onedrivelocalRestore := "C:\Users"
onedrivelocalDotPhrasesPattern := "OneDrive - Department of Veterans Affairs\CPRSBooster\DotPhrases"

; CAREFUL: SIMILARLY NAMED VARIABLE TO ONEDRIVELOCALDOTPHRASES elsewhere BUT DIFFERENT
onedrivelocalDotPhrases := userprofile . "\" . onedrivelocalDotPhrasesPattern

; Create an object to store filenames and their corresponding full paths for all user files
AllUsersPathFiles := {}

; Loop through each user directory in C:\Users\
Loop, Files, C:\Users\*, D  ; D flag to search for directories (i.e., user directories)
{
    currentUserPath := A_LoopFileFullPath "\OneDrive - Department of Veterans Affairs\CPRSBooster\DotPhrases"
    
    ; Now loop through files in the constructed path
    Loop, Files, %currentUserPath%\*.bstr, R
    {
        ; Store each filename as the key and full file path as the value in the object
        AllUsersPathFiles[A_LoopFileName] := A_LoopFileFullPath
    }
}

; Create an object to store the active dot phrase files
ActiveDotPhraseFiles := {}

; Loop through active dot phrase files in the OneDrive directory and store them in ActiveDotPhraseFiles object
Loop, %onedrivelocalDotPhrases%\*.bstr, R
{
    ActiveDotPhraseFiles[A_LoopFileName] := A_LoopFileFullPath
}

; Initialize counters for added and updated files
filesAdded := 0
filesUpdated := 0

; Compare each file in AllUsersPathFiles with those in ActiveDotPhraseFiles
for key, fullPath in AllUsersPathFiles
{
    if (!ActiveDotPhraseFiles.HasKey(key)) ; File not found in active dot phrase directory, so copy it
    {
        FileCopy, %fullPath%, %onedrivelocalDotPhrases%\
        filesAdded++
    }
    else
    {
        ; If file exists, compare modification dates
        FileGetTime, modTimeAllUsers, %fullPath%, M ; Get the modification time for the file in AllUsersPathFiles
        activeFilePath := ActiveDotPhraseFiles[key]
        FileGetTime, modTimeActive, %activeFilePath%, M ; Get the modification time for the file in ActiveDotPhraseFiles

        if (modTimeAllUsers > modTimeActive) ; If the AllUsers file is newer, update the active directory
        {
            FileCopy, %fullPath%, %onedrivelocalDotPhrases%\, 1   ; overwrite the existing file
            filesUpdated++
        }
    }
}

;;;; DONE WITH FINDING MISSING FILES AND RESTORING THEM from ALL USERS DIRECTORY
; Step 1: Repopulate ActiveDotPhraseFiles to ensure it's up to date after recent modifications
ActiveDotPhraseFiles := {} ; Clear the object
Loop, %onedrivelocalDotPhrases%\*.bstr, R
{
    ActiveDotPhraseFiles[A_LoopFileName] := A_LoopFileFullPath
}

; Step 2: Check the desktop backup folder and update active dot phrase files as needed
desktopbackupFiles := {} ; You can store these files if necessary, though it may not be needed for this step

Loop, %dotPhrasesBackupFolder%\*.bstr, R
{
    desktopbackupFiles[A_LoopFileName] := A_LoopFileFullPath ; Store the desktop backup files

    ; Check if the file from desktop backup is in the active directory
    if (!ActiveDotPhraseFiles.HasKey(A_LoopFileName)) ; File not found in active dot phrase directory
    {
        FileCopy, %A_LoopFileFullPath%, %onedrivelocalDotPhrases%\
        filesAdded++
    }
    else
    {
        ; If file exists, compare modification dates
        FileGetTime, modTimeBackup, %A_LoopFileFullPath%, M ; Get the modification time for the desktop backup file
        activeFilePath := ActiveDotPhraseFiles[A_LoopFileName]
        FileGetTime, modTimeActive, %activeFilePath%, M ; Get the modification time for the active file

        if (modTimeBackup > modTimeActive) ; If the desktop backup file is newer, update the active directory
            {
                FileCopy, %A_LoopFileFullPath%, %onedrivelocalDotPhrases%\, 1 ; Overwrite the existing file
                filesUpdated++
            }
    }
}

; Display the result
; MsgBox, %filesAdded% file(s) were added and %filesUpdated% file(s) were updated in the active files directory.


	; Show the number of files 'restored' in a message box
    if (filesAdded = 0)
        {
            MsgBox, 262144, CPRS Booster, Did not find any missing dot phrases`n`n Try going to Ctrl-H and click the troubleshooting link for more ideas. 
        }
        else
        {
        MsgBox, 262144, CPRS Booster, %filesAdded% files restored. `n`n YOU MUST RESTART CPRS Booster (double click destop icon or use your normal Booster start procedure) to use restored dot phrases.`n`n If you still see missing dot phrases, try going to Ctrl-H ---> Troubleshooting for more ideas.
       ; run, \\v23.med.va.gov\apps\GUI\Local_Site_GUI\MIN\CPRSBOOSTER\CPRSBooster.exe
        }
	
return
;############################################################################################
;###############End Restore Missing Dot phrases#####################################
;############################################################################################


NatDPlib:  ; this is the first step if we are uploading or going to lib

AtleastoneUploaded := 0  ; initialize. Don't show 'thank you screen if none uploaded'.

  IfNotExist, %NationalLibDPFiles%
  {
  
  Gosub Gui36

  }
  

  
Gui, 12: default ; Set the 12 GUI as default
RowCount := LV_GetCount() ; Get the number of rows in the ListView

CheckedCount := 0 ; Initialize the count of checked rows
FailedDotphrases := "" ; Initialize variable to hold names of failed dotphrases.



; Set row index to 0 to start the loop
RowIndex := 0
Loop, %RowCount% ; Loop through all the rows to check if any row is checked and upload if needed
{
    RowIndex := LV_GetNext(RowIndex, "C") ; Get the next checked row
    if !RowIndex ; If no more checked rows, break the loop
        break

    CheckedCount++ ; Increment the count of checked rows
    LV_GetText(Filename, RowIndex, 7) ; Retrieve the filename from the 7th column of the current row
    DotphraseFile := Filename ; Set the filename as DotphraseFile
	
	
	if (A_Index < 2) ; only do this once
	{
			gosub profilecheck
			
			if (profileerror = 1)
			{
			profileerror := 0
			return ; user would not create profile
			}
			
			; Read the user profile data  
			UserProfileData := ReadUserProfile(UserProfileFile)
			gosub importUserProfile ; get all the user profile variables.
			gosub gui42 ; check with user before final upload
			
			WinWaitClose, BOOSTER: CONFIRM PROFILE
			gui, 42: Destroy
			if (cancelupload = 1)
			{
			cancelupload := 0
			return
			}
			
			
	}

    gosub, Uploadit ; Call the Uploadit subroutine
	LV_Modify(RowIndex, "-Check") ; Uncheck the current row after uploading

	

}

if (CheckedCount = 0) ; If no row is checked, go to
		{
			; gosub, gui38   ;? should be goto ; this is the do you want to GIVE or GET GUI
			goto gui38
		
		}
		else ; person is uploading to library (already did above)
		{
		
			if (FailedDotphrases != "") ; If there are any failed dotphrases
			{
				MsgBox, 262144, CPRS Booster, The following dotphrases failed to be uploaded:`n%FailedDotphrases%
			}
			else
			{
					if (AtleastoneUploaded > 0)
					{
						MsgBox, 262144, CPRS Booster, Done! `n`nTHANKS for making someone else's job easier by sharing your dot phrases!
					}
			}
			
		gosub CheckSiteCodeList ; whether they succeeded or failed: let's get their site code on dropdown nat lib

		
		}


GuiControl, Focus, MyFileList ; MY filelist= mine vs FILElist is the LV on the NATIONal page but we might be back at our page
return




12ButtonCreateNewDotPhrase!:

gui, 12: Destroy ; get rid of this while making new
gosub clearDpVariables
gosub GuiNewDot
return




12ButtonReactivateAllDotPhrases:

global suspenddp := 0

gui, 12: Destroy
 gosub dplist
 winminimize, Booster Dot Phrases: Your Dot Phrases
 
SplashTextOn ,150 ,100, CPRS Booster, Dot Phrases Reactivated
sleep 2000
SplashTextOff



return

12ButtonSuspendAllDotPhrases:
global suspenddp := 1

gui, 12: Destroy
 gosub dplist
 winminimize, Booster Dot Phrases: Your Dot Phrases
SplashTextOn ,150 ,100, CPRS Booster, Dot Phrases Suspended!
sleep 2000
SplashTextOff


return




MyListView:


; MsgBox, % "The GUI event was: " A_GuiEvent

if (A_GuiEvent = "DoubleClick")
{
    LV_GetText(fname, A_EventInfo, 7)  ; Get the text from the row's lastfield.
     ; msgbox You double-clicked row number %A_EventInfo%. Text: "%RowText%"

gosub openeditgui
}

if (A_GuiEvent = "RightClick")
{
    LV_GetText(fname, A_EventInfo, 7)  ; Get the text from the row's last field.
    ; msgbox You double-clicked row number %A_EventInfo%. Text: "%RowText%"

Menu, RtclickMenu, Add, Edit, GoEdit
Menu, RtclickMenu, Add, Delete, GoDelete
Menu, RtclickMenu, Show
}

return


OpenEditGui:

	loadonlyone := 1
	wecamefromlistview := 1 ; lets GuiNewDot know we are editing existing dp.
	gosub clearDpVariables ; start clean	
	gosub loadthem ; load the one to edit into memory
	
	gui, 12: Destroy ; get rid of this while editing.
	gosub GuiNewDot ; open the editor screen
return

goEdit:
gosub openeditgui
return

goDelete:
	MsgBox, 262145, CPRS Booster, DELETE Dot Phrase?
	IfMsgBox OK
	{
	gosub deleteDp
	gui, 12: Destroy ; get rid of this while editing.
	sleep 2000
	gosub dplist
	}

return

DeleteDp:
	; fname should have been set prior to this.
	loadonlyone := 1 ; we need to load the trigger phrase b4 we delete the file so we can inactivate dp
	gosub clearDpVariables ; start clean	
	gosub loadthem ; load the one to edit into memory: need dptrip
	filetodelete := onedrivelocalDot . fname ; fname is set in listview
	filedelete, %filetodelete%
	
	try
	{
	Hotstring(dptrig,Func("pasteDp").Bind(dpdp),"off") ;shut off hotstring even after deleted file it's in memory
	}
	
	gosub loadthem ; need to reload all b/c this could be a duplicate and need it's partner back
	
	SplashTextOn ,150 ,100, CPRS Booster, Deleted!
	sleep 1000
	SplashTextOff
	gosub clearDpVariables
return




12GuiClose:  ; Indicate that the script should exit automatically when the window is closed.
; msgbox I don't think you want to do this.
winminimize, Booster Dot Phrases: Your Dot Phrases

SplashTextOn ,150 ,100, CPRS Booster, Dot Phraser Now In Windows Tray Below
sleep 1400
SplashTextOff
   ; Gui, 12: Destroy 
return

;----------------Subroutine to check to see if contributor's site code is in nat lib site list file.


CheckSiteCodeList:
    ; Read the content of the file
    FileRead, siteList, %Librarysitelistpath%

    ; Remove carriage returns and new lines to ensure clean comparison
    siteList := StrReplace(siteList, "`r", "")
    siteList := StrReplace(siteList, "`n", "")

    ; Check if sitecode is in the string
    if (!InStr(siteList, sitecode))
    {
        ; If not found, append the sitecode to the file
        FileAppend, |%sitecode%, %Librarysitelistpath%
      
    }

return

;----------------------------





;########################Put ILLEGAL Characters back in before display Filename fragments ##################################


PutIllegalBack(x)
{
 x := StrReplace(x,"{less}","<")    ;Put ILLEGAL Characters back in before display Filename fragments
 x := StrReplace(x,"{greater}",">")    ;Put ILLEGAL Characters back in before display Filename fragments
 x := StrReplace(x,"{colon}",":")    ;Put ILLEGAL Characters back in before display Filename fragments
 x := StrReplace(x,"{quote}","""")    ;Put ILLEGAL Characters back in before display Filename fragments
 x := StrReplace(x,"{fslash}","/")  
 x := StrReplace(x,"{bslash}","\")   
 x := StrReplace(x,"{pipe}","|")  
 x := StrReplace(x,"{qstmrk}","?")    
 x := StrReplace(x,"{star}","*")  
 x := StrReplace(x,"{semi}",";") ; not ilegal but is the filename parsing delimiter

return %x%
}


;########################GUIs to Get to National Library ##################################


; GUI 38
gui38:
Gui, 38:Destroy
Gui, 38:Font, S14 CDefault Bold, Verdana
Gui, 38:Add, Text, x122 y219 w420 h30 , GET Dot Phrases from the World
Gui, 38:Add, Text, x122 y99 w490 h30 , GIVE Dot Phrases to the World (Please Do!)
Gui, 38:Font, S12 CDefault, Verdana
Gui, 38:Add, Button, x172 y49 w0 h140 , Button
Gui, 38:Font, S11 CDefault, Verdana
Gui, 38:Add, Button, x162 y149 w380 h40 gShareButton , Click to Share Your Dot Phrases
Gui, 38:Add, Button, x162 y269 w380 h40 gViewLibraryButton, Click to View National Dot Phrase Library
Gui, 38:Font, S15 CDefault Bold, Verdana
Gui, 38:Add, Text, x22 y39 w150 h30 , I WANT TO:
Gui, 38:Font, S10 Cblue Underline, Verdana
Gui, 38:Add, Text, x240 y9 w520 h20 gShowGui39, Should you share your dot phrases: You Betcha! Click For Info
Gui, 38:Show, x200 y300 h379 w734, Booster
Return

ShowGui39:
    Gosub, Gui39
Return

ShareButton:
 Gui, 38:Destroy
Gosub GUI40
Return

ViewLibraryButton:
Gui, 38:Destroy
goto gui34

    
Return

38GuiClose:
  Gui, 38:Destroy
  return
 

; GUI 39
Gui39:
 
    Gui, 39:Font, S12 CDefault Bold Italic, Verdana
    Gui, 39:Add, Text, x222 y19 w490 h30 , The world cannot survive without dot phrases
    Gui, 39:Add, Text, x132 y109 w0 h0 , Text
    Gui, 39:Font, S12 CDefault, Verdana
    Gui, 39:Add, Text, x392 y49 w210 h20 , - Anonymous
    Gui, 39:Add, Text, x132 y49 w-80 h130 , Text
    Gui, 39:Font, S13, Verdana

    instru := "
    (


Yes! We need your dot phrases!

No dot phrase is too small or too stupid to share. Why? 

The National Library is set up with advanced filters so that
even people in very specific niches can find relevant dot phrases.
So, if you are a social worker in the Anchorage VA with a dot 
phrase about helping people with fishing injuries: We'll take it! 
Only people interested in your dot phrase will see it (by virtue
of their library search process). 

We all need to pool our efforts here.

More is better. Just do it!


    )"

    Gui, 39:Add, Text, x92 y139 w700 h580 , %instru%
    Gui, 39:Show, x127 y87 h579 w850, Just do it!
Return

39GuiClose:
  Gui, 39:Destroy
  return
 
gui40:
 Gui, 40:Font, S12 CDefault, Verdana
instru := "
(
To share your dot phrases:

Within YOUR personal list of dot phrases, the left-most
column on the screen is the 'share' column.

Use the checkboxes in this column to select one or more
dot phrases to upload to the national library.

THEN click the **NATIONAL DOT PHRASE LIBRARY*** button 
again and the selected dot phrases will be shared.

In the future, you can avoid these instructions by
simply checking phrases in the share column BEFORE 
hitting the **NATIONAL DOT PHRASE LIBRARY*** button.
)"
Gui, 40:Add, Text,, %instru%
Gui, 40:Add, Button, Default g40OKButton y+20, OK
Gui, 40:Show, w560 h390, Instructions for Sharing Dot Phrases
Return

40GuiClose:
40OKButton:
Gui, 40:Destroy
sleep 100
Gui, 12: default ; Set the 12 GUI as default
; winactivate, Booster Dot Phrases: Your Dot Phrases
sleep 200
GuiControl, Focus, MyFileList ; move the focus back to my dot phrases; ? Not working

Return



;########################END OF GUIs to Get to National Library ##################################



;############################################################################################
;######################Uploading Local Dot phrase to National Library#########################################
;############################################################################################


;*******************first check profile (this sub routine is called from above***
;############################################################################################
;########################CHECK TO MAKE SURE THEY HAVE A PROFILE BEFORE DP UPLOAD#############################################
;############################################################################################

profilecheck:


profileerror := 0
if (!FileExist(UserProfileFile)) ; No profile is created
{

gosub gui41
WinWaitClose, CPRS Booster: Setup   ; this is actually just to user message: need profile setup

gosub gui35 ; sets up the profile
    ; Wait until Gui35 is closed
    WinWaitClose, Your Dot Phrase Profile
	
	if (!FileExist(UserProfileFile))
	{
	
	profileerror := 1
	return  ; if they didn't do profile: no go.
	}
	
}
else ; they already have a profile set up
{
; show them their profile/change prn


}

return

;;;********************************************




;############################################################################################
;###########################GUI 41: message to set up profile##################################################
;############################################################################################

gui41: 


instru := "
(
Create a profile:

The next brief step is a one-time thing to help
others with jobs like yours FIND your dot
phrases. Otherwise, your hard work is the 
lost needle in the dot phrase haystack.
Click OK to proceed ...
)"
Gui, 41: Font, s12, Verdana  ; Set Verdana
Gui, 41: Add, Text, X5 Y5 w600 R15, %instru%
Gui, 41: Add, Button, X5 Y165, OK ; Button to submit the information
Gui, 41: Show, x345 y400 w400 h200 , CPRS Booster: Setup
return ; return for Gui 41



41GuiClose:
41ButtonOK:
   
Gui, 41: Destroy ; Destroy the GUI to get it out of the way
 
 SplashTextOn ,150 ,100, CPRS Booster, Working....
sleep 500
SplashTextOff
return

;############################################################################################
;######################Gui42 Final Profile OK before upload dot phrase#######################


gui42:
Gui, 42:Font, S12 CDefault Bold Underline, Verdana ; Font for specific texts
Gui, 42:Add, Text, x32 y109 w170 h20 , Job Type
Gui, 42:Add, Text, x242 y109 w170 h20 , Department (ICC)
Gui, 42:Add, Text, x472 y109 w190 h20 , Specfic Job/Field
Gui, 42:Add, Text, x700 y109 w190 h20 , In or Outpatient

gui, 42:Font
Gui, 42:Font, S11 CDefault, Verdana ; Font for buttons
Gui, 42:Add, Button, x22 y199 w270 h40 g42StartUpload, This is Correct: Start Upload
Gui, 42:Add, Button, x350 y199 w270 h40 g42EditProfile, Wait: I need to edit my profile
Gui, 42:Add, Button, x700 y199 w100 h40 g42Cancel, Cancel

gui, 42:Font
Gui, 42:Font, S11 CDefault, Verdana ; Font for other texts


Gui, 42:Add, Text, x32 y139 w170 h20 , %JobType%
Gui, 42:Add, Text, x242 y139 w170 h20 , %ICCType%
Gui, 42:Add, Text, x472 y139 w190 h20 , %Department%
Gui, 42:Add, Text, x700 y139 w190 h20 , %UserInptOutpt%

Gui, 42:Font, S12 CDefault Bold , Verdana ; Font for specific texts
Gui, 42:Add, Text, x22 y19 w710 h30 , Your Profile Information: Will be used to help people find your dot phrases
Gui, 42:Add, Text, x100 y59 w140 h30 , %A_UserName%
Gui, 42:Add, Text, x522 y59 w190 h30 , %userLastname%
Gui, 42:Add, Text, x362 y59 w140 h30 , %userFirstname%

Gui, 42:Show, x138 y187 h285 w900, BOOSTER: CONFIRM PROFILE
Return

42StartUpload:
; Handler code for "This is Correct: Start Upload" button
Gui, 42:Destroy

Return

42EditProfile:
Gui, 42:Destroy
gosub Gui35
cancelupload := 1
WinWaitClose, Your Dot Phrase Profile

instru := "
(

Your profile was updated.

To upload the selected dotphrase, click
on the 'National Dot Phrase Library' button 
again.

)"
MsgBox, 262144, CPRS Booster, %INSTRU%
Return

42Cancel:
; Handler code for "Cancel" button
Gui, 42:Destroy
cancelupload := 1
Return

42GuiClose:
Gui, 42:Destroy
Return





;############################################################################################
;########################################end GUI 42########################################
;############################################################################################





;############################################################################################
;############################################################################################
;############################################################################################

Uploadit:

; Desc = 24 BP{colon} NORMAL; Dotphrase = .24nl; Fulltext = I hope you are doing well!  I am ha; Cat = Letters; Authr = VHAMINBockA
FullDPfilepath := onedrivelocalDot . dotphrasefile 


; Pull the dotphrase out of the filename b/c we may need to display to user if Sensative data pop up is shown
RegExMatch(FullDPfilepath, "Dotphrase = (.*?);", DPwithSensitiveData)

; DPwithSensitiveData1 will contain the extracted text
; MsgBox % "Extracted data: " DPwithSensitiveData1


; Read the dotphrase file
DotphraseData := ReadDotphraseFile(FullDPfilepath)

; Check for potential sensitive information.
SensitiveInfoFound := false
SensitiveInfo := ""
; Match SSNs
if (RegExMatch(DotphraseData, "\b\d{3}-\d{2}-\d{4}\b", matchSSN))
{
    SensitiveInfoFound := true
    SensitiveInfo .= "Potential SSN: " matchSSN "`n"
}

; Extracting Current Date
FormatTime, currentTime,, yyyyMMdd
fifteenYearsAgo := SubStr(currentTime, 1, 4) - 15 . SubStr(currentTime, 5)

; Match Dates
; This regex tries to match dates in formats like MM/DD/YYYY, MM/DD/YY, DD-MM-YYYY, or DD-MM-YY
; with 1 or 2 digits for month and day and 2 or 4 digits for the year.
if (RegExMatch(DotphraseData, "\b(?:\d{1,2}[\/.-]\d{1,2}[\/.-]\d{2,4})\b", matchDate))
{
   ; MsgBox, Match Found: %matchDate% ; Debug message box
    
    ; Extract the date components
    if (RegExMatch(matchDate, "(\d{1,2})[\/.-](\d{1,2})[\/.-](\d{2,4})", dateComponents))
    {
        ; MsgBox, Components: %dateComponents1%-%dateComponents2%-%dateComponents3% ; Debug message box
        
        day := dateComponents1
        month := dateComponents2
        year := dateComponents3
        
        ; If the year is in 2-digit format, convert it to 4-digit format
        if (StrLen(year) = 2)
        {
            thisYearShort := SubStr(A_Year, 3, 2) ; Last 2 digits of the current year
            thisYearCentury := SubStr(A_Year, 1, 2) ; First 2 digits of the current year (the century)
            year := (year <= thisYearShort) ? (thisYearCentury . year) : ((thisYearCentury - 1) . year)
            ; MsgBox, Converted Year: %year% ; Debug message box
        }
        
        ; Create the string for comparison
        compareDate := Format("{:04}{:02}{:02}", year, month, day)
       ;  MsgBox, Compare Date: %compareDate% ; Debug message box
        
        ; Compare the constructed date string to the date 15 years ago
        if (compareDate < fifteenYearsAgo)
        {
           ;  MsgBox, Sensitive Date Detected ; Debug message box
            SensitiveInfoFound := true
            SensitiveInfo .= "Potential Patient Birthdate: " matchDate "`n"
        }
    }
}



; Check for the word "password"
if (InStr(DotphraseData, "password", true))  ; true means case-insensitive
{
    SensitiveInfoFound := true
    SensitiveInfo .= "      Detected the word: password`n"
}

; Check for the word "PIV"
if (InStr(DotphraseData, "PIV", true))  ; true means case-insensitive
{
    SensitiveInfoFound := true
    SensitiveInfo .= "Detected the word: PIV`n"
}


if (SensitiveInfoFound)
{
    MsgBox, 4, Sensitive Information Found!!, % "This file appears to contain the following sensitive information:`n`n" 
    . SensitiveInfo 
	. "`n,`nFound within file for the dotphrase " . DPwithSensitiveData1
    . "`n`nDo you wish to continue with the upload?"
    
    IfMsgBox, No
    {
        Return ; If user selects "No", the subroutine is exited, and the file is not copied.
    }
}

; Construct the destination path where the file is to be copied.
DestinationPath := NationalLibDPFiles . dotphrasefile

; Read the user profile data
UserProfileData := ReadUserProfile(UserProfileFile)



; Create an index row
IndexRow := CreateIndexRow(DotphraseData, UserProfileData)

IndexRow := Indexrow . "|" . DotphraseFile    ; append the file name of dotp into the index

; Remove line breaks and carriage returns
IndexRow := StrReplace(IndexRow, "`n", "")  ; Removes line breaks (`n)
IndexRow := StrReplace(IndexRow, "`r", "")  ; Removes carriage returns (`r)

SiteCode := SubStr(A_Username, 4, 3)

indexrow := sitecode . "|" . indexrow


/*
; Append the index row to the index file
FileAppend, %IndexRow%`n, %IndexFile%

; Copy the file from FullDPfilepath to NationalLibDPFiles, and overwrite if it exists.
FileCopy, %FullDPfilepath%, %DestinationPath%, 1 ; 1 indicates to overwrite if the file already exists.
*/


; Read the entire content of the index file into the variable IndexContent
FileRead, IndexContent, %IndexFile%

; Check if the row already exists in the content of the index file
if (InStr(IndexContent, IndexRow) or (IndexRow = IndexContent)) 
{
    ; If the row already exists, display a message box
   
	MsgBox, 262144, CPRS Booster, Dot Phrase already in the library
	
}
else 
{



		timeoutDuration := 7000 ; 7 seconds timeout
		retryDelay := 200 ; 0.2 seconds delay between retries
		maxAttempts := timeoutDuration // retryDelay ; Calculate maximum number of attempts
		attempts := 0 ; Counter for the number of attempts made
		rowFound := false ; Flag to check if row is found

		Loop {
			; Increase the attempt counter
			attempts++

			; Write the row to the index file
			FileAppend, %IndexRow%`n, %IndexFile%
			sleep 100
			; Read the content of the index file
			FileRead, fileContent, %IndexFile%
			
			; Check if IndexRow is in the content of the file
			If InStr(fileContent, IndexRow) {
				rowFound := true
				break ; Row found, exit the loop
			}
			
			; Wait for 0.2 seconds before trying again
			Sleep, retryDelay
			
			; Check if the maximum number of attempts has been reached
			If (attempts >= maxAttempts) {
				break ; Max attempts reached, exit the loop
			}
		}

		; if (rowFound) {
		; 	MsgBox, The data was successfully written to the index file.
		; } else {
		; 	MsgBox, The data could not be written to the index file after %maxAttempts% attempts.
		;}


/*
    ; If the row doesn't exist, append it to the index file
    FileAppend, %IndexRow%`n, %IndexFile%
	
	

*/
	
	
	AtleastoneUploaded++
	
	
	
	
}

; Copy the file from FullDPfilepath to NationalLibDPFiles, and overwrite if it exists.
FileCopy, %FullDPfilepath%, %DestinationPath%, 1 ; 1 indicates to overwrite if the file already exists.








; Check if any error occurred during copy
if ErrorLevel ; If ErrorLevel is non-zero, an error occurred
{


    ; Extract dotphrase from the filename.
    if RegExMatch(DotphraseFile, "Dotphrase\s*=\s*(.*?);", match)
        FailedDotphrases .= match1 . "`n" ; Add failed dotphrase to the list, followed by a newline character.

}


Return ; End of Uploadit subroutine

;############################################################################################
;########################End Upload local Dot phrase to National Library##############################################################
;############################################################################################


;############################################################################################
;################FUNCTIONS To Support National Library Upload#############################################################
;############################################################################################


; Function to read the dotphrase file and extract relevant data
ReadDotphraseFile(DotphraseFile) {
    DotphraseData := ""
    FileRead, DotphraseData, %DotphraseFile%
    return DotphraseData
}

; Function to read the user profile data and extract relevant data
ReadUserProfile(UserProfileFile) {
    UserProfileData := ""
    FileRead, UserProfileData, %UserProfileFile%
    return UserProfileData
}

; Function to create an index row from the dotphrase and user profile data
CreateIndexRow(DotphraseData, UserProfileData)
 {
    ; Extract relevant fields from the dotphrase file (customize as needed)
    upldDpShortDesc := ""
    upldDpTrigger := ""
    upldDpFulltext := ""
    upldDpCat := ""
    Loop, Parse, DotphraseData, `n
    {
        if (A_Index = 1)
            upldDpShortDesc := A_LoopField
        else if (A_Index = 2)
            upldDpTrigger := A_LoopField
        else if (A_Index = 3)
			upldDpFulltext := SubStr(A_LoopField, 1, 250)
        else if (A_Index = 4)
            upldDpCat := A_LoopField
    }


	gosub importUserProfile
   
    ; Create the index row in pipe-delimited format
    IndexRow := upldDpShortDesc "|" upldDpTrigger "|" upldDpFulltext "|" upldDpCat "|" UserFirstName "|" UserLastName "|" JobType "|" ICCType "|" Department "|" Userfullname "|" UserInptOutpt
    return IndexRow
}



; subroutine to load userprofile into variables

importUserProfile:


; Read the user profile data
UserProfileData := ReadUserProfile(UserProfileFile)
; MsgBox, 262144, CPRS Booster, text here

 ; Extract relevant fields from the user profile data (assuming pipe-delimited format)
    UserFirstName := ""
    UserLastName := ""
    JobType := ""
    ICCType := ""
    Department := ""
    VAUsername := ""
    UserInptOutpt := ""
    
    Loop, Parse, UserProfileData, |
    {
        if (A_Index = 1)
            global UserFirstName := A_LoopField
        else if (A_Index = 2)
            global UserLastName := A_LoopField
        else if (A_Index = 3)
           global JobType := A_LoopField
        else if (A_Index = 4)
            global ICCType := A_LoopField
        else if (A_Index = 5)
            global Department := A_LoopField
        else if (A_Index = 6)
            global VAUsername := A_LoopField
        else if (A_Index = 7)
            global UserInptOutpt := A_LoopField
    }
	
	global userfullname := userLastname . ", " . userFirstname

return


;############################################################################################
;######################END NATIONAL Library functions###############################################################
;############################################################################################



;############################################################################################
;######################START Dot Phrase National Library GUI###############################################################
;############################################################################################


Gui34:
Gui, 34: destroy ; avoid duplicates of the national GUI
gui, 12: Destroy ; get rid of personal dot phrase window


SplashTextOn ,150 ,100, CPRS Booster, Loading NATIONAL Library
sleep 1000
SplashTextOff

MyData := CsvWithHeadersToArray(DPIpath)


-----------------------------------
Gui, 34: Font, cBlue underline s10, Verdana
Gui, 34: Add, Text, x170 y91 w100 h20 gsearchtips , (Search tips)
gui, 34: Font
Gui, 34: Font, S11 CDefault, Verdana
Gui, 34: Add, Text, x282 y89 w100 h20 , VA Location
Gui, 34: Add, Text, x402 y89 w130 h20 , Employee Type

;############################################################################################
;#####################BUILD EMP TYPE DROP DOWN#######################################
;############################################################################################

 ; ***************************THESE NEXT THREE LINES build the dropdown
 

FileRead, ddtextemp, %emppath%
Sort, ddtextemp, D|
 

Gui, 34: Add, DropDownList, x402 y119 w130 h500 vddEmpType2 , ALL|%ddtextemp%   ; emp type


;############################################################################################
;#################BUILD ICC DROP DOWN#############################
;############################################################################################

 ; ***************************THESE NEXT THREE LINES build the*** ICC ***dropdown

FileRead, ddtextemp, %ICCpath%
Sort, ddtextemp, D|
; **********************


;############################################################################################
;#################BUILD SITE LOCATION DROP DOWN#############################
;############################################################################################

 ; ***************************THESE NEXT THREE LINES build the*** SITE ***dropdown

FileRead, ddTextSite, %Librarysitelistpath%
Sort, ddTextSite, D|
; **********************




Gui, 34: Add, DropDownList, gICCdd2 x552 y119 w140 h500 vddICC2, ALL|%ddtextemp%  ; ICC\Dept  ; item selected goes to ICCdd2 subroutine


Gui, 34: Add, Text, x572 y89 w100 h20 , Section/ICC



departdisplay := ddDepart("All")   ;first time paint this display all departments

Gui, 34: Add, DropDownList, x712 y119 w170 h500 vddDepart2, ALL|%departdisplay2%   ; Specific role

Gui, 34: Add, Button, x50 y40 gApplyFilters, Click to Apply Filters/Search


Gui, 34: Add, Text, x50 y89 w100 h20 , Search For:
Gui, 34: Add, Edit, x50 y119 w200 h30 vDPsearch 

OnMessage(0x100, "WM_KEYDOWN") ; WM_KEYDOWN message ; looks for enter key pressed in search box



Gui, 34: Add, Text, x712 y89 w140 h20 , Department/Role
Gui, 34: Font, S11 CDefault bold, Verdana
Gui, 34: Add, Text, x410 y9 w310 h30 , Booster National Dot Phrase Library
Gui, 34: Font
Gui, 34: Font, S11 CDefault, Verdana
Gui, 34: Add, Text, x450 y49 w240 h20 , Use Filter Drop Downs Below
Gui, 34: Add, Text, x800 y15 w280 h20 , Double Click Dot Phrase for Details
Gui, 34: Add, Text, x800 y35 w260 h20 , Right Click Dot Phrase to Delete

Gui, 34: Add, ListView, x22 y159 w1110 h470 altsubmit  vFilelist gMyListViewNL checked,    VA\Type\ICC\Dept        | Dot Phrase |Full Text  (The text that is inserted)                  | Category        |  Description                | Contributor                  | fn

Gui, 34:Default

; Index file headers: location|dpdesc|dptrigger|dptxt|dpcategory|FirstName|LastName|EmplType|ICC|Dept|UploadUser|InptOutpt|filename|


; Determine the length of the MyData array
ArrayLength := MyData.location.MaxIndex()  ; not sure this is needed



; Initialize an empty array to hold unique location values
;  UniqueLocations := {}


; Loop through the array using numeric index
For Index, _ in MyData.location
{
    LibOrigin := MyData.location[Index]
    LibDP := MyData.dptrigger[Index]
    LibFulltxt := MyData.dptxt[Index]
	LibFulltxt := DecompressDotP(LibFulltxt)  ; gets rid of {Lbreak} notation

    LibCat := MyData.dpcategory[Index]
    LibDesc := MyData.dpdesc[Index]
    LibAuth := MyData.uploaduser[Index]
    LibFile := MyData.filename[Index]
	
	

    LV_Add("", LibOrigin, LibDP, LibFulltxt, LibCat, LibDesc, LibAuth, LibFile)
}




Gui, 34: Add, DropDownList, x282 y119 w90 h600 vddLocation2 , ALL|%ddTextSite% 

; Gui, 34: Add, DropDownList, x282 y119 w90 h2000 vddLocation2 , ALL|%locationslist% 

;  Inpt/Outpt Dropdown
Gui, 34: Add, Text, x890 y89 w100 h20 , Inpt/Outpt
Gui, 34: Add, DropDownList, x890 y119 w100 h300 vInptStatus , ALL|Outpatient|Inpatient  ; INPT OUTPT DROPDOWN


LV_ModifyCol(1, "Sort")





; Add the new button at the bottom of the GUI
Gui, 34: Add, Button, x270 y640 w500 h30 gMoveToPersonalLibrary, Add Selected Dot Phrases To My Personal Library

Gui, 34: Show, x10 y10 h684 w1161, WELCOME TO THE BOOSTER NATIONAL DOT PHRASE LIBRARY
GuiControl, Focus, filelist 

Return

searchtips:

;############################################################################################
;########################start gui 43: Search Tips####################
;############################################################################################
SplashTextOn ,150 ,100, CPRS Booster, Hold On...
sleep 300
SplashTextOff

gui43:
 ; 

my_picturefile =%BoosterRoot%Pictures\Searchtips.PNG
Gui, 43: Add, Picture,w1100 h-1 , %my_picturefile%
Gui, 43: Show, x100 y125 w1125 h600 , Booster Tips ; Display the GU
return ; return for Gui 43

43GuiClose:
 Gui, 43: Destroy ; Destroy the GUI to get it out of the way
Return


;############################################################################################
;################################End GUI 43###########################################
;############################################################################################

return



;-----------------------------------------This deals with pressing enter key in searchterms box
WM_KEYDOWN(wParam, lParam)
{
    if (wParam = 9 AND A_GuiControl = "dotphrase") ; Tab was pressed in the edit control.
    {
	
        Send ^{Tab}  ; Insert a real tab character.
        return 0  ; Prevent the control from seeing this WM_KEYDOWN message.
    }
    else if (wParam = 0x0D) ; Enter was pressed
	{
			if WinActive("WELCOME TO THE BOOSTER NATIONAL DOT PHRASE LIBRARY")
			{
				Gui, 34:Show  ; Activate the GUI window.
				Sleep, 20  ; Wait for the window to be activated.
				ControlGetFocus, focusedControl, A  ; Get the focused control in the active window.
				; MsgBox, Enter was pressed. Focused control: %focusedControl%
				if (focusedControl = "Edit1")
				{
					Gosub, ApplyFilters
				}
				
			}
	}


    ; Otherwise, do nothing to allow this message to be processed normally.
}




34GuiClose:
Gui, 34: destroy

gui, 12: Destroy ; reload& repaint personal DP gui


SplashTextOn ,150 ,100, CPRS Booster, Reloading YOUR Dot Phrases
sleep 1000
SplashTextOff
gosub Loadthem
 gosub dplist
 
 
return


-----------------------------
MyListViewNL:

if (A_GuiEvent = "RightClick")
{
    LV_GetText(fname, A_EventInfo, 7)  ; Get the text from the row's last field.
    ;  msgbox You double-clicked row number %A_EventInfo%. File: "%Fname%"



LV_GetText(Deletelocation, A_EventInfo, 1)
LV_GetText(Deletedotphrase, A_EventInfo, 2)
LV_GetText(Deletefn, A_EventInfo, 7)


 

Menu, RtclickMenu, Add, Delete, DeleteFromNational
Menu, RtclickMenu, Show
}




if (A_GuiEvent = "DoubleClick")
{

RetrievedFileName :=""
   sleep 80
    ; Retrieve the selected row number
    LV_GetText(RetrievedFileName, A_EventInfo, 7) ; Assuming 'fn' is the 7th column.

sleep 80
    ; Concatenate and remove potential carriage returns or newlines
    retrievedfilename := NationalLibDPFiles . retrievedfilename
    retrievedfilename := StrReplace(retrievedfilename, "`r", "")
    retrievedfilename := StrReplace(retrievedfilename, "`n", "")

    ; MsgBox, 262144, CPRS Booster, %retrievedfilename%  ; 

   ; If FileExist(retrievedfilename)
     ;  MsgBox, File exists!
   ; Else
    ;  MsgBox, File does not exist!
    
    ; Use the Run command to open the file in Notepad
    if (RetrievedFileName) ; Check if the filename was successfully retrieved
    {
        ; Run, Notepad "%RetrievedFileName%"
		
		
		; Read the file into a variable
FileRead, fileContent, %RetrievedFileName%

; Parse the fileContent
Loop, Parse, fileContent, `n, `r
		{
			if (A_Index = 1)
				description := A_LoopField
			else if (A_Index = 2)
				dotPhrase := A_LoopField
			else if (A_Index = 3)
				insertedText := A_LoopField
			else if (A_Index = 4)
				category := A_LoopField
			else if (A_Index = 5)
				uploadedBy := A_LoopField
		}

			gui37:
			gui, 37: destroy
			Gui, 37:New ; Create a new GUI named 37
			Gui, 37:Add, Text, x392 y-127 w230 h166 , Text
			Gui, 37:Font, S13 CDefault Bold, Verdana
			Gui, 37:Add, Text, x42 y19 w600 h30 , Trigger (dot phrase): %dotPhrase%
			Gui, 37:Add, Text, x42 y59 w600 h20 , Description: %description%
			Gui, 37:Add, Text, x42 y99 w600 h30 , Category: %category%
			Gui, 37:Add, Text, x42 y139 w600 h30 , Creator: %uploadedBy%
			Gui, 37:Add, Text, x312 y169 w300 h30 , Inserted Text:
			Gui, 37:Font
			Gui, 37:Font, S13, Verdana
			
			insertedText := PutIllegalBack(insertedText)
			insertedText := DecompressDotP(insertedText)
			Gui, 37:Add, Edit, x22 y199 w890 h260 , %insertedText%
			Gui, 37:Show, x134 y131 h494 w931, Dot Phrase Details

			Return

    }

}
;returnt(fname, A_EventInfo, 7)  ; Get the text from the row's lastfield.
    ; msgbox You double-clicked row number %A_EventInfo%. Text: "%RowText%"

;gosub openeditgui
;}

; */
    ; Check if the event is a normal left click
	
	;MsgBox, % "The GUI event was: " A_GuiEvent
	
   if (A_GuiEvent != "DoubleClick")
    {
	return
	}


return  ; END of MyListViewNL

37GuiClose:
 Gui, 37: Destroy 
return

;--------------------------DELETE ROWS FROM NATIONAL


DeleteFromNational:

if (Deletenationalmsg = 0)
{
Deletenationalmsg := 1
MsgBox, 262144, CPRS Booster, FYI: You can only delete one dot phrase at a time `n (Selecting multiple doesn't do anything)

}
    userChoice := "" ; Reset
    ; Show GUI 44
    Gosub, gui44

    ; Wait for the GUI window to be closed
    WinWaitClose, BOOSTER: CONFIRM DELETE

    ; Handle user's choice
    if (userChoice = "Cancel") {
        userChoice := "" ; Reset for next use
        return
    }



; Format the location
location := SubStr(location, 1, 3)

; FIRST: DELETE THE ACTUAL FILE FROM THE NATIONAL LIBRARY
fileToDelete := NationalLibDPFiles . deletefn


   ; Concatenate and remove potential carriage returns or newlines

    fileToDelete:= StrReplace(fileToDelete, "`r", "")
    fileToDelete:= StrReplace(fileToDelete, "`n", "")




; MsgBox, , ,File to Delete %filetodelete%


FileDelete, %fileToDelete%
; If !ErrorLevel ; If the file was deleted successfully
    ;MsgBox, , , The file has been deleted.
	; else
	; MsgBox, 262144, CPRS Booster, File was not found to be deleted

; SECOND: DELETE THE ROW REFERENCING THE FILE IN THE DOT PHRASE INDEX FILE
FileRead, indexData, %DPIpath%
indexRows := StrSplit(indexData, "`n", "`r")
newIndexData := ""
deleted := false
Loop, % indexRows.MaxIndex()
{
    row := indexRows[A_Index]
    fields := StrSplit(row, "|")
	

	
	LocFromIndex:= fields[1]
	DPFromIndex:= fields[3]
	FNFromIndex:= fields[13]
	
	
  ; remove potential carriage returns or newlines
	
	FNfromIndex:= StrReplace(FNfromIndex, "`r", "")  ;we're not using these below
    FNfromIndex:= StrReplace(FNfromIndex, "`n", "")
	
	
	 Deletefn:= StrReplace(Deletefn, "`r", "")
    Deletefn:= StrReplace(Deletefn, "`n", "")
	
	if (FNFromIndex = "" or FNFromIndex = " ") ; Check if filename is empty or whitespace
    {
        continue ; Skip this row
    }
	
	

    if (fields[1] = Deletelocation) and (fields[3] = Deletedotphrase) and (fields[13] = Deletefn)
    {
	
        deleted := true
        continue ; Skip this row
    }
  
	newIndexData .= row
    if (A_Index < indexRows.MaxIndex()) ; Check if it's the last row
        newIndexData .= "`n" ; Append newline if not the last row
}
If deleted
{
    FileDelete, %DPIpath%
    FileAppend, %newIndexData%, %DPIpath%
    MsgBox, 262144, CPRS Booster, Dot Phrase deleted.
	gosub RefreshNationalFileList
}
else
   MsgBox, , , Something may have gone wrong. Not sure...
return



;--------------------END DELETE ROWS

;############################################################################################
;#######################confirm delete from national dot library GUI#############################################
;######################################GUI44######################################################






gui44:
    Gui, 44:Destroy
    Gui, 44:Font, S12 CDefault, Verdana
    Gui, 44:Add, Text, x142 y209 w330 h40 , Are you sure you want to do this?
    Gui, 44:Add, Text, x22 y39 w590 h50 , YOU ARE REMOVING THIS DOT PHRASE FROM THE NATIONAL LIBRARY
    Gui, 44:Add, Button, x72 y279 w240 h40 g44DeleteFromNational, DELETE FROM NATIONAL
    Gui, 44:Add, Button, x352 y279 w130 h40 g44Cancel, CANCEL
    Gui, 44:Add, Text, x32 y109 w560 h50 , - Users who have already downloaded`, will still have access in their personal library
    Gui, 44:Show, x127 y87 h349 w624, BOOSTER: CONFIRM DELETE
    return

44DeleteFromNational:
    userChoice := "DeleteFromNational"
    Gui, 44:Destroy
    return

44Cancel:
44GuiClose:
    userChoice := "Cancel"
    Gui, 44:Destroy
    return


;############################################################################################
;###################End confirm delete GUI###############################################
;############################################################################################



;############################################################################################
;###################Refresh national Lib Filelist after delete##########################################
;############################################################################################

RefreshNationalFileList:


	Gui, 34:Default ;
				Sleep, 100  ; Wait for the window to be activated.
	
		
    ; Reload the Mydata array
   
	 MyData := CsvWithHeadersToArray(DPIpath)
 

    LV_Delete()
	
    ; Repopulate the file list
    ; Determine the length of the MyData array
    ArrayLength := MyData.location.MaxIndex()

    ; Initialize an empty array to hold unique location values
    UniqueLocations := {}

    ; Loop through the array using numeric index
    For Index, _ in MyData.location
    {
        LibOrigin := MyData.location[Index]
        LibDP := MyData.dptrigger[Index]
        LibFulltxt := MyData.dptxt[Index]
        LibFulltxt := DecompressDotP(LibFulltxt)  ; gets rid of {Lbreak} notation

        LibCat := MyData.dpcategory[Index]
        LibDesc := MyData.dpdesc[Index]
        LibAuth := MyData.uploaduser[Index]
        LibFile := MyData.filename[Index]

        ; Add the location to the UniqueLocations array if not already added
        if (UniqueLocations.HasKey(LibOrigin) = false)
        {
            UniqueLocations[LibOrigin] := "" ; The value doesn't matter, we are only interested in unique keys
        }

        LV_Add("", LibOrigin, LibDP, LibFulltxt, LibCat, LibDesc, LibAuth, LibFile)
    }

    ; Update the listview in Gui 34

  Gui, 34:Show, NA
    GuiControl, 34:Focus, filelist
    return





;############################################################################################
;############################################################################################
;############################################################################################



;--------------------------------APPLY FILTERS and search terms in national DP lib

ApplyFilters:
    ; Get values from all dropdowns
    GuiControlGet, SelectedEmpType, , ddEmpType2
    GuiControlGet, SelectedInptStatus, , InptStatus
    GuiControlGet, SelectedDeptRole, , ddDepart2
    GuiControlGet, SelectedLocation, , ddLocation2
    GuiControlGet, SelectedICC, ,ddICC2
    GuiControlGet, SearchTerm, , DPsearch

    ; Clear the ListView
    LV_Delete()

    ; Store matched rows and their scores
    MatchedRows := []

    ; Repopulate the ListView based on filters
    For Index, _ in MyData.location
    {
        ; Load data
        LibOrigin := MyData.location[Index]
        LibEmpType := MyData.EmplType[Index]
        LibInptStatus := MyData.InptOutpt[Index]
        LibDeptRole := MyData.Dept[Index]
        LibICC := MyData.ICC[Index]
        LibDP := MyData.dptrigger[Index]
        LibFulltxt := MyData.dptxt[Index]
		LibFulltxt := DecompressDotP(LibFulltxt)  ; gets rid of {Lbreak} notation
        LibCat := MyData.dpcategory[Index]
        LibDesc := MyData.dpdesc[Index]
        LibAuth := MyData.uploaduser[Index]
        LibFile := MyData.filename[Index]

        ; Filter logic
        if (SelectedLocation != "ALL" and SelectedLocation != "" and SelectedLocation != LibOrigin)
        {
            continue
        }
        if (SelectedICC != "ALL" and SelectedICC != "" and SelectedICC != LibICC)
        {
            continue
        }
        if (SelectedEmpType != "ALL" and SelectedEmpType != "" and SelectedEmpType != LibEmpType)
        {
            continue
        }
		if !(SelectedInptStatus = "ALL" or SelectedInptStatus = "" or SelectedInptStatus = LibInptStatus or LibInptStatus = "both")
		{
			continue
		}

        if (SelectedDeptRole != "ALL" and SelectedDeptRole != "" and SelectedDeptRole != LibDeptRole)
        {
            continue
        }
		

      ; Score and match search terms
        if (SearchTerm != "")
        {
            RowData :=  LibDP . LibFulltxt . LibCat . LibDesc . LibAuth 
            Score := 0
            IsInLibDesc := false  ; flag to check if any term is in LibDesc
            
            if (InStr(RowData, SearchTerm))  ; Exact match
            {
                Score += 1000  ; High score for exact matches
                if (InStr(LibDesc, SearchTerm))  ; Check if search term is in LibDesc
                {
                    IsInLibDesc := true
                }
            }
            else
            {
                SearchTerms := StrSplit(SearchTerm, " ")
                Matches := 0
                for i, Term in SearchTerms
                {
                    if (InStr(RowData, Term))
                    {
                        Matches += 1
                        if (InStr(LibDesc, Term))  ; Check if term is in LibDesc
                        {
                            IsInLibDesc := true
                        }
                    }
                }
                if (Matches = SearchTerms.MaxIndex())  ; All terms match
                {
                    Score += 100  ; Next highest score for all terms matching
                }
                else if (Matches > 0)  ; Some terms match
                {
                    Score += Matches  ; Score based on the number of matching terms
                }
            }
            
            ; Double the score if any search term is found in LibDesc
            if (IsInLibDesc)
            {
                Score *= 2
            }
            
            ; Add to MatchedRows if it's a match
            if (Score > 0)
            {
                Row := { "Origin": LibOrigin, "DP": LibDP, "Fulltxt": LibFulltxt, "Cat": LibCat, "Desc": LibDesc, "Auth": LibAuth, "File": LibFile, "Score": Score }
                MatchedRows.Push(Row)
            }
        }
        else
        {
            ; Add the row to the ListView if there's no search term
            LV_Add("", LibOrigin, LibDP, LibFulltxt, LibCat, LibDesc, LibAuth, LibFile)
        }
    }

    ; Sort and add matched rows to the ListView
    if (SearchTerm != "")
    {
        ; Sort the MatchedRows array by Score in descending order
        MatchedRows_Sorted := SortByScoreDesc(MatchedRows)

        ; Add the sorted rows to the ListView
        for Each, Row in MatchedRows_Sorted
        {
            LV_Add("", Row.Origin, Row.DP, Row.Fulltxt, Row.Cat, Row.Desc, Row.Auth, Row.File)
        }
    }
    
    GuiControl, Focus, filelist
Return

SortByScoreDesc(ByRef MatchedRows)
{
    SortedMatchedRows := []
    While (MatchedRows.MaxIndex() > 0)
    {
        MaxScore := 0
        MaxIndex := 0
        For Index, Row In MatchedRows
        {
            If (Row.Score > MaxScore)
            {
                MaxScore := Row.Score
                MaxIndex := Index
            }
        }
        SortedMatchedRows.Push(MatchedRows[MaxIndex])
        MatchedRows.RemoveAt(MaxIndex)
    }
    Return SortedMatchedRows
}


;---------------------------------END apply search terms


;############################################################################################
;#######################Copy Dot phrase files from national to local#####################################
;############################################################################################


MoveToPersonalLibrary:
    ; Initialize RowNumber to 0 for the first iteration
    RowNumber := 0
	libproblem := 0
	selectedRowsCount := 0  ; Initialize selectedRowsCount to 0
    
Loop
{
    ; Get the row number of the next checked item, starting from the row after RowNumber
    RowNumber := LV_GetNext(RowNumber, "Checked")

    ; If RowNumber is 0, break the loop (no more checked items)
    if not RowNumber
        break
	selectedRowsCount++  ; Increment the selectedRowsCount


; Extract the 'fn' (filename) from the last column of the row
LV_GetText(Filename, RowNumber, 7)
LV_GetText(AttemptedFText, RowNumber, 3)
LV_GetText(AttemptedDP, RowNumber, 2)


Filename := Trim(Filename) ; Trim any extra spaces
    ; Remove any carriage return or newline characters from the Filename
    Filename := StrReplace(Filename, "`r", "")  ; Remove carriage returns
    Filename := StrReplace(Filename, "`n", "")  ; Remove newlines


; Construct the full path of the file
FullFilePath := NationalLibDPFiles . Filename
FullFilePath := Trim(FullFilePath) ; Trim any extra spaces


    ; Destination path where the file should be copied
    DestinationPath := onedrivelocalDot . Filename  ; Construct destination path



    ; Copy the file, overwrite if necessary
    FileCopy, % FullFilePath, % DestinationPath, 1  ; 1 indicates to overwrite
	
	if !(FileExist(DestinationPath))
	{
	libproblem := 1
	}
	
}  ; end of loop

if (selectedRowsCount = 0)  ; No rows were selected
	{
		MsgBox, 262144, CPRS Booster, No Dot Phrases Selected To Download.`n Use Checkboxes on far left of screen
	}
else if (libproblem = 1)
{
instru := "
(
There was some kind of problem 
getting one or more of the 
dot phrases.
)"
    MsgBox, 262144, CPRS Booster, %instru%
}
else
{
    instru := "
    (
    Congratulations! All Done
    Dotphrases were copied to your Library
    )"
    MsgBox, 262144, CPRS Booster, %instru% 
}

gosub 34GuiClose ; close national GUI; reload and Reopen personal

Return


;**************************************END COPY DP FROM NATIONAL************






;############################################################################################
;#####################NATIONAL DOT PHRASE GUI END######################################
;############################################################################################
;############################################################################################
;######################################################################################
;############################################################################################


;############################################################################################
;#################Function to Injest pipe delimited file into an object##################################################
;############################################################################################

CsvWithHeadersToArray(csvPath)   ; Injests index file. changed to pipe delim; output in format = data.columnname.rownumber
{
	data := {}
	col := {}
	FileRead, csvText, % csvPath
	loop, Parse, csvText, `n
	{
		row := A_Index
		if (row = 1)
		{
			loop, Parse, A_LoopField, |   ; pipe
			{
				data[A_LoopField] := []
				col[A_Index] := A_LoopField
			}
			continue
		}
		loop, Parse, A_LoopField, |   ; pipe
			data[col[A_Index]][row - 1] := A_LoopField
	}
	return data
}




;############################################################################################
;############################################################################################
;############################################################################################



;############################################################################################
;################################GUI36: Sync with DOTPHRASE library GUI##############################################
;############################################################################################
Gui36:

Gui, 36: Destroy
my_picturefile =%BoosterRoot%Pictures\syncwithlibrary2.PNG

Gui 36: Font, S14 CDefault, Verdana
Gui 36: Add, Text, x32 y29 w630 h30 , One Time Connection To Library From This Computer Required

Gui 36: Font, S13 CDefault, Verdana
Gui 36: Add, Text, x62 y69 w570 h40 , When YOU click the 'Let's do it!' Button below, I AM going to open a Library Access Webpage.
Gui 36: Add, Text, x62 y120 w570 h45,  YOU are going to click the SYNC button (looks like picture below). THEN COME BACK to this page and click 'I Did it!'


; Gui 36: Add, Text, x62 y120 w760 h40 ,Get ready to: 1. Click on THREE LITTLE DOTS 2. Click SYNC. 3 & 4: Close browser

Gui 36: Add, Button, x102 y200 w500 h30 gDoit, Let's Do It! Show me the SYNC Button!


Gui 36: Add, Picture, x5 y255 h350 , %my_picturefile%
Gui 36: Add, Button, x572 y630  w100 h30 gCancelsync, Cancel
Gui 36: Add, Button, x100 y630  w100 h30 gIdidit, I Did It!

; Generated using SmartGUI Creator 4.0
Gui 36: Show, x100 y10 h670 w900, Connect to National Library
Return


36GuiClose:
 Gui, 36: Destroy ; Destroy the GUI to get it out of the way
Return

Doit:

MsgBox, 262144, CPRS Booster, After you click 'SYNC' click OK on any Pop-ups
MsgBox, 262144, CPRS Booster, Then Close the browser
MsgBox, 262144, CPRS Booster, DO NOT now OR in the future directly use Sharepoint to view/edit/add/remove dot phrases in the library. `n`nONLY use Booster itself. `n`n Otherwise: a mess you will make (for everyone) ..
SplashTextOn ,150 ,100, CPRS Booster, Here we go....
sleep 300
SplashTextOff
torun := "https://dvagov.sharepoint.com/sites/vabstrlib/zz%20DO%20NOT%20TOUCH%20FILES%20BELOW/Forms/AllItems.aspx"
run, %torun%
return

CancelSync:
Gui, 36: Destroy
return

Ididit:

  IfNotExist, %NationalLibDPFiles%
  {
  
  MsgBox, 262144, CPRS Booster, TROUBLE in paradise. Did not work. Click OK to close this box and then click 'Let's do it!' and try again.
  }
  else
  {
  SplashTextOn ,150 ,100, CPRS Booster, GREAT WORK! `n All set!
	sleep 1500
	SplashTextOff
	Gui, 36: Destroy
	MsgBox, 262144, CPRS Booster, If not done: Close the web browser/sharepoint..
	MsgBox, 262144, CPRS Booster, It May Take Several Hours For the Library to Sync/Appear
	MsgBox, 262144, CPRS Booster, Inside of the library: you can double click on a dot phrase to see its full details...

  }

return



return


;############################################################################################
;############################################################################################
;############################################################################################








;############################################################################################
;#####################PERSONAL PROFILE LOGIC START######################################
;############################################################################################
;############################################################################################
;######################################################################################
;############################################################################################


Gui35:


Gui, 35: destroy
; Create the User folder if it doesn't exist
if (!FileExist(UserFolderPath))
    FileCreateDir, %UserFolderPath%

gosub importUserProfile ; load current settings.

Gui, 35: Font, S11 Bold, Verdana
Gui, 35: Add, Text, x32 y-1 w240 h20 , Create Your Profile


Gui, 35: Font
Gui, 35: Font, S11, Verdana   ; ****NORMAL TEXT
instru := "
(
Why?? Because (A) Booster will automatically show you dot phrases made
by people like you... and (B) Your shared dot phrases can be found by others.
)"
Gui, 35: Add, Text, x72 y29 w730 h40 , %instru%



Gui, 35: Add, Edit, VUserFirstName x322 y269 w180 h30 
Gui, 35: Add, Edit, VUserLastName x572 y269 w180 h30 



Gui, 35: Add, Text, x74 y269 w230 h20 , %A_UserName%


;############################################################################################
;#####################BUILD EMP TYPE DROP DOWN#######################################
;############################################################################################

 ; ***************************THESE NEXT THREE LINES build the dropdown

FileRead, ddtextemp, % emppath
Sort, ddtextemp, D|
 
; **********************
Gui, 35: Add, DropDownList, vJobType x62 y149 w200 h500 , %ddtextemp%


;############################################################################################
;#################BUILD ICC DROP DOWN#############################
;############################################################################################

 ; ***************************THESE NEXT THREE LINES build the*** ICC ***dropdown
FileRead, ddtextemp, % ICCpath
Sort, ddtextemp, D|
; **********************
Gui, 35: Add, DropDownList, gICCdd x322 y149 w200 h500 vddICC , %ddtextemp%


departdisplay := ddDepart("All")   ;first time paint this display all departments

Gui, 35: Add, DropDownList, x572 y149 w200 h500 vddDepart , %departdisplay%



Gui, 35: Font, S11 Bold, Verdana   ; BOLDED ITEMS
Gui, 35: Add, Text, x32 y89 w260 h30 , What is your job?
Gui, 35: Add, Text, x32 y199 w260 h30 , Who are you?
Gui, 35: Add, Text, x32 y330 w260 h30 , Work Setting?




Gui, 35: Font
Gui, 35: Font, underline S11, Verdana ;UNDERLINED NON BOLDED
Gui, 35: Add, Text, x62 y119 w200 h20 , Job Type
Gui, 35: Add, Text, x322 y119 w200 h20 , Department (ICC)
Gui, 35: Add, Text, x572 y119 w200 h20 , Specific Job/Field
Gui, 35: Add, Text, x62 y239 w230 h20 , Your VA USERNAME:

Gui, 35: Add, Text, x322 y239 w230 h20 , Your real FIRST name:
Gui, 35: Add, Text, x572 y239 w230 h20 , Your real LAST name:


   ; non-bolded non underlined
Gui, 35: Font
Gui, 35: Font, S11, Verdana

; Add radio buttons for "Inpatient," "Outpatient," and "Both"
Gui, 35: Add, Radio, vUserInptOutpt x322 y349 w100 h30 , Inpatient
Gui, 35: Add, Radio, x442 y349 w100 h30 , Outpatient
Gui, 35: Add, Radio, x562 y349 w100 h30 , Both

Gui, 35: Add, Button, x32 y429 w100 h30 gSaveProfile , Submit
Gui, 35: Add, Button, x162 y429 w100 h30 gcancelProfile, Cancel
Gui, 35: Show, x222 y187 h500 w888, Your Dot Phrase Profile
Return

cancelprofile:
35GuiClose:
Gui, 35: destroy
return

;############################################################################################
;######################FUNCTION######BUILD SPECIFIC DEPARTMENT/ROLE DROP DOWN########################
;############################################################################################


/*
ddDepart(ICCSelection) 
{
  
    FileRead, ddtextdept, % ExactRolepath
    ; Sort, ddtextdept, D|

 

    departdisplay := " "
    Loop, Parse, ddtextdept, `n ; split the rows apart
    {
	
		
				ICC := "" ; reset
				
		Loop, Parse, A_LoopField, |    ; split the columns within a row
				{


						if (A_Index = 1)
						{
						ICC := A_LoopField
				
						}


						if (A_Index = 2)
						{
						
						
							if (ICCSelection = ICC)
							{
											
								exactrole := A_LoopField
								departdisplay .= ExactRole "|"
						
								 
							}
						
						}

				}	
		
    }
	
	
	departdisplay := StrReplace(departdisplay, "`r", "")  ; remove linefeeds

    return departdisplay
}
*/

;############################################################################################
;######################FUNCTION######BUILD SPECIFIC DEPARTMENT/ROLE DROP DOWN########################
;############################################################################################
ddDepart(ICCSelection) 
{
  
    FileRead, ddtextdept, % ExactRolepath

    departRoles := [] ; Initialize an empty array
  
    Loop, Parse, ddtextdept, `n ; split the rows apart
    {
        ICC := "" ; reset
        
        Loop, Parse, A_LoopField, |    ; split the columns within a row
        {
            if (A_Index = 1)
            {
                ICC := A_LoopField
            }

            if (A_Index = 2 && ICCSelection = ICC)
            {
                exactrole := A_LoopField
                departRoles.Push(exactrole) ; Add the role to the array
            }
        }    
    }

    ; Convert the array to a delimited string for sorting
    delimitedRoles := ""
    for index, role in departRoles
    {
        delimitedRoles .= role "`n"
    }
    
    ; Sort the delimited string
    Sort, delimitedRoles, D`n

    ; Convert the sorted string back to a pipe-delimited string
    departdisplay := StrReplace(delimitedRoles, "`n", "|")
    departdisplay := RTrim(departdisplay, "|") ; Remove the trailing pipe
    
    departdisplay := StrReplace(departdisplay, "`r", "")  ; remove linefeeds

    return departdisplay
}

ICCdd:  ; limits to correct departments: THIS IS THE FOR THE **PROFILE** DROP DOWN
; we need to update the exact role list and restrict to ICC


	GuiControlGet, ddICC , , ddICC 
	refreshdepartments := ddDepart(ddICC)
	refreshdepartments := "|"refreshdepartments   ; need leading pipe to overwrite
	GuiControl,, ddDepart, %refreshdepartments% ; should replace the dropdown options

return



ICCdd2:  ; limits to correct departments: THIS IS THE FOR THE **DP LIBRARY GUI** DROP DOWN
; we need to update the exact role list and restrict to ICC


		GuiControlGet, ddICC2 , , ddICC2 
		refreshdepartments2 := ddDepart(ddICC2)
		refreshdepartments2 := "|ALL|"refreshdepartments2   ; need leading pipe to overwrite
		GuiControl,, ddDepart2, %refreshdepartments2% ; should replace the dropdown options

return

 
 SaveProfile:
    Gui, 35: Submit, NoHide ; Submit the entire GUI

    ; Get the values from the form submission variables
   
    ICCType := ddICC
    Department := ddDepart
    VAUsername :=  A_UserName
	
	    ; Check if any required fields are missing
    if (UserFirstName = "" or UserLastName = "" or JobType = "" or ICCType = "" or Department = "" or (UserInptOutpt != "1" and UserInptOutpt != "2" and UserInptOutpt != "3"))
    {
        MsgBox, 262144, CPRS Booster, Please fill out all fields before pressing 'Submit'.
		
        return
    }
	
	  ; Determine the selected work setting
    if (UserInptOutpt = "1")
        UserInptOutpt := "Inpatient"
    else if (UserInptOutpt = "2")
        UserInptOutpt := "Outpatient"
    else if (UserInptOutpt = "3")
        UserInptOutpt := "Both"
    else
        UserInptOutpt := "" ; Default if none selected


    ; Create the data string in pipe delimited format
    ProfileData := UserFirstName "|" UserLastName "|" JobType "|" ICCType "|" Department "|" VAUsername "|" UserInptOutpt


    ; Delete the existing file (if it exists)
    FileDelete, %UserProfileFile%

    ; Write the new data to the file
    FileAppend, %ProfileData%`n, %UserProfileFile%

    ; Close the GUI
    Gui, 35: Destroy
    
	return



Return ; return of gui35 label

;############################################################################################
;#####################PERSONAL PROFILE LOGIC END######################################
;############################################################################################
;############################################################################################
;######################################################################################
;############################################################################################




;############################################################################################
;######################END Dot Phrase National Library GUI###############################################################
;############################################################################################





;############################################################################################
;########################Look for Brillians############################################
;############################################################################################
BrillChk:

WinGet, hWnd, ID, A
Winget, process, Processname, ahk_id %hWnd%

if (process = "Brillians.exe")
{

Suspend, On
Sleep 6000
suspend, Off


}

Return

;############################################################################################
;############################################################################################
;############################################################################################



;############################################################################################
;#########################Debugger######################################
;############################################################################################
!^+D:: ; Alt + Ctrl + Shift + D
    ListLines
    If WinExist("Lines most recently executed")
        WinActivate, Lines most recently executed
    Else
    {
        Sleep, 1000 ; Wait for the ListLines window to appear
        WinActivate, Lines most recently executed ; Activate the ListLines window
    }
return





;############################################################################################
;####################End debugger####################################################
;############################################################################################





;############################################################################################
;#####################voogle to do list#########################################
;############################################################################################


; We're missing bar click to gui45 collision avoidance and 2. Screen toggle resize issues. 3. Can't find agree button
; 4. What happens with time outs when we can't find stuff



;############################################################################################
;###################Look for the Agree button on Voogle page: color search#############################################
;############################################################################################
ClickVoogleAgree:

gosub ActivateVoogle
sleep 200
coords := ColorSearch(browserTitle, "0x007BFF",10000 , "q4", "BR") ; sets coords  
    coords.screenX:= coords.screenX - 10
    coords.screenY:= coords.screenY - 10

if (coords !=false)
{
sleep 600
gosub clickoncolor ; clicks on the coords
vooglelauncherror := 0
}
else
{
vooglelauncherror := 1
; MsgBox, 262144, CPRS Booster, Might be a problem. If so, try pressing the Booster CPRS Search Button again. 
		 
		
}

RETURN

;############################################################################################
;##############################End click Voogle agree button########################################
;############################################################################################

;########################################Click on color####################################################
;#########################call color search function first############################################
;############################################################################################

clickoncolor:

if (coords)   ; only do this if we found the color 
	{
	variableX := coords.screenX
	variableY := coords.screenY 
	mouseclick, left, %variableX%, %variableY%
	; MsgBox, 262144, CPRS Booster, x,y: %variableX%, %variableY%
	}


return



;############################################################################################
;############################################################################################
;############################################################################################

;############################################################################################
;##################GENERIC COLOR SEARCH (colorsearch Findcolor) function ##############################################
;############################################################################################

; Color search function with optional quadrant and direction parameters
; Example usage:
; coords := ColorSearch("Voogle", "0x1A2B57", 3000, "q4", "TR")
; If no quadrant and direction are provided, it defaults to searching the entire window/screen from top-left:
; coords := ColorSearch("Voogle", "0x1A2B57", 3000,"","")

; Parameters:
; windowName - The name of the window in which to conduct the color search (optional).
;              If omitted, the entire screen is searched.
; color - PUT IN QUOTES. The color to search for (gin RGB format, e.g., 0x1A2B57). IF MORE THAN ONE separate by pipe.
; timeout - The time allowed for the search (in milliseconds).
; quadrant - The part of the window or screen to search ("q1", "q2", "q3", "q4", or "all" for the entire area).
;            Defaults to "all".
; direction - The starting direction for the search ("TL", "TR", "BL", "BR").
;             "T" starts from the top, "B" starts from the bottom, "L" starts from the left, "R" starts from the right.
;             Defaults to "TL".
;---------------
; To extract the values from the returned object:
; if (coords) {
;     windowX := coords.windowX
;     windowY := coords.windowY
;     screenX := coords.screenX
;     screenY := coords.screenY
;	  Colorfound = coords.color
;     MsgBox, Color found at window coordinates (%windowX%, %windowY%) and screen coordinates (%screenX%, %screenY%).
; } else {
;     MsgBox, Color not found within the specified time.
; }


;  HERE IS COLORSEARCH NEW
ColorSearch(windowName, colors, timeout, quadrant, direction) {
    ; Set default values for optional parameters
    if (quadrant = "") {
        quadrant := "all"
    }
    if (direction = "") {
        direction := "TL"
    }

    ; Split the colors into an array if there are multiple colors
    colorArray := StrSplit(colors, "|")

    ; Ensure the window name is optional
    if (windowName) {
        ; Activate the specified window using title match mode
        SetTitleMatchMode, 1
        WinActivate, %windowName%
        
        ; Get the position and size of the window
        WinGetPos, , , winWidth, winHeight, %windowName%
    } else {
        ; Use the entire screen
        winWidth := A_ScreenWidth
        winHeight := A_ScreenHeight
    }

    ; Define the search area based on the quadrant
    if (quadrant = "all") {
        startX := 0
        startY := 0
        endX := winWidth
        endY := winHeight
    } else {
        switch quadrant {
            case "q1":
                startX := 0
                startY := 0
                endX := winWidth / 2
                endY := winHeight / 2
                
            case "q2":
                startX := winWidth / 2
                startY := 0
                endX := winWidth
                endY := winHeight / 2
              
            case "q3":
                startX := 0
                startY := winHeight / 2
                endX := winWidth / 2
                endY := winHeight
               
            case "q4":
                startX := winWidth / 2
                startY := winHeight / 2
                endX := winWidth
                endY := winHeight
                
            default:
                MsgBox, Invalid quadrant specified.
                return false
        }
    }

    ; Set the coordinate mode for pixel search relative to the window
   ;  CoordMode, Pixel, Window
   CoordMode, Pixel, Screen

    ; Initialize the start time
    start_time := A_TickCount

    ; Outer loop to handle timeout
    Loop {
	
	
				; win security screen (CPRS) somehow messed up color search in PIV
			If WinActive("Windows Security") ; get this done if this is there at same time
				{
				send {tab}
				sleep 50
				send {enter}
				}
        ; Inner loop to search for each color
        for index, color in colorArray {
            if (direction = "TL") {
                PixelSearch, foundX, foundY, startX, startY, endX, endY, %color%, 0, Fast RGB
            } else if (direction = "TR") {
                PixelSearch, foundX, foundY, endX, startY, startX, endY, %color%, 0, Fast RGB
            } else if (direction = "BL") {
                PixelSearch, foundX, foundY, startX, endY, endX, startY, %color%, 0, Fast RGB
            } else if (direction = "BR") {
                PixelSearch, foundX, foundY, endX, endY, startX, startY, %color%, 0, Fast RGB
            } else {
                MsgBox, Invalid search direction specified.
                return false
            }

            if (ErrorLevel = 0)
			 {
                ; Move the mouse to the found color position within the window
                ; MouseMove, foundX, foundY
                
                ; Get the window-relative coordinates
                ; CoordMode, Mouse, Window
                ; MouseGetPos, windowX, windowY
                
                ; Get the screen-relative coordinates
                ; CoordMode, Mouse, Screen
                ; MouseGetPos, screenX, screenY

                
                ; Return the found coordinates and the color
                return {windowX: windowX, windowY: windowY, screenX: FoundX, screenY: FoundY, color: color}
            }
        }

        ; Check for timeout
        if (A_TickCount - start_time > timeout) {
           ; MsgBox, Timeout reached. Searched Color not found 
            return false
        }

        ; Sleep to prevent CPU overuse
        Sleep, 100
    }
}

;############################################################################################
;#########################END OF COLOR SEARCH FUNCTION###################################
;############################################################################################

;############################################################################################
;#########################Find Blue bar atop Voogle################################################
;############################################################################################

findvooglebar:

coords := ColorSearch(browserTitle, "0x101A34|0x1A2B57",4000 , "q2", "BR") ; sets coords  

if (coords !=false)
{
blueScreenY := coords.ScreenY
blueScreenX := coords.ScreenX

	  
	    blueXforGUI := blueScreenX - 420
		blueYforGUI := blueScreenY - 125 ; let gui rest higher than place we click on blue bar
	   
	   BarToClickX := blueScreenX - 800
		BarToClicky := blueScreenY - 5
		
	
		 	
		vooglelauncherror := 0 ; found the blue bar atop voogle
		
}
else
{
MsgBox, 262144, CPRS Booster, Something went wrong. Try pressing the Booster CPRS
vooglelauncherror := 1
}

return
;############################################################################################
;#########################END of Find voogle blue bar#############################################
;############################################################################################




;############################################################################################
;############CLICK ON BLUE VOOGLE BANNER BAR#############################################
;############################THIS IS DIFFERENT THAN FIND BAR; RUN that first############################################################

clickvooglebar:
 ; note: the booster helper GUI (after submit) gets rid of voogle maintenance bar prn
gosub ActivateVoogle


CoordMode, mouse, window   ; what's this for?
sleep 10

 ; MsgBox, 262144, CPRS Booster, Mouse should be on blue bar. Y = %bartoclicky%


;********AVOID CLICKING ON THE BOOSTER HELPER*****************************


; Get the coordinates and size of the GUI
Gui, 45:+LastFound									
GuiID := WinExist()
WinGetPos, GuiX, GuiY, GuiWidth, GuiHeight, ahk_id %GuiID%

; Check if the click coordinates overlap with the GUI
if (BarToClickX >= GuiX && BarToClickX <= (GuiX + GuiWidth) && BarToClickY >= GuiY && BarToClickY <= (GuiY + GuiHeight)) {
    ; Adjust the X coordinate to avoid the GUI
    if (BarToClickX > (GuiX + GuiWidth / 2)) {
        BarToClickX := GuiX + GuiWidth + 15 ; Move 15 units to the right of the GUI
    } else {
        BarToClickX := GuiX - 15 ; Move 15 units to the left of the GUI
    }
}
; winactivate Voogle and   ; did this already 

; mouseclick,, BarToClickX, BarToClicky
;***************************************


mouseclick, left, BarToClickX, BarToClicky


return
;############################################################################################
;#####################End voogle click blue bar##########################################
;############################################################################################



;############################################################################################
;###################Activate voogle window w/different possible titles################################################
;############################################################################################

ActivateVoogle:

SetTitleMatchMode, 1
vooglooper := 0
while (vooglooper < 20)
{
			IfWinExist, Voogle and
			{
				 browserTitle := "Voogle and"
				WinGet, winState, MinMax, Voogle and
				if (winState != -1) ; Not minimized
				{
					winactivate Voogle and
					vooglooper := 100
				}
				else
				{
				Gui, 45: HIDE
				}
			}
			else IfWinExist, Voogle - Work
			{
				browserTitle := "Voogle - Work"
				WinGet, winState, MinMax, Voogle - Work
				if (winState != -1) ; Not minimized
				{
					winactivate Voogle - Work
					vooglooper := 100
				}
				else ; if minimized, also hide helper GUI
				{
				Gui, 45: HIDE
				}
			}
			else
			{
			sleep 200
			vooglooper++
			}
}
return

;############################################################################################
;################################end Voogle window activate#####################################################
;############################################################################################




;############################################################################################
;#####################Voogle Helper GUI (vooglehelper)##################################################
;############################################################################################
; address for Voogle-Booster how to use doc:
;  %Vooglehelpdoc%



gui45:

gosub findvooglebar

if (vooglelauncherror = 1)
{
    return
}
Gui, 45: destroy

Gui, 45: Font, s10 cblack, Verdana
Gui, 45: Add, Text, x12 y9 w240 h40 , Booster Can Help With Voogle: What Do you want to search?

Vooglelist := "Notes || Outpt Meds | Labs | Radiology | Immunizations | Vitals"
Gui, 45: Add, DropdownList, gSubmitOption x12 w200 h200 -Tabstop altsubmit vSearchType , %Vooglelist%

; Add hyperlinked text
Gui, 45: Font, s8 cBlue underline, Verdana
Gui, 45: Add, Text, x150 h15 gOpenURL, How to Use This?

Gui, 45: +AlwaysOnTop

; Get the position and size of the Edge browser window
WinGetPos, BrowserX, BrowserY, BrowserWidth, BrowserHeight, %BrowserTitle%

; Calculate the coordinates for the upper right corner of the browser window
GuiX := BrowserX + BrowserWidth - 450  ; 250 is the width of the GUI
GuiY := BrowserY + 25   ; Align with the top edge of the browser window

; Show the GUI at the calculated coordinates
try {
    Gui, 45: Show, x%GuiX% y%GuiY% h97 w250, Booster Helper
}

Return


OpenURL:
Gui, 45: HIDE

SplashTextOn ,150 ,100, CPRS Booster, Just a second....
sleep 700
SplashTextOff
	run, %Vooglehelpdoc%
	
    ; Run, https://dvagov.sharepoint.com/:w:/s/CPRSBooster950/ESdN0yYDfZBApMdl7cGEQdwBlqRdXgcIoUW_gKATucfoYQ?e=1WDYMs
Return



SubmitOption:
Gui 45: Submit, NoHide  ; Update the variable with the current control values
; GuiControlGet, SelectedOption, , SearchType  ; Retrieve the current selection


winactivate Voogle and
send {pgup 5}  ; move to top of voogle screen
sleep 50


; gosub voogmaint ; get rid of this if present
; gosub findvooglebar
	if (vooglelauncherror = 1)
	{
	return ; we couldn't find the vooglebar
	}
	
	; mouseclick, left, BarToClickX, BarToClicky  
; gosub clickvooglebar



if (SearchType = 1)
{
; 	mouseclick, left, BarToClickX, BarToClicky  
; gosub clickvooglebar
 gosub tabToVoogSearchbox

    ; Assume the cursor is inside a text box and clear the text
    Send, ^a  ; Select all text in the text box
    Send, {Backspace}  ; Clear the selected text
    ; Do not send any more text
}  
else if (SearchType = 2)
{
	; mouseclick, left, BarToClickX, BarToClicky  
; gosub clickvooglebar
 gosub tabToVoogSearchbox

    Send, show outpatient rx
}
else if (SearchType = 3)
{
	; mouseclick, left, BarToClickX, BarToClicky 
; gosub clickvooglebar
 gosub tabToVoogSearchbox

    Send, show labs
}
else if (SearchType = 4)
{
	; mouseclick, left, BarToClickX, BarToClicky  
; gosub clickvooglebar
 gosub tabToVoogSearchbox

    Send, show radiology
}
else if (SearchType = 5)
{
	; mouseclick, left, BarToClickX, BarToClicky  
; gosub clickvooglebar
gosub tabToVoogSearchbox

    Send, show immunizations
}
else if (SearchType = 6)
{
	; mouseclick, left, BarToClickX, BarToClicky  
; gosub clickvooglebar
gosub tabToVoogSearchbox

    Send, show Vitals
}


sleep 1300
if (searchtype != 1) ; if searching everything don't send a tab
{
send {tab} ; gets to subsearch
}

Return

45GuiClose:
Gui, 45: Destroy

return


;############################################################################################
;######################END GUI 45 = Voogle helper widget##########################################
;############################################################################################


;############################################################################################
;###################Tab sequence to Voogle search box#####################################################
;############################################################################################

tabToVoogSearchbox:

SearchEdge(browserTitle, "Concept Search")
sleep 50
send {tab}

/*sleep 80
send {tab 9}
sleep 50
if (WarningOn = 1)
{
 send {tab}
 sleep 10

}
*/
return

;############################################################################################
;##########################end tab to voog search bo#################################################
;############################################################################################

;############################################################################################
;#####################Tab to patient info box in Voogle#############################################
;############################################################################################

tabToVoogPtinfobox:


sleep 80
send {tab 5}
sleep 50
if (WarningOn = 1)
{
 send {tab}
 sleep 10

}
return

;############################################################################################
;############################################################################################
;############################################################################################




;############################################################################################
;####################VOOGLE: User accepts risks####################################
;##############################Gui 46##############################################################

gui46:

MsgBox, 262144, CPRS Booster, Welcome to Voogle/Booster! This is the only time you will see the next two instructional screens.


Gui, 46:Add, Picture, x2 y-1 w800 h460 , \\v23.med.va.gov\apps\GUI\Local_Site_GUI\MIN\CPRSBOOSTER\Pictures\Vooglelimitations.PNG
Gui, 46:Add, Text, x182 y189 w10 h-10 , Text

Gui, 46:Font, S12 CDefault, Verdana
Gui, 46:Add, Button, x12 y479 w500 h40 gAcceptRisk46 , Voogle May Not Find Existing Data. I Accept Risk of Use
Gui, 46:Add, Button, x562 y479 w130 h40 gCancel46 , Cancel
; Generated using SmartGUI Creator 4.0
Gui, 46:Show, x127 y87 h539 w805, Booster: Voogle Can Miss Things.
Return

AcceptRisk46:
OneTimeVoogleEducation := 1

Gui, 46:Destroy
Gosub, writeit
goto Gui47
Return

Cancel46:
GuiClose46:
Gui, 46:Destroy
Return

;############################################################################################
;#########################End voogle user risk assessment###################################################################
;############################################################################################



;############################################################################################
;######################Voogle How to Use it Screen#####################################################
;###############################GUI47#############################################################

gui47:
Gui, 47:Add, Picture, x2 y-1 w800 h450 , \\v23.med.va.gov\apps\GUI\Local_Site_GUI\MIN\CPRSBOOSTER\Pictures\VoogleHowToGuide.PNG
Gui, 47:Add, Button, x632 y449 w100 h30 gOK47 , OK
; Generated using SmartGUI Creator 4.0
Gui, 47:Show, x127 y87 h488 w805, Voogle & Booster
Return

OK47:
GuiClose47:
Gui, 47:Destroy
goto startvoogle
Return

;############################################################################################
;#######################end voogle how to screen################################################
;############################################################################################





;############################################################################################
;######################Add/Flag PCP Accept Terms GUI#####################################################
;###############################GUI49#############################################################

gui49:

MsgBox, 262144, CPRS Booster, Welcome to Add-Flag-Forward PCP! This is the only time you will see the next instructional screens.

Gui, 49:Add, Picture, x2 y-1 w900 h493 , \\v23.med.va.gov\apps\GUI\Local_Site_GUI\MIN\CPRSBOOSTER\Pictures\AddFlagForwardPCPButton2.PNG

Gui, 49:Font, S12 CDefault, Verdana

; Add a "Next" button with label matching GUI number
Gui, 49:Add, Button, x450 y510 w350 h30 gnextButton49, Next

Gui, 49:Show, x100 y100 h550 w910, Add-Flag-Forward PCP
Return

nextButton49:
; Actions to perform when "Next" button is clicked
Gui, 49:Destroy   ; Destroys GUI 49
Goto, gui50       ; Goes to label gui50 to show the next GUI
Return



Cancel49:
GuiClose49:
Gui, 49:Destroy
goto, gui50
Return

;############################################################################################
;#######################end gui 49################################################
;############################################################################################



;############################################################################################
;####################ADDFLAG PCP terms part 2: burnout########################################################
;###############################gui 50  Gui50#############################################################


gui50:


Gui, 50:Add, Picture, x2 y-1 w700 h305, \\v23.med.va.gov\apps\GUI\Local_Site_GUI\MIN\CPRSBOOSTER\Pictures\PCPburnout.PNG

Gui, 50:Font, S12 CDefault, Verdana
Gui, 50:Add, Button, x12 y350 w500 h40 gAcceptRisk50 , I Will Try Not To Contribute to PCP Burnout
 Gui, 50:Add, Button, x562 y350 w130 h40 gCancel50 , Cancel

Gui, 50:Show, x100 y100 h400 w710, Add-Flag-Forward PCP
Return

AcceptRisk50:
Gui, 50:Destroy
OneTimeAddPCPEducation := 1
Gosub, writeit
gosub FlagOrSignPCP
return

Cancel50:
GuiClose50:
Gui, 50:Destroy
Return







;############################################################################################
;########################End gui 50####################################################
;############################################################################################


;############################################################################################
;######################Add/Flag/Forward GUI: FROM THE VIDEO SCREEN#####################################################
;###############################GUI51#############################################################

gui51:

Gui, 51:Add, Picture, x2 y-1 w900 h497 , \\v23.med.va.gov\apps\GUI\Local_Site_GUI\MIN\CPRSBOOSTER\Pictures\AddFlagForwardPCPButton2.PNG

Gui, 51:Font, S12 CDefault, Verdana


Gui, 51:Show, x100 y100 h550 w910, Add-Flag-Forward PCP
Return

GuiClose51:
Gui, 51:Destroy
Return

;############################################################################################
;#######################end gui 51################################################
;############################################################################################

;############################################################################################
;#####################Gui52: Shows what's new from prior updates###################################
;############################################################################################

gui52:
whatsnew:

MsgBox, 262144, CPRS Booster, On the next screen: use the NEXT and BACK Buttons`n to scroll through recent Booster updates


; Initialize the image list with the current version image
imageList := [BoosterRoot "Pictures\NewVersionCURRENT.PNG"]
currentImageIndex := 1

; Loop to add old version images to the list if they exist
oldImageIndex := 1
Loop {
    oldImagePath := BoosterRoot "Pictures\NewVersionCURRENT-OLD" . oldImageIndex . ".PNG"
    if !FileExist(oldImagePath)
        break  ; Stop the loop if the file does not exist
    imageList.Push(oldImagePath)  ; Add the image path to the list
    oldImageIndex++
}

; Create the slideshow GUI with the first image

; Create the slideshow GUI with the first image
Gui, 52: New, +HwndmySlideshowGui
imagePath := imageList[currentImageIndex]  ; Get the current image path
Gui, 52: Add, Picture, vImageControl h459 w900, %imagePath%
Gui, 52: Font, s16  ; Set the font size for the button
Gui, 52: Add, Button, x12 y500 w100 h30 gPreviousImage, << Back  ; Adjust the Y position to fit within the GUI
Gui, 52: Add, Button, x394 y500 w100 h30 gNextImage, Next >>  ; Adjust the Y position and X position for centering
Gui, 52: Add, Button, x776 y500 w100 h30 gCloseSlideshow, Close  ; Adjust the Y position to fit within the GUI
Gui, 52:Show, x100 y100 w900 h550, CPRS BOOSTER RECENT ADDITIONS   ; Increase the GUI height to accommodate buttons

return  ; end of GUI52 proper


; Navigate to the previous image
PreviousImage:
    if (currentImageIndex - 1 < 1) {
        currentImageIndex := imageList.MaxIndex()  ; Wrap around to the last image if we're at the beginning
    } else {
        currentImageIndex--  ; Otherwise, go to the previous image
    }
    imagePath := imageList[currentImageIndex]  ; Get the current image path
    GuiControl, 52:, ImageControl, %imagePath%  ; Update the image in the slideshow
return

; Navigate to the next image
NextImage:
    if (currentImageIndex + 1 > imageList.MaxIndex()) {
        currentImageIndex := 1  ; Reset to the first image if we've reached the end of the list
    } else {
        currentImageIndex++  ; Otherwise, just go to the next image
    }
    imagePath := imageList[currentImageIndex]  ; Get the current image path
    GuiControl, 52:, ImageControl, %imagePath%  ; Update the image in the slideshow
return

; Close the slideshow GUI
CloseSlideshow:
    Gui, 52: Destroy
return

; Handle the GUI close event
52GuiClose:
    Gui, 52: Destroy
return 



;############################################################################################
;########################End GUI52###############################################
;############################################################################################



;#########################NOT USING THIS GUI###################################################################
;########################End GUI53###############################################
;#######################Quick Order Step Edit Window#####################################################################
gui53:
 ; Create or show the GUI
 Gui, 53:New, +AlwaysOnTop
 Gui, 53:Add, Text,, Edit Step:
 Gui, 53:Add, Edit, vEditedKeystroke w100 20, %keystroketosend%
 Gui, 53:Add, Button, g53SubmitEditedKeystroke Default, OK
 Gui, 53:Add, Button, g53CancelGui, Cancel
 Gui, 53:Show,, Edit Step

 GuiControl, Focus, EditedKeystroke ; Set focus to the edit control
 return



 
; OK button - Submit the new text
53SubmitEditedKeystroke:
Gui, 53:Submit
keystrokestosend := EditedKeystroke ; Update the variable
EditQuickOrder() ; Call the subroutine
Gui, 53:Destroy
return

; Cancel button - Close the GUI without saving
53CancelGui:
Gui, 53:Destroy
return

; Subroutine for processing the updated text
EditQuickOrder() {
MsgBox, The updated value of keystroketosend is: %keystroketosend%
; Add your logic for processing here
}


;############################################################################################
;####################gui54######################################
;##################ERROR screen during QO playback: failed to find screen######################################

gui54:

playingbackroot := 0 ;reset

Gui, 54:Font, s11, Verdana 
Gui, 54:Add, Text,, Something is wrong with the quick order. Was waiting for screen: %keystroketosend%
Gui, 54:Add, Text,, Would you like to take a minute to fix the quick order now?..I'll help you
Gui, 54:Add, Button, gFixNow, Fix NOW
Gui, 54:Add, Button, g54cancel, Cancel
Gui, 54:Show,, CPRS Booster
return

FixNow:
		Gui, 54:Destroy
		; Add your code to handle the "Fix NOW" action here
		qodebug := true ;***************** turn on debugger (which is part of button action****************

			MsgBox, 262144, CPRS Booster, ****Close*** ALL CPRS Windows Except The Main One, THEN hit OK here
			MsgBox, 262144, CPRS Booster, We are now going to find the error in the quick order
			MsgBox, 262144, CPRS Booster, I'm going to step through the quick order ONE step at a time 
			MsgBox, 262144, CPRS Booster: F12 to continue, If the step carries out the CORRECT action, press F12 to `n proceed to the next step in the quick order
			MsgBox, 262144, CPRS Booster: F11 when you find the error, If the step does the WRONG thing: press F11: this marks the problem in the quick order 
			MsgBox, 262144, CPRS Booster, READY? `n(make SURE you've closed all CPRS screens except the main one)
			SplashTextOn ,150 ,100, CPRS Booster, Here we go!
			sleep 1000
			SplashTextOff
			Gui, 54:Destroy
			Goto, buttonaction

return


qodebugger:
Gui,  27: Destroy
qodebug := true ;***************** turn on debugger (which is part of button action****************
MsgBox, 262144, CPRS Booster, ****Close*** ALL CPRS Windows Except The Main One, THEN hit OK here
MsgBox, 262144, CPRS Booster, We are now going to find the error in the quick order
MsgBox, 262144, CPRS Booster, I'm going to step through the quick order ONE step at a time 
MsgBox, 262144, CPRS Booster: F12 to continue, If the step carries out the CORRECT action, press F12 to `n proceed to the next step in the quick order
MsgBox, 262144, CPRS Booster: F11 when you find the error, If the step does the WRONG thing: press F11: this marks the problem in the quick order 
MsgBox, 262144, CPRS Booster, READY? `n(make SURE you've closed all CPRS screens except the main one)
SplashTextOn ,150 ,100, CPRS Booster, Here we go!
sleep 1000
SplashTextOff

Goto, buttonaction ; the debugger is really just the playback loop slowed down
return

54cancel:
54GuiClose:
Gui, 54:Destroy
return

;############################################################################################
;#########################GUI 55###################################################
;############################################################################################

;############################################################################################
;#########################GUI 55###################################################
;############################################################################################

Gui55:
lastControlText := ""  ; Initialize outside the function
gui 55: Destroy
Gui, 55: New, +AlwaysOnTop +HwndMyGuiHwnd
Gui, 55: Font, s10
Gui, 55: Add, Text, vMyrxText w280 h110 ; Adjusted height for button
;Gui, 55: Add, Text,, Custom Double Dot Trigger (optional)
;Gui, 55: Add, Edit, vCustomTrigger w150 Limit35
Gui, 55: Add, Button, x200 y200 gHideQO w80, Hide This Window
Gui, 55: Add, Button, x10 y250 gSaveBoosterQuickOrder w280, Save As Booster Quick Order  ; Added Button
Gui, 55: Show, x1200 y200 w300 h300, Booster Med Engine

    ; Check if the "Order Menu" window exists and move it
    IfWinExist, Order Menu
    {
        WinMove, Order Menu,, 100, 100
    }

WinActivate, Outpatient Medications

winset, top,, Booster Med Engine
IfWinExist, CPRS Booster Quick Order, Quick order Saved!
{

WinMove, CPRS Booster Quick Order,, 1200, 600
}
SetTimer, MonitorOutptRxWindow, 600
return



MonitorOutptRxWindow:
If !WinExist("Outpatient Medications")
{
    Gui, 55: Destroy
    sleep 200
	Gui, 60: Destroy
    SetTimer, MonitorOutptRxWindow, Off
    return
}
else 
{
	controlText := ""
    controlValues := []  ; Store extracted values

    ControlGetText, text0, Tedit1, Outpatient Medications  ; drug name
    controlText .= text0 . " "
    controlValues.Push(text0)
    
    ControlGetText, text1, TORComboEdit9, Outpatient Medications ; dose (simple)
    text1 := TrimTextBeforeDollar(text1)
    controlText .= text1 . " "
    controlValues.Push(text1)
    
    ControlGetText, text2, TORComboEdit8, Outpatient Medications
    controlText .= text2 . " "
    controlValues.Push(text2)
    
    ControlGetText, text3, TORComboEdit7, Outpatient Medications
    controlText .= text3 . " "
    controlValues.Push(text3)
    
    ControlGet, isCheckedprn, Checked,, TCheckBox1, Outpatient Medications
    if (isCheckedprn)
    {
        controlText .= "`nAS NEEDED "
    }
    controlValues.Push(isCheckedprn ? "AS NEEDED" : "")
    
    ControlGetText, text5, TORComboEdit2, Outpatient Medications
    controlText .= text5 . "`n"
    controlValues.Push(text5)
    
    ControlGetText, text6, TCaptionMemo1, Outpatient Medications
    controlText .= text6 . "`n"
    controlValues.Push(text6)
    
    ControlGetText, text7, TCaptionEdit3, Outpatient Medications
    controlText .= "`nDays: " . text7 . " "
    controlValues.Push(text7)
    
    ControlGetText, text8, TCaptionEdit2, Outpatient Medications
    controlText .= "Quant: " . text8 . " "
    controlValues.Push(text8)
    
    ControlGetText, text9, TCaptionEdit1, Outpatient Medications
    controlText .= "Refills: " . text9 . "`n"
    controlValues.Push(text9)
    
    ControlGet, isChecked1, Checked,, TRadioButton1, Outpatient Medications
    ControlGet, isChecked2, Checked,, TRadioButton2, Outpatient Medications
    ControlGet, isChecked3, Checked,, TRadioButton3, Outpatient Medications
    
    pickupMethod := isChecked1 ? "PARK" : isChecked2 ? "MAIL" : isChecked3 ? "WINDOW" : ""
    controlText .= "Pick up: " . pickupMethod . " `n"
    controlValues.Push(pickupMethod)
    
    outputText := ""  ; Build output string
    displayText := ""  ; Build display string (without pipes) Build output string
    for index, value in controlValues
    {
        outputText .= (index = 1 ? "" : "|") . value  ; Pipe-delimited for the output FILE

       ; displayText .= (index = 1 ? "" : " ") . value  ; Space-separated for display  


	   /*

	   ; Index order
	   1= "Username: "
	   2 = "Drug Name: 
	   3 = "Dose: " 
	   4 = "Route: "
	   5 = "Frequency: " 
	   6= "PRN: " 
	   7= "Indication: 
	   8 = "Comments: " 
	   9 = "Days: " . order.days . "`n"
	   10= "Quantity: " . order.quantity . "`n"
	   11 = "Refills: " . order.refills . "`n"
	   12 = "Pickup Method: " . order.pickup_method . "`n"
	   13 = "Display Text: " . order.display_text . "`n"
	   14 = "Custom Trigger: " . order.custom_trigger . "`n"
	
	   */


		if (index = 8)
            displayText .= "  DAYS: " . value . "   "
        else if (index = 9)
            displayText .= "QTY: " . value . "   "
        else if (index = 10)
            displayText .= "REFILLS:  " . value . "   "
        else if (index = 7)  ; Skip text6 (TCaptionMemo1) for now
			displaytext .= " "
		else
            displayText .= (index = 1 ? "" : " ") . value  ; Space-separated for display
    }
	    ; Append TCaptionMemo1 to the end of displayText
		displayText .= "  " . text6

    Gui, 55: Default
    GuiControl, Text, MyrxText, %controlText%
}
return

hideqo:
	
	Gui, 55: Hide
	SetTimer, MonitorOutptRxWindow, Off
	gui55Hide := 1
	
return


SaveBoosterQuickOrder:
    EnvGet, Username, USERNAME  ; Get current username
    MedQOpath := qopath ; Adjust path if needed
    FileCreateDir, %MedQOpath% 

    Hashfilename := HashText(outputText) 
    filePath := MedQOpath . Username . HashFilename . ".bstrRxqo"

    ; Check if file already exists
    If FileExist(filePath) {
        MsgBox, 262144, CPRS Booster, You ALREADY have this quick order.
        return  ; Exit without overwriting the existing file
    }
	
    GuiControlGet, customTrigger,, CustomTrigger
    FileAppend, %Username%|%outputText%|%displayText%|%customTrigger%`n, %filePath%, UTF-8
	MsgBox, 262144, CPRS Booster Quick Order, QUICK ORDER SAVED!
	Gui, 55: Destroy


	if !(GotRxQOInstructions> 0)
	{
		
		SetTimer, MonitorOutptRxWindow, Off
		SetTimer, MonitorForSpecificWindows, Off
		WinMove, Outpatient Medications,, 10, 700
		MsgBox, 262144, CPRS Booster, You made your first quick order!
		
		MsgBox, 262148, CPRS Booster, Want me to show you how to use these now?  ; Yes/No message box
		IfMsgBox Yes
		{
			MsgBox, 262144, CPRS Booster, Please CLOSE the OUTPATIENT MEDS screen below `n THEN click OK Here
			gosub gui58
			; some variable was set here to 1 and is now missing
			SetTimer, MonitorOutptRxWindow, ON
			SetTimer, MonitorForSpecificWindows, ON
			gosub writeit
		}
		Else
		{
			MsgBox, 262144, CPRS Booster, No problem! You can explore them later.
			SetTimer, MonitorOutptRxWindow, ON
			SetTimer, MonitorForSpecificWindows, ON
		}

	}
	


return



TrimTextBeforeDollar(text)
{
    ; Find the position of the first "$" character
    pos := InStr(text, "$")
    if (pos > 0)
    {
        ; Find the first non-space character to the left of the "$"
        Loop
        {
            pos--
            if (pos <= 0 || !InStr(" `t", SubStr(text, pos, 1)))
                break
        }
        ; Trim the text to the left of this position
        text := SubStr(text, 1, pos)
    }
    return text
}




55cancel:
55GuiClose:
Gui, 55: Destroy
return




;############################################################################################
;########################WIndow monitoring timer###############################################
;############################################################################################




MonitorForSpecificWindows:
if (debugging)
{
	Return ; don't run this if debugging b/c it will show up in log and suck up space
}

if !WinExist("Outpatient Medications") ; don't keep going if outpt med window not there
	{
		Gui, 55: Destroy
		Gui, 60: Destroy
		return
	}


	If WinExist("Outpatient Medications")  ; outpt meds WITHOUT details page
	{
		windowTitle := "Outpatient Medications"
		controlClassNN := "TORComboEdit8"
		CoordMode, Mouse, Screen
		CoordMode, Pixel, Screen
		ControlGet, isVisible, Visible,, %controlClassNN%, %windowTitle%
		if !(isVisible)
		{


			if (gui56FirstOpen = 0)
			{
			gui56firstOpen := 1
			gosub gui56
			}			

		}
	}

If WinExist("Outpatient Medications") && !WinExist("Booster Med Engine")  && (gui55Hide = 0)
{
	windowTitle := "Outpatient Medications"
	controlClassNN := "TORComboEdit8"
	ControlGet, isVisible, Visible,, %controlClassNN%, %windowTitle%
	if (isVisible)
	{
		;MsgBox, 262144, CPRS Booster, visible %ctrlVisible%
		gosub gui55
        return
    }
    
}

; Check if GUI 60 exists already
guiExists := false
Gui, 60: Default
GuiControlGet, OutputVar, Pos, Button1
if (ErrorLevel = 0) {
    guiExists := true
    ; MsgBox, 262144, CPRS Booster, Button exists alraedy
    return
}

; call gui60 prn
If WinExist("Outpatient Medications") && (gui55Hide = 1) && (guiExists = false)
    {
        windowTitle := "Outpatient Medications"
        controlClassNN := "TORComboEdit8"
        ControlGet, isVisible, Visible,, %controlClassNN%, %windowTitle%
        if (isVisible)
        {
            ; Check if GUI 60 exists
        
            Gui, 60: Default
            GuiControlGet, OutputVar, Pos, MakeQuickOrder
            if (ErrorLevel = 1) {
                gosub gui60
            }
	
	}
    
}
return


;############################################################################################
;########################Start HASH logic###############################################
;############################################################################################


; Function to compute MD5 hash of a given string
HashText(text) {
    return bcrypt.hash(text, "MD5")
}



class bcrypt
{
    static hBCRYPT := DllCall("LoadLibrary", "str", "bcrypt.dll", "ptr")

    hash(String, AlgID, encoding := "utf-8")
    {
        AlgID         := this.CheckAlgorithm(AlgID)
        ALG_HANDLE    := this.BCryptOpenAlgorithmProvider(AlgID)
        OBJECT_LENGTH := this.BCryptGetProperty(ALG_HANDLE, "ObjectLength", 4)
        HASH_LENGTH   := this.BCryptGetProperty(ALG_HANDLE, "HashDigestLength", 4)
        HASH_HANDLE   := this.BCryptCreateHash(ALG_HANDLE, HASH_OBJECT, OBJECT_LENGTH)
        this.BCryptHashData(HASH_HANDLE, STRING, encoding)
        HASH_LENGTH   := this.BCryptFinishHash(HASH_HANDLE, HASH_LENGTH, HASH_DATA)
        hash          := this.CalcHash(HASH_DATA, HASH_LENGTH)
        this.BCryptDestroyHash(HASH_HANDLE)
        this.BCryptCloseAlgorithmProvider(ALG_HANDLE)
        return hash
    }

    BCryptOpenAlgorithmProvider(ALGORITHM, FLAGS := 0)
    {
        if (DllCall("bcrypt\BCryptOpenAlgorithmProvider", "ptr*", BCRYPT_ALG_HANDLE
                                                         , "ptr",  &ALGORITHM
                                                         , "ptr",  0
                                                         , "uint", FLAGS) != 0)
            throw Exception("BCryptOpenAlgorithmProvider failed", -1)
        return BCRYPT_ALG_HANDLE
    }

    BCryptGetProperty(BCRYPT_HANDLE, PROPERTY, cbOutput)
    {
        if (DllCall("bcrypt\BCryptGetProperty", "ptr",   BCRYPT_HANDLE
                                                 , "ptr",   &PROPERTY
                                                 , "uint*", pbOutput
                                                 , "uint",  cbOutput
                                                 , "uint*", cbResult
                                                 , "uint",  0) != 0)
            throw Exception("BCryptGetProperty failed", -1)
        return pbOutput
    }

    BCryptCreateHash(BCRYPT_ALG_HANDLE, ByRef pbHashObject, cbHashObject)
    {
        VarSetCapacity(pbHashObject, cbHashObject, 0)
        if (DllCall("bcrypt\BCryptCreateHash", "ptr",  BCRYPT_ALG_HANDLE
                                                 , "ptr*", BCRYPT_HASH_HANDLE
                                                 , "ptr",  &pbHashObject
                                                 , "uint", cbHashObject
                                                 , "ptr",  0
                                                 , "uint", 0
                                                 , "uint", 0) != 0)
            throw Exception("BCryptCreateHash failed", -1)
        return BCRYPT_HASH_HANDLE
    }

    BCryptHashData(BCRYPT_HASH_HANDLE, STRING, encoding := "utf-8")
    {
        VarSetCapacity(pbInput, (StrPut(STRING, encoding) - 1) * ((encoding = "utf-16" || encoding = "cp1200") ? 2 : 1), 0)
        cbInput := StrPut(STRING, &pbInput, encoding) - 1
        if (DllCall("bcrypt\BCryptHashData", "ptr",  BCRYPT_HASH_HANDLE
                                                , "ptr",  &pbInput
                                                , "uint", cbInput
                                                , "uint", 0) != 0)
            throw Exception("BCryptHashData failed", -1)
        return true
    }

    BCryptFinishHash(BCRYPT_HASH_HANDLE, cbOutput, ByRef pbOutput)
    {
        VarSetCapacity(pbOutput, cbOutput, 0)
        if (DllCall("bcrypt\BCryptFinishHash", "ptr",  BCRYPT_HASH_HANDLE
                                                    , "ptr",  &pbOutput
                                                    , "uint", cbOutput
                                                    , "uint", 0) != 0)
            throw Exception("BCryptFinishHash failed", -1)
        return cbOutput
    }

    BCryptDestroyHash(BCRYPT_HASH_HANDLE)
    {
        if (DllCall("bcrypt\BCryptDestroyHash", "ptr", BCRYPT_HASH_HANDLE) != 0)
            throw Exception("BCryptDestroyHash failed", -1)
        return true
    }

    BCryptCloseAlgorithmProvider(BCRYPT_ALG_HANDLE)
    {
        if (DllCall("bcrypt\BCryptCloseAlgorithmProvider", "ptr",  BCRYPT_ALG_HANDLE
                                                          , "uint", 0) != 0)
            throw Exception("BCryptCloseAlgorithmProvider failed", -1)
        return true
    }

    CheckAlgorithm(ALGORITHM)
    {
        static HASH_ALGORITHM := ["MD5"]
        for index, value in HASH_ALGORITHM
            if (value = ALGORITHM)
                return Format("{:U}", ALGORITHM)
        throw Exception("Invalid hash algorithm", -1, ALGORITHM)
    }

    CalcHash(ByRef HASH_DATA, HASH_LENGTH)
    {
        loop % HASH_LENGTH
            HASH .= Format("{:02x}", NumGet(HASH_DATA, A_Index - 1, "uchar"))
        return HASH
    }
}



;############################################################################################
;########################END HASH Logic ###############################################
;############################################################################################


;############################################################################################
;###########START OF DOUBLE DOT Search######################################
;##################GUI 56##########################################################################


class MedQuickOrder {
    __New(username, drug_name, dose, route, frequency, prn, indication, comments, days, quantity, refills, pickup_method, display_text, custom_trigger) {
        this.username := username
        this.drug_name := drug_name
        this.dose := dose
        this.route := route
        this.frequency := frequency
        this.prn := prn
        this.indication := indication
        this.comments := comments
        this.days := days
        this.quantity := quantity
        this.refills := refills
        this.pickup_method := pickup_method
        this.display_text := display_text
        this.custom_trigger := custom_trigger
    }
}

load_med_quick_orders(directory) {
    med_quick_orders := []
    Loop, Files, %directory%\*.bstrRxqo
    {
        FileReadLine, line, %A_LoopFileFullPath%, 1
        if (line != "") {
            elements := StrSplit(line, "|")
            elementCount := elements.MaxIndex()
            if (elementCount == 14) {
                med_quick_order := new MedQuickOrder(elements[1], elements[2], elements[3], elements[4], elements[5], elements[6], elements[7], elements[8], elements[9], elements[10], elements[11], elements[12], elements[13], elements[14])
                med_quick_orders.Push(med_quick_order)
            }
        }
    }
    
    SortMedQuickOrders(med_quick_orders)
    return med_quick_orders
}

SortMedQuickOrders(ByRef arr) {
    Loop % arr.Length() - 1 {
        swapped := false
        Loop % arr.Length() - A_Index {
            if (arr[A_Index].display_text > arr[A_Index + 1].display_text) {
                temp := arr[A_Index]
                arr[A_Index] := arr[A_Index + 1]
                arr[A_Index + 1] := temp
                swapped := true
            }
        }
        if (!swapped)
            break
    }
}






;  disable this line for now :*:..r:: 

gui56:


directory := qopath
med_quick_orders := load_med_quick_orders(directory)

global finaloutput := ""  
global GuiOpen := false  
global selectedIndex := 1 
global filteredItems := []  


Gui, 56: default

WinGetTitle, originalWin, A  

finaloutput := ""  
Gosub CreateListBox  
return

CreateListBox:
    gui, 56: Destroy  
    gui, 56: +AlwaysOnTop
    gui, 56: Font, s11 cblack, Verdana
    gui, 56: Add, Text, vStartText w200 Center x425 y20, START TYPING TO FILTER
	gui, 56: Add, Text,  x900 y20, Press ESCAPE KEY TO EXIT
    gui, 56: Add, Text, vUserText w200 Center x425 y20,  
    gui, 56: Add, ListBox, vGui_ListBox gListBoxClickHandler H500 w1000 x50 y60,  
    gui, 56: Show, x100 y100 h600 w1100, Select Booster Quick Order  
    selectedIndex := 1  
    Gosub UpdateListBox  
    Gosub LoopInput  
return



;############################################################################################
;############START KEYBOARD INPUT LOOP#################################################
;############################################################################################


LoopInput:
lastChar := ""  ; Variable to store last captured character
Loop
{
	IfWinNotActive, Select Booster Quick Order && if !(gui56firstopen = 1) ; This means if user goes to another window and gui56firstopen is not 1, destroy the search gui
    {

		SplashTextOn ,150 ,100, CPRS Booster, HERE
sleep 600
SplashTextOff
        
        if (lastChar != "")  ; If a character was captured, send it to the active window
        {
            Send, %lastChar%
        }
        gui, 56: Destroy
        gui56FirstOpen := 0
        return  ; Exit the loop and function
    }

    Input, OutputVar, L1, {Esc}{Enter}{Backspace}{Up}{Down}  


	if (ErrorLevel = "EndKey:Enter") 
	{

		Gosub SelectListBoxItem 
		gui, 56: Destroy 
        gui56FirstOpen := 0

	}

    /*if (ErrorLevel = "EndKey:Enter") {
        if (filteredItems.Length() = 0) {
            gui, 56: Destroy  
			SplashTextOn ,150 ,100, CPRS Booster, LEN = 0
			sleep 6000
			SplashTextOff
            return  
        } else {

			SplashTextOn ,150 ,100, CPRS Booster, LEN > 0
			sleep 6000
			SplashTextOff
            Gosub SelectListBoxItem  
        }
        return
    }
		*/
    if (ErrorLevel = "EndKey:Backspace") {
        if (StrLen(finaloutput) > 0)
            finaloutput := SubStr(finaloutput, 1, -1)
    } else if (ErrorLevel = "EndKey:Up") {
        Gosub MoveUp
    } else if (ErrorLevel = "EndKey:Down") {
        Gosub MoveDown
    } 
    else if (ErrorLevel = "EndKey:Escape") {
        gui, 56: Destroy 
        Open := 0 
        return
    }
    else {
        lastChar := OutputVar  ; Store the last captured character
        finaloutput .= OutputVar
        If (gui56firstOpen = 1) 
			{
				; WinActivate, Outpatient Medications
				send %lastChar% 
			} ; Send the last character directly to the outpt med search
  
    }
    
    StringUpper, finaloutput, finaloutput  
    Gosub UpdateListBox  
}
return


;############################################################################################
;################END keyboard loop###############################################
;############################################################################################

UpdateListBox:
    if (finaloutput = "") {
        GuiControl, Hide, UserText
        GuiControl, Show, StartText
    } else {
        GuiControl, Hide, StartText
        GuiControl, Show, UserText
        GuiControl, text, UserText, %finaloutput%
    }

    ;newList := "|GO TO MED ORDER PAGE|"  
    newList := "|"
    filteredItems := []  

    for index, order in med_quick_orders {
        if InStr(order.display_text, finaloutput) {
            filteredItems.Push(order)
        }
    }

    SortMedQuickOrders(filteredItems)  

    for index, order in filteredItems {
        newList .= order.display_text . "|"
        
    }
    newList .= "NONE OF THESE: GO TO MED ORDER PAGE|" 
    GuiControl,, Gui_ListBox, %newList%  

    if (selectedIndex > filteredItems.Length() + 2)  
        selectedIndex := 1

    GuiControl, Choose, Gui_ListBox, %selectedIndex%
return

MoveUp:
    if (selectedIndex > 1)
        selectedIndex -= 1
    GuiControl, Choose, Gui_ListBox, %selectedIndex%
    Sleep, 50  
return

MoveDown:
    if (selectedIndex < filteredItems.Length() + 2)  
        selectedIndex += 1
    GuiControl, Choose, Gui_ListBox, %selectedIndex%
    Sleep, 50  
return
		
SelectListBoxItem:
    GuiControlGet, selectedItem, , Gui_ListBox

	; MsgBox, 262144, CPRS Booster, %selectedItem%
    
    if (selectedItem = "NONE OF THESE: GO TO MED ORDER PAGE") {
        gui, 56: Destroy  
	
        Gosub GotoMedOrder
        return
    }

	if (selectedItem != "") 
		{
			gui, 56: Destroy  
            gui56FirstOpen := 0
			for index, order in filteredItems
			{
            if (order.display_text = selectedItem) 
				{
                global selectedOrder := order  ; make available for the subroutine
                Gosub ReadAndSetValuesFromFile
                return
            	}
        	}
    	}
	/*
    if (selectedItem != "")
    {
        gui, 56: Destroy  
        for index, order in filteredItems {
            if (order.display_text = selectedItem) {
                ; Restore full selection logic
                output := "Username: " . order.username . "`n"
                output .= "Drug Name: " . order.drug_name . "`n"
                output .= "Dose: " . order.dose . "`n"
                output .= "Route: " . order.route . "`n"
                output .= "Frequency: " . order.frequency . "`n"
                output .= "PRN: " . order.prn . "`n"
                output .= "Indication: " . order.indication . "`n"
                output .= "Comments: " . order.comments . "`n"
                output .= "Days: " . order.days . "`n"
                output .= "Quantity: " . order.quantity . "`n"
                output .= "Refills: " . order.refills . "`n"
                output .= "Pickup Method: " . order.pickup_method . "`n"
                output .= "Display Text: " . order.display_text . "`n"
                output .= "Custom Trigger: " . order.custom_trigger . "`n"
                output .= "----------------------------------------`n"
                
                tempFile := A_Temp "\selected_quick_order.txt"
                FileDelete, %tempFile%
                FileAppend, %output%, %tempFile%
                Run, notepad.exe %tempFile%
                break
            }
        }
    }
*/
return

GotoMedOrder:
    ;MsgBox, "Going to Med Order Page..."
	
		keystrokes := "Orders|Down " . SiteSpecificDownKeysToMedOrderMenu . "|Enter|w:Outpatient Medications|"  ; go to orders tab

		RunningRxQO := 1 ; prevents yellowscreen from popping up in testingnewqo	
		gosub testingnewQO
		WinWait, Outpatient Medications, , 3

return

ListBoxClickHandler:
    if (A_GuiEvent = "DoubleClick")  
    {
        send {enter}
    }
return

56GuiClose:
56GuiEscape:
    gui, 56: Destroy  
    gui56FirstOpen := 0
	sleep 100
	send {esc}
    ; send {enter}  ; end key for keyboard input loop
	sleep 50
	send {esc} ; end key for keyboard input loop
return

;############################################################################################
;#####################Stop Counting Down strokes for Med QO setup##############################
;############################################################################################
stopCounting:
InputBox, SiteSpecificDownKeysToMedOrderMenu, CPRS Booster, How Many Times Did you Press DOWN?, , 300, 150
if (ErrorLevel)
{
	MsgBox, 262144, CPRS Booster, Cancelled. Come Back Any time!
	return
}

MsgBox, 262144, CPRS Booster, Let's Test It. Click OK and let's see if we get to outpatient Med orders screen


keystrokes := "Orders|Down " . SiteSpecificDownKeysToMedOrderMenu . "|Enter|w:Outpatient Medications|"  ; go to orders tab

RunningRxQO := 1 ; prevents yellowscreen from popping up in testingnewqo	
gosub testingnewQO
WinWait, Outpatient Medications, , 3

IfWinExist, Outpatient Medications
{
	Gosub, writeit
	MsgBox, 262144, CPRS Booster, Good Work! All Set
}
else
{
MsgBox, 262148, CPRS Booster, Hmmm. Didn't work. Want to try it again? ; 4100 ensures the MsgBox is always on top
SiteSpecificDownKeysToMedOrderMenu := 0

IfMsgBox No
	return
	MsgBox, 262144, CPRS Booster, Close any open CPRS windows other than the main CPRS window THEN click OK
	goto ReadAndSetValuesFromFile

}

return


;############################################################################################
;###############RUN THE MEDICATION QUICK ORDER######################################
;############################################################################################

ReadAndSetValuesFromFile:   ;no longer from file: actually passed from above


SetKeyDelay, 0, 0  ; 0ms between keys, 10ms between press and release

if !(SiteSpecificDownKeysToMedOrderMenu > 0)
{
MsgBox, 262145, One Time Set up, One Time Set Up Needed (takes about 1 min)  ; 4100 ensures the MsgBox is always on top and includes OK/Cancel buttons

IfMsgBox Cancel		
	return

gosub gui57

return  
}

SetTimer, MonitorForSpecificWindows, Off  ; We Don't want the screen to MAKE a new QO popping up now
keystrokes := "Orders|Down " . SiteSpecificDownKeysToMedOrderMenu . "|Enter|w:Outpatient Medications|"  ; go to orders tab


RunningRxQO := 1 ; prevents yellowscreen from popping up in testingnewqo	
gosub testingnewQO
RunningRxQO := 0 ; reset
    ; Ensure an order was selected
    if (!IsObject(selectedOrder)) {
        MsgBox, 262144, CPRS Booster, No valid order selected.
        return
    }

    ; Extract control values from selectedOrder object
    drugName := selectedOrder.drug_name
    dose := selectedOrder.dose
    route := selectedOrder.route
    frequency := selectedOrder.frequency
    prn := selectedOrder.prn
    indication := selectedOrder.indication
    comments := selectedOrder.comments
    days := selectedOrder.days
    quantity := selectedOrder.quantity
    refills := selectedOrder.refills
    pickupMethod := selectedOrder.pickup_method

    ; Activate the outpatient medication window
    windowTitle := "Outpatient Medications"
    WinActivate, %windowTitle%

    ; Wait for the FIRST OUTPT Med Search window to be present
    timeout := 20
	startTime := A_TickCount
	while (A_TickCount - startTime < timeout * 1000) 
		{
		ControlGet, isVisible, Visible,, TEdit1, %windowTitle%
		if (isVisible) {
			break
		}
		Sleep, 200
	}
	if (!isVisible) {
		MsgBox, 262144, CPRS Booster, Something Went Wrong
		return
	}
      
    

    if (drugName) {
		pasteit(drugName)
        ;send %drugName%
        sleep 50

        ; Wait until the control's value matches the drug name
        startTime := A_TickCount
        while (A_TickCount - startTime < timeout * 1000) {
            ControlGetText, controlText, TEdit1, %windowTitle%
            if (controlText = drugName) {
                break
            }
            Sleep, 200
        }

        Sleep, 600
        send {Enter}
        sleep 600
		; Selected Medication Allergy Check
        ;send {Enter}
        ;sleep 1200
    }

; Wait for the window to be active
timeout := 20
startTime := A_TickCount
SawAllergyWindow := 0
while (A_TickCount - startTime < timeout * 1000) 
{
	; Check if the control is visible: I THINK THIS VERIFIES the rx DETAILS window is open
	ControlGet, isVisible, Visible,, TORComboEdit8, %windowTitle%
	if (isVisible) {
		Gosub activecontrols
		break
	}

	If (SawAllergyWindow) 
	{
		Sleep, 200
		ControlGet, isListViewVisible, Visible,, TCaptionListView1, %windowTitle%
		if (isListViewVisible) {

			; SplashTextOn ,150 ,100, CPRS Booster, User Cancelled
			; sleep 1000
			; SplashTextOff
			return ; Exit the subroutine if TCaptionListView1 is visible after the allergy window: user cancelled
		}
	}

	; Check if the window with the title "Selected Medication Allergy Check" is active
	if WinExist("Selected Medication Allergy Check") {
		SawAllergyWindow := 1
		
		WinWaitClose, Selected Medication Allergy Check, , 15

		; Reset the start time and timeout for the outer loop
		startTime := A_TickCount
	}
	
	Sleep, 100
}



	send {tab 2} ; get to the accept order button
	SplashTextOn ,150 ,100, CPRS Booster, Press SPACEBAR TO ACCEPT ORDER
sleep 2500
SplashTextOff

; ******************************now we need to wait until user is done with order details window

timeout := 5
startTime := A_TickCount
while (A_TickCount - startTime < timeout * 1000) 
		{
			; Check if the control is visible: I THINK THIS VERIFIES the rx DETAILS window is open
			ControlGet, isVisible, Visible,, TORComboEdit8, %windowTitle%
			if !(isVisible)
			{
				break
			}

		}

	SetTimer, MonitorForSpecificWindows, ON  ; resume monitoring for med details screen to allow new rx QOs to be made
return
;############################################################################################
;####################END OF RUNNING MEDICATION QUICK ORDER###########################################
;############################################################################################


activecontrols:
    ; Set control values directly
    ControlSetText, Tedit1, %drugName%, %windowTitle%  ; Drug Name
    ControlSetText, TORComboEdit9, %dose%, %windowTitle%  ; Dose
    ControlSetText, TORComboEdit8, %route%, %windowTitle%  ; Route
    ControlSetText, TORComboEdit7, %frequency%, %windowTitle%  ; Frequency
    ControlSetText, TORComboEdit2, %indication%, %windowTitle%  ; Indication
    ControlSetText, TCaptionMemo1, %comments%, %windowTitle%  ; Comments
    ControlSetText, TCaptionEdit3, %days%, %windowTitle%  ; Days
    ControlSetText, TCaptionEdit2, %quantity%, %windowTitle%  ; Quantity
    ControlSetText, TCaptionEdit1, %refills%, %windowTitle%  ; Refills

    ; Handle PRN Checkbox
    if (prn = "AS NEEDED") {
        Control, Check,, TCheckBox1, %windowTitle%
    } else {
        Control, Uncheck,, TCheckBox1, %windowTitle%
    }

    ; Handle Pickup Method Radio Buttons
    Control, Uncheck,, TRadioButton1, %windowTitle%
    Control, Uncheck,, TRadioButton2, %windowTitle%
    Control, Uncheck,, TRadioButton3, %windowTitle%

    if (pickupMethod = "PARK") {
        Control, Check,, TRadioButton1, %windowTitle%
    } else if (pickupMethod = "MAIL") {
        Control, Check,, TRadioButton2, %windowTitle%
    } else if (pickupMethod = "WINDOW") {
        Control, Check,, TRadioButton3, %windowTitle%
    }

return

;############################################################################################
;#############OLD INCLUDE FILE: now in code: GET Browser##############################################
;############################################################################################



ModernBrowsers := "ApplicationFrameWindow,Chrome_WidgetWin_0,Chrome_WidgetWin_1,Maxthon3Cls_MainFrm,MozillaWindowClass,Slimjet_WidgetWin_1"
LegacyBrowsers := "IEFrame,OperaWindowClass"




	; nTime := A_TickCount
	; SMUrl := GetActiveBrowserURL()
	
	; WinGetClass, sClass, A
	;  If (SMUrl != "")
	;	MsgBox, % "The URL is """ SMUrl """`nEllapsed time: " (A_TickCount - nTime) " ms (" sClass ")"
	;  Else If sClass In % ModernBrowsers "," LegacyBrowsers
	; 	MsgBox, % "The URL couldn't be determined (" sClass ")"
	;   Else
	;	MsgBox, % "Not a browser or browser not supported (" sClass ")"


GetActiveBrowserURL() {
	global ModernBrowsers, LegacyBrowsers
	WinGetClass, sClass, A
	If sClass In % ModernBrowsers
		Return GetBrowserURL_ACC(sClass)
	Else If sClass In % LegacyBrowsers
		Return GetBrowserURL_DDE(sClass) ; empty string if DDE not supported (or not a browser)
	Else
		Return ""
}

; "GetBrowserURL_DDE" adapted from DDE code by Sean, (AHK_L version by maraskan_user)
; Found at http://autohotkey.com/board/topic/17633-/?p=434518

GetBrowserURL_DDE(sClass) {
	WinGet, sServer, ProcessName, % "ahk_class " sClass
	StringTrimRight, sServer, sServer, 4
	iCodePage := A_IsUnicode ? 0x04B0 : 0x03EC ; 0x04B0 = CP_WINUNICODE, 0x03EC = CP_WINANSI
	DllCall("DdeInitialize", "UPtrP", idInst, "Uint", 0, "Uint", 0, "Uint", 0)
	hServer := DllCall("DdeCreateStringHandle", "UPtr", idInst, "Str", sServer, "int", iCodePage)
	hTopic := DllCall("DdeCreateStringHandle", "UPtr", idInst, "Str", "WWW_GetWindowInfo", "int", iCodePage)
	hItem := DllCall("DdeCreateStringHandle", "UPtr", idInst, "Str", "0xFFFFFFFF", "int", iCodePage)
	hConv := DllCall("DdeConnect", "UPtr", idInst, "UPtr", hServer, "UPtr", hTopic, "Uint", 0)
	hData := DllCall("DdeClientTransaction", "Uint", 0, "Uint", 0, "UPtr", hConv, "UPtr", hItem, "UInt", 1, "Uint", 0x20B0, "Uint", 10000, "UPtrP", nResult) ; 0x20B0 = XTYP_REQUEST, 10000 = 10s timeout
	sData := DllCall("DdeAccessData", "Uint", hData, "Uint", 0, "Str")
	DllCall("DdeFreeStringHandle", "UPtr", idInst, "UPtr", hServer)
	DllCall("DdeFreeStringHandle", "UPtr", idInst, "UPtr", hTopic)
	DllCall("DdeFreeStringHandle", "UPtr", idInst, "UPtr", hItem)
	DllCall("DdeUnaccessData", "UPtr", hData)
	DllCall("DdeFreeDataHandle", "UPtr", hData)
	DllCall("DdeDisconnect", "UPtr", hConv)
	DllCall("DdeUninitialize", "UPtr", idInst)
	csvWindowInfo := StrGet(&sData, "CP0")
	StringSplit, sWindowInfo, csvWindowInfo, `" ;"; comment to avoid a syntax highlighting issue in autohotkey.com/boards
	Return sWindowInfo2
}

GetBrowserURL_ACC(sClass) {
	global nWindow, accAddressBar
	If (nWindow != WinExist("ahk_class " sClass)) ; reuses accAddressBar if it's the same window
	{
		nWindow := WinExist("ahk_class " sClass)
		accAddressBar := GetAddressBar(Acc_ObjectFromWindow(nWindow))
	}
	Try sURL := accAddressBar.accValue(0)
	If (sURL == "") {
		WinGet, nWindows, List, % "ahk_class " sClass ; In case of a nested browser window as in the old CoolNovo (TO DO: check if still needed)
		If (nWindows > 1) {
			accAddressBar := GetAddressBar(Acc_ObjectFromWindow(nWindows2))
			Try sURL := accAddressBar.accValue(0)
		}
	}
	If ((sURL != "") and (SubStr(sURL, 1, 4) != "http")) ; Modern browsers omit "http://"
		sURL := "http://" sURL
	If (sURL == "")
		nWindow := -1 ; Don't remember the window if there is no URL
	Return sURL
}


GetAddressBar(accObj) {
	Try If ((accObj.accRole(0) == 42) and IsURL(accObj.accValue(0)))
		Return accObj
	Try If ((accObj.accRole(0) == 42) and IsURL("http://" accObj.accValue(0))) ; Modern browsers omit "http://"
		Return accObj
	For nChild, accChild in Acc_Children(accObj)
		If IsObject(accAddressBar := GetAddressBar(accChild))
			Return accAddressBar
}

IsURL(sURL) {
	Return RegExMatch(sURL, "^(?<Protocol>https?|ftp)://(?<Domain>(?:[\w-]+\.)+\w\w+)(?::(?<Port>\d+))?/?(?<Path>(?:[^:/?# ]*/?)+)(?:\?(?<Query>[^#]+)?)?(?:\#(?<Hash>.+)?)?$")
}


Acc_Init()
{
	static h
	If Not h
		h:=DllCall("LoadLibrary","Str","oleacc","Ptr")
}
Acc_ObjectFromWindow(hWnd, idObject = 0)
{
	Acc_Init()
	If DllCall("oleacc\AccessibleObjectFromWindow", "Ptr", hWnd, "UInt", idObject&=0xFFFFFFFF, "Ptr", -VarSetCapacity(IID,16)+NumPut(idObject==0xFFFFFFF0?0x46000000000000C0:0x719B3800AA000C81,NumPut(idObject==0xFFFFFFF0?0x0000000000020400:0x11CF3C3D618736E0,IID,"Int64"),"Int64"), "Ptr*", pacc)=0
	Return ComObjEnwrap(9,pacc,1)
}
Acc_Query(Acc) {
	Try Return ComObj(9, ComObjQuery(Acc,"{618736e0-3c3d-11cf-810c-00aa00389b71}"), 1)
}
Acc_Children(Acc) {
	If ComObjType(Acc,"Name") != "IAccessible"
		ErrorLevel := "Invalid IAccessible Object"
	Else {
		Acc_Init(), cChildren:=Acc.accChildCount, Children:=[]
		If DllCall("oleacc\AccessibleChildren", "Ptr",ComObjValue(Acc), "Int",0, "Int",cChildren, "Ptr",VarSetCapacity(varChildren,cChildren*(8+2*A_PtrSize),0)*0+&varChildren, "Int*",cChildren)=0 {
			Loop %cChildren%
				i:=(A_Index-1)*(A_PtrSize*2+8)+8, child:=NumGet(varChildren,i), Children.Insert(NumGet(varChildren,i-8)=9?Acc_Query(child):child), NumGet(varChildren,i-8)=9?ObjRelease(child):
			Return Children.MaxIndex()?Children:
		} Else
			ErrorLevel := "AccessibleChildren DllCall Failed"
	}

} 



;############################################################################################
;#####################END get browser##########################################
;############################################################################################

;############################################################################################
;##############################GUi 57############################################
;############################################################################################
gui57:

Gui, 57:Add, Picture, x2 y2 h493 w649 , \\v23.med.va.gov\apps\GUI\Local_Site_GUI\MIN\CPRSBOOSTER\Pictures\RxQuickOrderSetup.PNG

Gui, 57:Font, S12 CDefault, Verdana
Gui, 57:Add, Button, x300 y550 w100 h30 gOK57, OK  ; Add OK button at the bottom middle

Gui, 57:Show, x100 y100 h600 w700, Medication Quick Order
Return



ok57:
GuiClose57:
Gui, 57:Destroy
MedQODownCount = 1

MsgBox, 262144, CPRS Booster, REMEMBER: PRESS F1 when Done counting ; Always on top with OK/Cancel buttons
gosub getOrderStart ; they will take the next step by pressing F1 (see that logic)
					; and then they'll go to stopcounting above.
Return

;############################################################################################
;##################GUI58 Gui 58########################################################
;############################################################################################


gui58:

Gui, 58:Add, Picture, x2 y2 h644 w980 , \\v23.med.va.gov\apps\GUI\Local_Site_GUI\MIN\CPRSBOOSTER\Pictures\GetToRxQO.PNG

Gui, 58:Font, S12 CDefault, Verdana
Gui, 58:Add, Button, x400 y650 w300 h30 gOK58, OK  ; Add OK button at the bottom middle

Gui, 58:Show, x80 y80 h690 w1000, How to Access Quick Orders
Return



ok58:
GuiClose58:
Gui, 58:Destroy
MsgBox, 262144, CPRS Booster, Next I'll show you how the quick order display works!
gosub gui59
return



;############################################################################################
;##################GUI59 Gui 59########################################################
;############################################################################################


gui59:

Gui, 59:Add, Picture, x2 y2 h644 w980 , \\v23.med.va.gov\apps\GUI\Local_Site_GUI\MIN\CPRSBOOSTER\Pictures\UseQOGUI.PNG

Gui, 59:Font, S12 CDefault, Verdana
Gui, 59:Add, Button, x400 y650 w300 h30 gOK59, OK  ; Add OK button at the bottom middle

Gui, 59:Show, x80 y80 h690 w1000, How to USE Quick Orders
Return



ok59:
GuiClose59:
Gui, 59:Destroy

SplashTextOn ,150 ,100, CPRS Booster, That's it!
sleep 1400
SplashTextOff
return


;############################################################################################
;#################################Gui60 Gui, 60#################################################
;############################################################################################

gui60: ; put Use Booster Quick Order text link on the screen

displayrxWinY := rxwinY - 26
displayRxwinX := rxWinX + 400

Gui, 60: Destroy ; Ensure the GUI is destroyed before creating it
Gui, 60: +AlwaysOnTop +ToolWindow -Caption +Owner ; Always on top, no title bar
Gui, 60: Color, FFFBF0  ; Set the GUI background color to the specified color

Gui, 60: Font, s9 cBlue underline, Verdana ; Set font size, color, and underline for the text
Gui, 60: Add, Text, gMakeRxQuickOrder w200 h18 Center, Use Booster Quick Order ; Add the clickable text
Gui, 60: Show, x%displayrxWinX% y%displayrxWinY% h18 NoActivate ; Show the GUI without activating it

return

MakeRxQuickOrder:
gosub gui56
return

;############################################################################################
;#####################GUI61 Gui 61   AI HELPER######################################
;############################################################################################
Gui61:


PreloadedSummaryName := ""
PreloadedPromptText := ""


DropDownItems := ""  ; Initialize the dropdown items
AIFilePath := AIPath . "*.bstrPmpt"
Loop, Files, %AIfilepath%  ; Loop through all .bstrPmpt files in the directory
{
	MsgBox, 262144, CPRS Booster, INSIDE HERE
	FileName := RegExReplace(A_LoopFileName, "\.bstrPmpt$")  ; Remove the file extension
	DropDownItems .= FileName . "|"  ; Add the file name to the dropdown items
}

Gui, 61:Add, DropDownList, x22 y99 w560 h40 vSummaryType, %DropDownItems%  ; Populate the dropdown list
Gui, 61:Add, Button, x12 y169 w310 h40 gEditAIInstructions, Edit AI Instructions ('Prompt') For Summary Type Above
Gui, 61:Add, Button, x352 y169 w230 h40 gCreateNewSummaryType, Create New Summary Type
Gui, 61:Add, Text, x22 y49 w540 h40 , SELECT TYPE OF SUMMARY YOU WANT:
Gui, 61:Add, Button, x382 y319 w110 h40 gMakeSummary, Make My Summary!
Gui, 61:Add, Button, x512 y319 w110 h40 gCancelSummary, CANCEL

Gui, 61:Show, x127 y87 h379 w668, Booster AI Helper
Return

EditAIInstructions:
	GuiControlGet, SelectedSummaryType,, SummaryType
	if (SelectedSummaryType = "")
	{
		MsgBox, 262144, CPRS Booster, Please select a summary type from drop down below
		Return
	}
	;MsgBox, 262144, CPRS Booster, Editing AI instructions for: %SelectedSummaryType%
	; Add logic to open the editor for the selected summary type
Return

CreateNewSummaryType:
	; Ensure the 'AI' subfolder exists under the 'onedrivelocal' path
	
	gosub gui62
Return

MakeSummary:
	GuiControlGet, SelectedSummaryType,, SummaryType
	if (SelectedSummaryType = "")
	{
		MsgBox, 262144, CPRS Booster, Please select a summary type first.
		Return
	}
	;MsgBox, 262144, CPRS Booster, Generating summary for: %SelectedSummaryType%
	; Add logic to generate the summary
Return

CancelSummary:
61GuiClose:
Gui, 61:Destroy
Return


;############################################################################################
;############################################################################################
;############################################################################################


;############################################################################################
;#######################GUI62 gui 62  NEW/Edit AI PROMPT#################################################
;############################################################################################
Gui62:

Gui, 61:Destroy

Gui, 62:Destroy ; Ensure no duplicate GUI
Gui, 62:Font, s12, Verdana ; Set font size to 12
Gui, 62:Add, Text, x42 y19 w640 h70 , Create/Edit AI Prompts
Gui, 62:Add, Edit, x32 y209 w650 h330 vPromptText, %PreloadedPromptText%
Gui, 62:Add, Button, x42 y579 w200 h30 gSavePrompt, SAVE
Gui, 62:Add, Button, x262 y579 w200 h30 gDeleteSummaryType, DELETE
Gui, 62:Add, Button, x482 y579 w200 h30 gCancelPrompt, CANCEL
Gui, 62:Add, Text, x42 y179 w190 h20 , PROMPT TEXT:
Gui, 62:Add, Text, x42 y109 w190 h20 , NAME OF SUMMARY
Gui, 62:Add, Edit, x32 y139 w330 h20 vSummaryName, %PreloadedSummaryName%
Gui, 62:Font, s9 cBlue underline, Verdana ; Add link style
Gui, 62:Add, Text, x450 y19 w200 h20 gCreateNewNoteType, Create New Note Type/Prompt

; Header text
Gui, 62:Font, cBlack norm s10, Verdana
Gui, 62:Add, Text, x450 y70 w300 h20, HOW TO USE AMBIENT SCRIBING:
Gui, 62:Font, s9 cBlue underline, Verdana ; Add link style
Gui, 62:Add, Text, x450 y95 w200 h40 gAmbScribeHelp, Printed Instructions
Gui, 62:Add, Text, x450 y126 w200 h20 gAmbScribeHelpVid, Video Instructions (5 min)
; https://tinyurl.com/AmbScribeVideo
Gui, 62:Show, x155 y124 h626 w720, Create/Edit AI Prompt
Return

AmbscribehelpVid:
	Gui, 62:Destroy ; Ensure no duplicate GUI
	run https://tinyurl.com/AmbScribeVideo
	; this doc is in the Booster Teams group's files
	
return


AmbScribeHelp:
	Gui, 62:Destroy ; Ensure no duplicate GUI
	run https://tinyurl.com/BoosterAmbScribe
	; this doc is in the Booster Teams group's files
	goto gui64
return 

CreateNewNoteType:
	GuiControl,, SummaryName,  ; Clear the SummaryName field
	GuiControl,, PromptText,   ; Clear the PromptText field
Return
SavePrompt:
	Gui, 62:Submit, NoHide
	if (SummaryName = "" || PromptText = "")
	{
		MsgBox, 262144, CPRS Booster, Please fill in both the summary name and prompt text.
		Return
	}

	; Prevent saving if 'Booster' is in the summary name (case-insensitive)
	if (InStr(SummaryName, "Booster"))
	{
		MsgBox, 262144, CPRS Booster, You cannot change built in Booster notes BUT you `n can change the note name and save a custom copy
		Return
	}

	; Replace line breaks and carriage returns with a placeholder (e.g., `{Lbreak}`)
	PromptText := StrReplace(PromptText, "`n", "{Lbreak}")
	PromptText := StrReplace(PromptText, "`r", "{Lbreak}")

	; NOTE: the above IF is failing if there is essentially a save AS thing happening`
	FilePath := AIPath . A_UserName . " - " . SummaryName . ".bstrAD"
	PromptText := A_UserName . "|" . SummaryName . "|" . PromptText

	FileDelete, %FilePath% ; Overwrite if it exists
	FileAppend, %PromptText%, %FilePath%
	MsgBox, 262144, CPRS Booster, Prompt saved successfully!
	Gui, 62:Destroy
	gui, 64: Show
	comingfromAmbientDictation := False  ; reset
	Global lastprompttype := SummaryName ; save the last prompt type	
	loadAndUpdatePrompts() ; update object displayed in Gui 64 (AD bar)
Return

DeleteSummaryType:
	Gui, 62:Submit, NoHide
	if (SummaryName = "")
	{
		MsgBox, 262144, CPRS Booster, Please enter the name of the summary type to delete.
		Return
	}

		if (InStr(SummaryName, "Booster"))
	{
		MsgBox, 262144, CPRS Booster, You cannot delete built in Booster notes
		Return
	}
	
	if (comingfromAmbientDictation = True) ; If coming from AD ; sets the file extesion
	{
		FilePath := AIPath . A_UserName . " - " . SummaryName . ".bstrAD"
		; FilePath := AIPath . SummaryName . ".bstrAD"
		; MsgBox, 262144, CPRS Booster, %filePath%
	}
	else ; If coming from AD
	{
	FilePath := AIPath . SummaryName . ".bstrPmpt"
	}

	
	if FileExist(FilePath)
	{
		FileDelete, %FilePath%
		MsgBox, 262144, CPRS Booster, Summary type deleted successfully!
		Gui, 62:Destroy
	}
	else
	{
		MsgBox, 262144, CPRS Booster, Summary type not found.
	}
	loadAndUpdatePrompts() ; update object displayed in Gui 64 (AD bar)
	gui, 64: Show
	; comingfromAmbientDictation := False  ; reset  ; IF someone loops here on AD toolbar this gets reset
Return

CancelPrompt:
62GuiClose:
	Gui, 62:Destroy
	gui, 64: Show
	comingfromAmbientDictation := False  ; reset
Return

;############################################################################################
;############################Code status pop up fix GUI##############################################
;###############################gui63 gui 63#############################################################


gui63:

Gui, 63:Font, S14 CDefault, Verdana
Gui, 63:Add, Text, x72 y19 w420 h30 , The CPRS Code Status Window Opened
Gui, 63:Font, S12 CDefault, Verdana
Gui, 63:Add, Text, x42 y59 w470 h40 , Booster sometimes accidentally opens the CPRS Code Status Window. Did you do it or Booster?
; Generated using SmartGUI Creator 4.0
Gui, 63:Add, Button, x32 y109 w230 h40 , I opened the Code Status window
Gui, 63:Add, Button, x282 y109 w230 h40 , Booster must have done it!
gui, 63: +AlwaysOnTop +ToolWindow +Owner
Gui, 63:Show, x500 y500 h165 w537, CPRS Booster: Who Did It?
Return

63GuiClose:
Gui 63:Destroy

; Button Handlers
63ButtonIopenedtheCodeStatuswindow:
Gui 63:Destroy
;MsgBox, You opened the Code Status window.
SplashTextOn ,150 ,100, CPRS Booster, Ok. Continue with your work.
sleep 1300
SplashTextOff
Return

63ButtonBoostermusthavedoneit!:
Gui 63:Destroy



	winclose Resuscitation Status	
	SplashTextOn ,150 ,100, CPRS Booster, Sorry about that! `n I need to restart myself!
	sleep 3000
	SplashTextOff
	reload 

; MsgBox, Booster must have done it!
Return


;############################################################################################
;###############################GUI 64, gui64 AMBIENT DICTATION Toolbar############################################################

; Load AD prompts and update the NoteType dropdown
LoadAndUpdatePrompts()
{
    Global AIPath, ADPrompts, lastprompttype
	noteTypes := ""  ; reset object
    filePattern := AIPath . "*.bstrAD"
    ADPrompts := {}  ; reset object
	; MsgBox, 262144, CPRS Booster, %lastprompttype%
	if (lastprompttype = "") 
	{
    ; noteTypes := "Clinic Note||"  ; ensure 'Clinic Note' is the default and first option
	lastprompttype := "Clinic Note - BOOSTER" ; set the default to clinic note
	}
	
	/*
	else
	{
	noteTypes := "Clinic Note|"
	}

	*/

    Loop, Files, %filePattern%
    {
		; MsgBox, 262144, CPRS Booster, %A_LoopFileFullPath%

        FileRead, content, %A_LoopFileFullPath%
        Loop, Parse, content, `n, `r
        {
            line := A_LoopField
            if line =
                continue
            fields := StrSplit(line, "|")
            if (fields.Length() >= 3)
            {
                user := fields[1]
                noteType := fields[2]
                prompt := fields[3]

				; Now reverse the {Lbreak} replacements
				prompt := StrReplace(prompt, "{Lbreak}", "`n")	
                ADPrompts[noteType] := { User: user, Prompt: prompt }
            }
        }
    }

    for noteType in ADPrompts
    {
        ; if (noteType != "Clinic Note" && noteType != "Add/Edit Note")  ; Exclude 'Clinic Note' and 'Add/Edit' from being added again
           ;  noteTypes .= noteType . "|"
		
		 If (noteType = lastprompttype) ; if this is the last prompt type, set it as the default
		 { 
			noteTypes .= noteType . "||"
		 }
		 Else
		{
 		noteTypes .= noteType . "|"
		}
    }
   ;  noteTypes .= "Add/Edit"  ; ensure 'Add/Edit' is always the last option
    GuiControl, 64:, NoteType, |%noteTypes%
	; MsgBox, 262144, CPRS Booster, |%noteTypes% 
}



;############################################################################################
;################Ambient Dictation Toolbar:Main#######################################
;############################################################################################

gui64:



If (AmbdictationDone = 1)   
{		
MsgBox, 262144, CPRS Booster, Welcome to Ambient Scribing!`n`n The Scribe toolbar you will see next can be MOVED by grabbing the LEFT side of it.
MsgBox, 262144, CPRS Booster, As soon as you are done recording your conversation with the patient, `n`n Click 'Create AI Note'
MsgBox, 262144, CPRS Booster, Booster will place all information VA GPT needs on the clipboard.`n`n When Booster pulls up the VA GPT window, `n`n Paste the information from the clipboard into the VA GPT window.`n`n Then press ENTER to send it to the AI.
MsgBox, 262144, CPRS Booster, You can then copy the AI response and paste it into your CPRS note.
MsgBox, 262144, CPRS Booster: IMPORTANT - AI MAKES MISTAKES: PROOFREAD, *****AI Makes Mistakes*****`n`n THE AI Note MUST be proofread!`n`n YOU ARE SOLELY RESPONSIBLE FOR THE ACCURACY OF THE SIGNED NOTE!!
AmbdictationDone := 2
gosub writeit
 }

Gui, 64: Destroy
Gui, 64: +AlwaysOnTop -Caption +ToolWindow
Gui, 64: Font, s10, Verdana
Gui, 64: Color, 0xFFFFE1

; Add a hand graphic as the draggable section (replace HandGraphicPath with your actual path)
Gui, 64: Add, Picture, x0 y0 w30 h30 gDragADGUI +BackgroundTrans, %HandGraphicPath%
;Gui, 64: Add, Picture, x0 y0 w30 h30 gDragADGUI +BackgroundTrans,
Gui, 64: Add, Button, gToggleListening vToggleBtn x40 y5 w260 h25, START LISTENING/TRANSCRIBING
Gui, 64: Add, Button, gLaunchAINote vCreateBtn x310 y5 w180 h25, CREATE AI NOTE
Gui, 64: Add, ComboBox, vNoteType x510 y6 w350, |  ; dynamic content
Gui, 64: Font, s8 cBlue underline
Gui, 64: Add, Text, gOpenConfigure VConfigText x870 y8 w78 h20, Configure/Help
Gui, 64: Font, s10, Verdana
Gui, 64: Add, Button, gCloseGui64 vCloseBtn x960 y5 w25 h25, X
Gui, 64: Add, Text, vListeningText x310 y8 w640 +Center +BackgroundTrans Hidden, *******************Listening*********************
LoadAndUpdatePrompts() ; this has to update control which is already there
Gui, 64: Show, x145 y200 w990 h35, Ambient Scribe Toolbar
Return

OpenConfigure:

	GuiControlGet, SelectedNoteType,, NoteType
	MsgBox, 262144, CPRS Booster, Configuring: %Selectednotetype%. `n`n To configure a different title, use the drop down box to select `n the title BEFORE clicking the 'configure' link. `n`n To create a NEW note type ("prompt"), click the 'Create new note type' link on the next screen.`n`n For General Instructions on using Ambient Dictation: click 'Instructions' at the top of the next screen.
	; loadAndUpdatePrompts()
	comingfromAmbientDictation := True
	Gui, 64: Default
	
	;MsgBox, 262144, CPRS Booster, %SelectedNoteType%
	if (SelectedNoteType = "" || SelectedNoteType = "Add/Edit")
	{
		MsgBox, 262144, CPRS Booster, Please select a valid note type to configure.
		Return
	}
	PreloadedSummaryName := SelectedNoteType
	if (ADPrompts.HasKey(SelectedNoteType))
	{
		PreloadedPromptText := ADPrompts[SelectedNoteType].Prompt
	}
	else
	{
		PreloadedPromptText := ""
	}
	global lastprompttype := preloadedsummaryname ; save the last prompt type
	gui, 64: Hide
	Gosub Gui62
	;loadAndUpdatePrompts()
	
Return

DragADGUI:
PostMessage, 0xA1, 2,,, A
Return

ToggleListening:


		;MsgBox, 262144, CPRS Booster, %dragonNotInstalled%
		Listening := !Listening
		if (Listening)
		{
			Gui, 64: Color, FFFF00
			GuiControl,, ToggleBtn, STOP LISTENING/TRANSCRIBING
			GuiControl, Hide, CreateBtn
			GuiControl, Hide, NoteType
			GuiControl, Hide, CloseBtn
			guicontrol, Hide, ConfigText
			GuiControl, Show, ListeningText


			IfWinNotExist, Booster Dictation Box
			{
				Gosub ListenFromScratch
			}
			Else ; Box is already there: user didn't hit make AI note button yet.
				{
					; Check if there is already transcribed text in the dictation box: DANGER of mixing pts
					GuiControlGet, existingText, 65:, DragonAnchor
					cleanedText := StrReplace(existingText, "+", "")
					cleanedText := RegExReplace(cleanedText, "\s", "")
					if (StrLen(cleanedText) > 10)
					{
						Gosub Gui66
						; Gui66 will handle the user's choice and proceed accordingly
					}
					else
					{
						WinActivate, Booster Dictation Box
						Gosub startDragonListening ; start listening
					}
				}	
		}
		else  ; listening = false = stop listening
		{
			Gui, 64: Color, 0xFFFFE1
			GuiControl,, ToggleBtn, START LISTENING/TRANSCRIBING
			GuiControl, Show, CreateBtn
			GuiControl, Show, NoteType
			GuiControl, Show, CloseBtn
			GuiControl, Show, ConfigText
			GuiControl, Hide, ListeningText
			Gosub, StopListenting
		}
Return

; =======================
; GUI 66: Dictation Box Already Has Text
; =======================
Gui66:
	Gui, 66:Destroy
	Gui, 66:Font, s12, Verdana
	Gui, 66:Add, Text, x32 y29 w420 h60, IMPORTANT: There is already transcribed text `n in the dictation box.
	Gui, 66:Add, Button, x32 y109 w320 h47 gGui66_SamePatient, LISTENING AGAIN TO SAME PATIENT AS BEFORE
	Gui, 66:Add, Button, x32 y169 w320 h40 gGui66_NewPatient, NEW PATIENT: CLEAR OUT OLD TEXT
	Gui, 66:Show, x400 y400 h230 w410, Booster Dictation Box: Already Has Text
Return

Gui66_SamePatient:
	Gui, 66:Destroy
	WinActivate, Booster Dictation Box ; do NOT destroy old dictation box; do NOT toggle anchor
	Gosub startDragonListening
Return

Gui66_NewPatient:
	Gui, 66:Destroy
	Gui, 65:Destroy ; destroy the old dictation box
	goto listenfromscratch ; start listening from scratch
Return

66GuiClose:
	Gui, 66:Destroy
Return

listenfromscratch:

				Gosub, ShowGui65  ; this subroutine starts listening and anchors dragon to booster dictation box
				gosub ToggleDictationAnchor ; turn it on b/c it should be off here (first time though)
				Gosub startDragonListening ; start listening
				SplashTextOn ,150 ,100, CPRS Booster, Get verbal consent from patient
				sleep 1500
				SplashTextOff
return

StopListenting:
Gui, 65: show
; WinActivate, Dragon Medical One 
winactivate, Booster Dictation Box
	; Gui, 65: Hide
	; MsgBox, 262144, CPRS Booster, %dragonNotInstalled%

	
	Listening := False
	SetTimer, DM1_CheckColorTimer, Off ; temporarily stop checking dragon mic status so we can send
	; Send ^{Space} ; stop listening	; dragon commands w/o the timer loop butting in.
	Gui, 64: Color, 0xFFFFE1
	GuiControl,, ToggleBtn, START LISTENING/TRANSCRIBING
	GuiControl, Show, CreateBtn
	GuiControl, Show, NoteType
	GuiControl, Show, CloseBtn
	GuiControl, Show, ConfigText
	GuiControl, Hide, ListeningText

	SetTimer, CheckDictationText, Off ; stop checking for text in the dictation box
	sleep 30
	; CHANGED: we don't want to release anchor b/c user might start again on same pt
	; Send, ^!a ; release anchor; Change: Actually I don't think I want to release UNTIL I destroy this window
	;sleep 50
	; WinActivate, Dragon Medical One
	;sleep 150
	; Send ^{Space}
	send {NumpadAdd}
	sleep 50
	send ^{Space}
	sleep 50
	send {esc 2}

	sleep 50

	gosub DM1_CheckColorTimer ; this should verify that mic is turned off and if not: do it. But NOT a timer in this case: just uses a subroutine
	
	; WinActivate, Booster Dictation Box
	;Gui, 65: Hide
	; SetTimer, DM1_CheckColorTimer, Off
Return

LaunchAINote:


	if (Listening) {
		MsgBox, Please STOP transcription before creating the AI note.
		return
	}


	GuiControlGet, copiedText, 65:, DragonAnchor  ; Getting the text from Booster Dictation Box
	cleanedText := StrReplace(copiedText, "+", "")
	if (StrLen(cleanedText) < 20) {
		MsgBox, 262144, CPRS Booster, You must record something before creating the AI note.
		return
	}
	GuiControlGet, selectedNoteType, 64:, NoteType
		
	; MsgBox, 262144, CPRS Booster, Selected Note Type: %selectedNoteType% `n Last prompt type: %lastprompttype%`n`n If you want to change the note type, click 'Configure/Help' and select a different note type.`n`n If you want to create a new note type, click 'Create New Note Type/Prompt' on the next screen.`n`n If you want to use the last used note type, click 'Create AI Note' again.

		; If the selected note type is different from the last used, save it
		if (selectedNoteType != lastprompttype) {
			Global lastprompttype := selectedNoteType
			gosub writeit
		}

		Global lastprompttype := selectedNoteType ; save the last prompt type
		
		
		loadAndUpdatePrompts()
		if ADPrompts.HasKey(selectedNoteType)
		{
			promptData := ADPrompts[selectedNoteType]
			finalText := promptData.Prompt . "`r`nDOCTOR-PATIENT CONVERSATION BELOW:`r`n" . copiedText
		}
		else
		{
			finalText := "[No AI prompt available for this note type.]" . "`r`nDOCTOR-PATIENT CONVERSATION BELOW:`r`n" . copiedText
		}

		Clipboard := finalText

		Run, https://vagptbeta.va.gov/

		SplashTextOn ,150 ,100, CPRS Booster,  text on the CLIPBOARD
		sleep 3000
		SplashTextOff

		send {tab}
		sleep 1000
		send {Enter}
		SplashTextOn ,150 ,100, CPRS Booster, PASTE into the VA GPT window.`n THen Press ENTER `n
		sleep 1500
		SplashTextOff
		send {Enter}
		sleep 1000
		send {Enter}
		Gui, 65: Destroy   ; User SHOULD be done with dragon dictation box now 
		; Do we need to remove anchor? We destroy the box



Return

CloseGui64:
	Gui, 64: Destroy
	; global lastprompttype := "" ; reset
Return

; =======================
; GUI 65: Dragon Anchor Box
;gui65
; =======================

ShowGui65:    ; THIS IS THE DRAGON DICTATION BOX

CoordMode, Mouse, Screen
CoordMode, Pixel, Screen
CoordMode, ToolTip, Screen
; Gui, 65: Destroy   ; WE DON'T WANT TO DESTROY ***UNLESS USER IS DONE*** = make AI note
Gui, 65: +ToolWindow +AlwaysOnTop
Gui, 65: Font, s11, Verdana
Gui, 65: Add, Edit, vDragonAnchor hwndhAnchorEdit x0 y0 w300 h300
Gui, 65: Show, x800 y900 w300 h300, Booster Dictation Box
	sleep 200
Return

65GuiClose:
	Gui, 65: Destroy
Return



StartDragonListening:
    ; WinActivate, Dragon Medical One
	gosub startListening ; start listening to Dragon Medical One
	; Gui, 65: Hide
    ; WinActivate, Booster Dictation Box
	SetTimer, DM1_CheckColorTimer, 1000 ; monitor the color of the Dragon Medical One window
 Return


ToggleDictationAnchor: ; can jump here
	; MsgBox, 262144, CPRS Booster, box open
    GuiControl Focus, DragonAnchor
    ControlGetPos, anchorX, anchorY,,,, Booster Dictation Box
    anchorX += 10
    anchorY += 10
    ; MouseMove, %anchorX%, %anchorY%, 0
	; sleep 500
    ; Click
	WinActivate, Booster Dictation Box
	; MsgBox, 262144, CPRS Booster, cursor in box
    sleep 300
    Send, ^!a
    sleep 300

return ; end toggledictationanchor


startListening: ; send start command to DRAGON
Listening := True  ; ADDED 7-24
	; Check if Dragon Medical One is minimized, and restore if so
		WinGet, winDragState, MinMax, Dragon Medical One
		if (winDragState = -1) {
			WinRestore, Dragon Medical One
			WinMaximize, Dragon Medical One
			sleep 300
			WinMove, Dragon Medical One,, 1100, 300
		}
		
	
	sleep 100
	; Send ^{Space}
	send {NumpadAdd}
	sleep 50
	send ^{Space}
	sleep 50 
	send {esc 2}
	sleep 500

	; Start a timer to check for text in the dictation box every 1 minute
	SetTimer, CheckDictationText, 60000
return

CheckDictationText:
SetTimer, CheckDictationText, Off  ; Stop the timer so it only runs once per startListening
GuiControlGet, dictationText, 65:, DragonAnchor
; Remove all plus signs and whitespace
cleanedText := StrReplace(dictationText, "+", "")
cleanedText := RegExReplace(cleanedText, "\s", "")
if (StrLen(cleanedText) <= 10)
{
	MsgBox, 262144, CPRS Booster, No meaningful text has been captured in the dictation box. There may be a problem with dictation.
}

	
	
 return

HideAnchorEdit:
	GuiControl, 65: Hide, DragonAnchor
Return

HideGui65:
	Gui, 65: Destroy
Return

ShowflaggedOrders:
; when done the orders may not show up with flags.
								send !v
								sleep 50
								send C  ; for custom
								sleep 50
								send {pgup 2}
								sleep 50
								send {pgdn}
								sleep 50
								send {tab}
								sleep 75
								send {pgup 2}
								sleep 75
								send {down}
								sleep 100
									send {enter}
								sleep 300
Return						

;############################################################################################
;####################AMBIENT DICTATION: Dragon Timeout monitor############################################
;############################################################################################




DM1_CheckColorTimer:

WinGet, dm1_hWnd, ID, Dragon Medical One
if (!dm1_hWnd) {
	; MsgBox, Transcription Stopped (window not found)
	 return
}

    ; Make the Dragon Medical One window always on top
    WinSet, AlwaysOnTop, On, ahk_id %dm1_hWnd%

WinGetPos, dm1_x, dm1_y, dm1_w, dm1_h, ahk_id %dm1_hWnd%
CoordMode, Pixel, Screen
PixelSearch, dm1_px, dm1_py, dm1_x, dm1_y, dm1_x + dm1_w - 1, dm1_y + dm1_h - 1, 0x4DA900, 3, Fast RGB

if (ErrorLevel) {
	; MsgBox, Transcription Stopped (color not found)

	If (Listening) ; if we are trying to start listening BUT yellow mic is not found
	{
	gosub startListening ; restart listening
	}
}
Else
{
	 ;MsgBox, Transcription is active (color IS found)
	 If !(Listening) ; if we are trying to STOP listening but Green color is STILL THERE
	 {
		  attempts := 0
		  maxAttempts := 5
		  Loop
		  {
				send {NumpadAdd}
				sleep 50
				send ^{Space}
				sleep 50
				send {esc 2}
				sleep 500

				; Re-check for green color after trying to turn off
				PixelSearch, dm1_px, dm1_py, dm1_x, dm1_y, dm1_x + dm1_w - 1, dm1_y + dm1_h - 1, 0x4DA900, 3, Fast RGB
				if (ErrorLevel) {
					 break ; Successfully turned off
				}
				attempts++
				if (attempts >= maxAttempts) {
					 MsgBox, 262144, CPRS Booster, I can't turn Dragon off. Please do it manually.
					 break
				}
		  }
	 }
}
return


;############################################################################################
;############################################################################################
;############################################################################################
;###                                                                                      ###
;###              NURSING BOOSTER - Converted from AHK v2 to v1                           ###
;###              CPRS Reminder Template Toolbar (merged into CPRSBooster)                 ###
;###                                                                                      ###
;###  Saves/applies checkbox templates to CPRS reminder dialogues.                        ###
;###  Fill out an assessment once, save it, one-click replay next time.                   ###
;###                                                                                      ###
;###  SAFETY: Clicks checkboxes only. Never clicks OK, Finish, or Submit.                ###
;###  The nurse always reviews and submits manually.                                      ###
;###                                                                                      ###
;############################################################################################
;############################################################################################
;############################################################################################


;============================================================================================
; NURSING BOOSTER DROPDOWN HANDLER (on Gui 14 toolbar)
;============================================================================================

NB_DropdownAction:
    Gui, 14:Submit, NoHide
    if (NB_DropdownChoice = 1)  ; "Nursing Booster" header - do nothing
    {
        GuiControl, 14:Choose, NB_DropdownChoice, 1
        return
    }
    else if (NB_DropdownChoice >= 2 && NB_DropdownChoice <= 6)  ; Quick Actions 1-5
    {
        hkIdx := NB_DropdownChoice - 1
        if (hkIdx = 1)
            NB_RunHotkeyAction(NB_HK1_Action, NB_HK1_Label)
        else if (hkIdx = 2)
            NB_RunHotkeyAction(NB_HK2_Action, NB_HK2_Label)
        else if (hkIdx = 3)
            NB_RunHotkeyAction(NB_HK3_Action, NB_HK3_Label)
        else if (hkIdx = 4)
            NB_RunHotkeyAction(NB_HK4_Action, NB_HK4_Label)
        else if (hkIdx = 5)
            NB_RunHotkeyAction(NB_HK5_Action, NB_HK5_Label)
    }
    else if (NB_DropdownChoice = 7)   ; Save Template
        gosub NB_BtnSaveCurrentState
    else if (NB_DropdownChoice = 8)   ; Load Template
        gosub NB_BtnLoadSavedTemplate
    else if (NB_DropdownChoice = 9)   ; Delete Template
        gosub NB_BtnDeleteTemplate
    else if (NB_DropdownChoice = 10)  ; Toggle Panel
        gosub NB_TogglePanel
    else if (NB_DropdownChoice = 11)  ; Build Key Macro
        gosub NB_OpenMacroBuilder
    else if (NB_DropdownChoice = 12)  ; Play Key Macro
        gosub NB_PlayMacroSelect
    else if (NB_DropdownChoice = 13)  ; Record Macro
        gosub NB_StartRecording
    else if (NB_DropdownChoice = 14)  ; Settings
        gosub NB_ToggleSettings
    ; Reset dropdown back to header
    GuiControl, 14:Choose, NB_DropdownChoice, 1
return

NB_RebuildDropdown() {
    global NB_HK1_Label, NB_HK2_Label, NB_HK3_Label, NB_HK4_Label, NB_HK5_Label
    newList := "Nursing Booster||" . NB_HK1_Label . "|" . NB_HK2_Label . "|" . NB_HK3_Label . "|" . NB_HK4_Label . "|" . NB_HK5_Label . "|Save Template|Load Template|Delete Template|Toggle Panel|Build Key Macro|Play Key Macro|Record Macro|Settings"
    GuiControl, 14:, NB_DropdownChoice, |%newList%
    GuiControl, 14:Choose, NB_DropdownChoice, 1
}


;============================================================================================
; NURSING BOOSTER TOGGLE PANEL (Gui 67)
;============================================================================================

NB_TogglePanel:
    if (NB_BoosterGuiVisible = 1)
    {
        Gui, 67:Hide
        NB_BoosterGuiVisible := 0
    }
    else
    {
        Gui, 67:Show, NoActivate
        WinSet, AlwaysOnTop, On, ahk_id %NB_PanelHwnd%
        NB_BoosterGuiVisible := 1
    }
return


;============================================================================================
; NURSING BOOSTER PANEL BUTTON HANDLERS
;============================================================================================

NB_PanelSave:
    gosub NB_BtnSaveCurrentState
return

NB_PanelLoad:
    gosub NB_BtnLoadSavedTemplate
return

NB_PanelDelete:
    gosub NB_BtnDeleteTemplate
return

NB_PanelDump:
    gosub NB_DumpDialogControls
return

NB_PanelSettings:
NB_ToggleSettings:
    if (NB_SettingsVisible) {
        Gui, 73:Hide
        NB_SettingsVisible := 0
    } else {
        Gui, 73:Show
        NB_SettingsVisible := 1
    }
return

NB_PanelBuildMacro:
    gosub NB_OpenMacroBuilder
return

NB_PanelPlayMacro:
    gosub NB_PlayMacroSelect
return

NB_PanelRecordMacro:
    gosub NB_StartRecording
return

NB_DragPanel:
    ; Allow dragging the panel by clicking the title bar text
    PostMessage, 0xA1, 2, 0,, NursingBoosterPanel
return

NB_SpeedSliderChanged:
    GuiControlGet, NB_ApplySpeed, 73:, NB_SpeedSlider
    GuiControl, 73:, NB_SpeedLabel, %NB_ApplySpeed% ms
return

73GuiClose:
    Gui, 73:Hide
    NB_SettingsVisible := 0
return


;============================================================================================
; CP FLOWSHEETS PANEL BUTTON HANDLERS
;============================================================================================

CF_PanelSpy:
    gosub CF_SpyDumpControls
return

CF_PanelSave:
    gosub CF_BtnSaveTemplate
return

CF_PanelLoad:
    gosub CF_BtnLoadTemplate
return

CF_PanelDelete:
    gosub CF_BtnDeleteTemplate
return

CF_ToggleAutoSave:
    Gui, 67:Submit, NoHide
    global CF_AutoSave
    if (CF_AutoSaveChk = 1) {
        MsgBox, 308, CP Flowsheets - AutoSave WARNING, WARNING: AutoSave will automatically click the SAVE button in CP Flowsheets after applying a template.`n`nThis saves the entry PERMANENTLY to the patient record.`n`nAre you sure you want to enable AutoSave?
        IfMsgBox, Yes
        {
            CF_AutoSave := 1
            ToolTip, CPFS AutoSave ENABLED - Save will be clicked automatically
            SetTimer, NB_ClearToolTip, -3000
        }
        else
        {
            CF_AutoSave := 0
            GuiControl, 67:, CF_AutoSaveChk, 0
        }
    } else {
        CF_AutoSave := 0
        ToolTip, CPFS AutoSave disabled
        SetTimer, NB_ClearToolTip, -2000
    }
return


;============================================================================================
; QUICK ACTION HOTKEY BUTTON HANDLERS
;============================================================================================

NB_HK1_Run:
    NB_RunHotkeyAction(NB_HK1_Action, "Quick 1")
return

NB_HK2_Run:
    NB_RunHotkeyAction(NB_HK2_Action, "Quick 2")
return

NB_HK3_Run:
    NB_RunHotkeyAction(NB_HK3_Action, "Quick 3")
return

NB_HK4_Run:
    NB_RunHotkeyAction(NB_HK4_Action, "Quick 4")
return

NB_HK5_Run:
    NB_RunHotkeyAction(NB_HK5_Action, "Quick 5")
return

NB_RunHotkeyAction(action, slotName) {
    global NB_TemplateDir, NB_MacroDir, CF_TemplateDir, NB_AppTitle
    if (action = "") {
        ToolTip, %slotName% not configured - click [...] to set up
        SetTimer, NB_ClearToolTip, -2000
        return
    }
    ; Parse action type: "nb_template:Name", "cf_template:Name", "macro:Name"
    if (RegExMatch(action, "^nb_template:(.+)$", m)) {
        NB_ApplyNamedTemplate(m1)
    }
    else if (RegExMatch(action, "^cf_template:(.+)$", m)) {
        templatePath := CF_TemplateDir . "\" . m1 . ".json"
        if (FileExist(templatePath)) {
            CF_ApplyTemplate(templatePath)
        } else {
            MsgBox, 48, %NB_AppTitle%, CPFS template "%m1%" not found.`n`nSave a template with that name using CPFS Save first.
        }
    }
    else if (RegExMatch(action, "^macro:(.+)$", m)) {
        macroPath := NB_MacroDir . "\" . m1 . ".keymacro"
        if (FileExist(macroPath)) {
            playSteps := NB_ParseMacroFile(macroPath)
            if (playSteps.Length() > 0) {
                NB_ExecuteMacro(playSteps, 150)
            }
        } else {
            MsgBox, 48, %NB_AppTitle%, Macro "%m1%" not found.`n`nSave a macro with that name using Build Key Macro first.
        }
    }
    else {
        ToolTip, Unknown action: %action%
        SetTimer, NB_ClearToolTip, -2000
    }
}

;============================================================================================
; QUICK ACTION SETUP DIALOG (Gui 71)
;============================================================================================

NB_HK_Setup:
    global NB_HK1_Action, NB_HK2_Action, NB_HK3_Action, NB_HK4_Action, NB_HK5_Action
    global NB_HK1_Label, NB_HK2_Label, NB_HK3_Label, NB_HK4_Label, NB_HK5_Label
    global NB_TemplateDir, NB_MacroDir, CF_TemplateDir

    ; Build list of available actions
    actionList := "-- None --|"

    ; NB templates
    Loop, Files, %NB_TemplateDir%\*.json
    {
        fname := StrReplace(A_LoopFileName, ".json", "")
        actionList .= "NB Template: " . fname . "|"
    }

    ; CF templates
    Loop, Files, %CF_TemplateDir%\*.json
    {
        fname := StrReplace(A_LoopFileName, ".json", "")
        actionList .= "CPFS Template: " . fname . "|"
    }

    ; Macros
    Loop, Files, %NB_MacroDir%\*.keymacro
    {
        fname := StrReplace(A_LoopFileName, ".keymacro", "")
        actionList .= "Macro: " . fname . "|"
    }

    Gui, 71:Destroy
    Gui, 71:+AlwaysOnTop +ToolWindow
    Gui, 71:Color, F8F8F8
    Gui, 71:Font, s9 Bold, Segoe UI
    Gui, 71:Add, Text, x10 y10 w380, Quick Action Button Setup
    Gui, 71:Font, s8 Norm, Segoe UI

    ; Slot 1
    Gui, 71:Add, Text, x10 y40 w50, Slot 1:
    Gui, 71:Add, Edit, x65 y38 w100 h22 vNB_HKSetup_L1, %NB_HK1_Label%
    Gui, 71:Add, DropDownList, x170 y38 w220 vNB_HKSetup_A1, %actionList%
    NB_HKSetupSelectAction("NB_HKSetup_A1", NB_HK1_Action)

    ; Slot 2
    Gui, 71:Add, Text, x10 y68 w50, Slot 2:
    Gui, 71:Add, Edit, x65 y66 w100 h22 vNB_HKSetup_L2, %NB_HK2_Label%
    Gui, 71:Add, DropDownList, x170 y66 w220 vNB_HKSetup_A2, %actionList%
    NB_HKSetupSelectAction("NB_HKSetup_A2", NB_HK2_Action)

    ; Slot 3
    Gui, 71:Add, Text, x10 y96 w50, Slot 3:
    Gui, 71:Add, Edit, x65 y94 w100 h22 vNB_HKSetup_L3, %NB_HK3_Label%
    Gui, 71:Add, DropDownList, x170 y94 w220 vNB_HKSetup_A3, %actionList%
    NB_HKSetupSelectAction("NB_HKSetup_A3", NB_HK3_Action)

    ; Slot 4
    Gui, 71:Add, Text, x10 y124 w50, Slot 4:
    Gui, 71:Add, Edit, x65 y122 w100 h22 vNB_HKSetup_L4, %NB_HK4_Label%
    Gui, 71:Add, DropDownList, x170 y122 w220 vNB_HKSetup_A4, %actionList%
    NB_HKSetupSelectAction("NB_HKSetup_A4", NB_HK4_Action)

    ; Slot 5
    Gui, 71:Add, Text, x10 y152 w50, Slot 5:
    Gui, 71:Add, Edit, x65 y150 w100 h22 vNB_HKSetup_L5, %NB_HK5_Label%
    Gui, 71:Add, DropDownList, x170 y150 w220 vNB_HKSetup_A5, %actionList%
    NB_HKSetupSelectAction("NB_HKSetup_A5", NB_HK5_Action)

    Gui, 71:Add, Button, x110 y185 w90 h28 gNB_HKSetup_Save Default, Save
    Gui, 71:Add, Button, x210 y185 w90 h28 gNB_HKSetup_Cancel, Cancel
    Gui, 71:Show, w400 h225, Quick Action Setup
return

NB_HKSetupSelectAction(ctrlName, currentAction) {
    ; Convert stored action back to display text for dropdown selection
    displayText := "-- None --"
    if (RegExMatch(currentAction, "^nb_template:(.+)$", m))
        displayText := "NB Template: " . m1
    else if (RegExMatch(currentAction, "^cf_template:(.+)$", m))
        displayText := "CPFS Template: " . m1
    else if (RegExMatch(currentAction, "^macro:(.+)$", m))
        displayText := "Macro: " . m1
    GuiControl, 71:ChooseString, %ctrlName%, %displayText%
}

NB_HKSetup_Save:
    Gui, 71:Submit
    global NB_HK1_Label, NB_HK1_Action, NB_HK2_Label, NB_HK2_Action
    global NB_HK3_Label, NB_HK3_Action, NB_HK4_Label, NB_HK4_Action
    global NB_HK5_Label, NB_HK5_Action

    ; Convert display text back to action strings
    NB_HK1_Label := NB_HKSetup_L1
    NB_HK1_Action := NB_HKParseActionChoice(NB_HKSetup_A1)
    NB_HK2_Label := NB_HKSetup_L2
    NB_HK2_Action := NB_HKParseActionChoice(NB_HKSetup_A2)
    NB_HK3_Label := NB_HKSetup_L3
    NB_HK3_Action := NB_HKParseActionChoice(NB_HKSetup_A3)
    NB_HK4_Label := NB_HKSetup_L4
    NB_HK4_Action := NB_HKParseActionChoice(NB_HKSetup_A4)
    NB_HK5_Label := NB_HKSetup_L5
    NB_HK5_Action := NB_HKParseActionChoice(NB_HKSetup_A5)

    ; Update button labels on panel
    GuiControl, 67:, NB_HK1_Btn, %NB_HK1_Label%
    GuiControl, 67:, NB_HK2_Btn, %NB_HK2_Label%
    GuiControl, 67:, NB_HK3_Btn, %NB_HK3_Label%
    GuiControl, 67:, NB_HK4_Btn, %NB_HK4_Label%
    GuiControl, 67:, NB_HK5_Btn, %NB_HK5_Label%

    ; Rebuild dropdown on bottom bar to reflect new quick action labels
    NB_RebuildDropdown()

    ; Save to file
    gosub NB_SaveHotkeyConfig
    Gui, 71:Destroy
    ToolTip, Quick actions saved
    SetTimer, NB_ClearToolTip, -2000
return

NB_HKSetup_Cancel:
    Gui, 71:Destroy
return

NB_HKParseActionChoice(displayText) {
    ; Convert dropdown display text to stored action string
    if (displayText = "-- None --" || displayText = "")
        return ""
    if (RegExMatch(displayText, "^NB Template: (.+)$", m))
        return "nb_template:" . m1
    if (RegExMatch(displayText, "^CPFS Template: (.+)$", m))
        return "cf_template:" . m1
    if (RegExMatch(displayText, "^Macro: (.+)$", m))
        return "macro:" . m1
    return ""
}

;============================================================================================
; QUICK ACTION CONFIG SAVE/LOAD
;============================================================================================

NB_LoadHotkeyConfig:
    global NB_HotkeyConfigPath
    global NB_HK1_Label, NB_HK1_Action, NB_HK2_Label, NB_HK2_Action
    global NB_HK3_Label, NB_HK3_Action, NB_HK4_Label, NB_HK4_Action
    global NB_HK5_Label, NB_HK5_Action

    if (!FileExist(NB_HotkeyConfigPath))
        return

    FileRead, hkJson, %NB_HotkeyConfigPath%
    if (hkJson = "")
        return

    ; Parse each slot with regex
    if (RegExMatch(hkJson, """label1"":\s*""((?:[^""\\]|\\.)*)""", m))
        NB_HK1_Label := m1
    if (RegExMatch(hkJson, """action1"":\s*""((?:[^""\\]|\\.)*)""", m))
        NB_HK1_Action := m1
    if (RegExMatch(hkJson, """label2"":\s*""((?:[^""\\]|\\.)*)""", m))
        NB_HK2_Label := m1
    if (RegExMatch(hkJson, """action2"":\s*""((?:[^""\\]|\\.)*)""", m))
        NB_HK2_Action := m1
    if (RegExMatch(hkJson, """label3"":\s*""((?:[^""\\]|\\.)*)""", m))
        NB_HK3_Label := m1
    if (RegExMatch(hkJson, """action3"":\s*""((?:[^""\\]|\\.)*)""", m))
        NB_HK3_Action := m1
    if (RegExMatch(hkJson, """label4"":\s*""((?:[^""\\]|\\.)*)""", m))
        NB_HK4_Label := m1
    if (RegExMatch(hkJson, """action4"":\s*""((?:[^""\\]|\\.)*)""", m))
        NB_HK4_Action := m1
    if (RegExMatch(hkJson, """label5"":\s*""((?:[^""\\]|\\.)*)""", m))
        NB_HK5_Label := m1
    if (RegExMatch(hkJson, """action5"":\s*""((?:[^""\\]|\\.)*)""", m))
        NB_HK5_Action := m1
return

NB_SaveHotkeyConfig:
    global NB_HotkeyConfigPath
    global NB_HK1_Label, NB_HK1_Action, NB_HK2_Label, NB_HK2_Action
    global NB_HK3_Label, NB_HK3_Action, NB_HK4_Label, NB_HK4_Action
    global NB_HK5_Label, NB_HK5_Action

    hkJson := "{`n"
    hkJson .= "  ""label1"": " . NB_EscJson(NB_HK1_Label) . ", ""action1"": " . NB_EscJson(NB_HK1_Action) . ",`n"
    hkJson .= "  ""label2"": " . NB_EscJson(NB_HK2_Label) . ", ""action2"": " . NB_EscJson(NB_HK2_Action) . ",`n"
    hkJson .= "  ""label3"": " . NB_EscJson(NB_HK3_Label) . ", ""action3"": " . NB_EscJson(NB_HK3_Action) . ",`n"
    hkJson .= "  ""label4"": " . NB_EscJson(NB_HK4_Label) . ", ""action4"": " . NB_EscJson(NB_HK4_Action) . ",`n"
    hkJson .= "  ""label5"": " . NB_EscJson(NB_HK5_Label) . ", ""action5"": " . NB_EscJson(NB_HK5_Action) . "`n"
    hkJson .= "}"

    FileDelete, %NB_HotkeyConfigPath%
    FileAppend, %hkJson%, %NB_HotkeyConfigPath%
return


;============================================================================================
; NURSING BOOSTER CPRS DETECTION TIMER
;============================================================================================

NB_CheckCPRS:
    Critical
    ; --- CPRS Detection ---
    cprsStatus := "CPRS: Not detected"
    IfWinExist, ahk_exe CPRSChart.exe
    {
        NB_CPRSDetected := 1
        dlgCheck := NB_FindActiveDialogWindow()
        if (dlgCheck) {
            cprsStatus := "Dialog detected"
        } else {
            WinGetTitle, cprsTitle, ahk_exe CPRSChart.exe
            StringLeft, cprsShort, cprsTitle, 50
            cprsStatus := "CPRS: " . cprsShort
        }
    }
    else
    {
        NB_CPRSDetected := 0
    }
    ; --- CP Flowsheets Detection ---
    cfStatus := "CPFS: Not detected"
    IfWinExist, ahk_exe CPFlowsheets.exe
    {
        CF_Detected := 1
        cfStatus := "CPFS: Detected"
    }
    else
    {
        CF_Detected := 0
    }
    GuiControl, 67:, NB_PanelStatus, Ready | %cprsStatus% | %cfStatus%
return

NB_ClearV6Warning:
    GuiControl, 67:, NB_PanelStatus, Ready
return


;============================================================================================
; NURSING BOOSTER - DIALOG WINDOW DETECTION
;============================================================================================

NB_FindActiveDialogWindow() {
    ; Try TfrmRemDlg first (reminder dialog)
    hwnd := WinExist("ahk_class TfrmRemDlg")
    if (hwnd)
        return hwnd

    ; Try TfrmTemplateDialog
    hwnd := WinExist("ahk_class TfrmTemplateDialog")
    if (hwnd)
        return hwnd

    ; Search all CPRS windows for one with checkbox controls
    WinGet, wndList, List, ahk_exe CPRSChart.exe
    Loop, %wndList%
    {
        wnd := wndList%A_Index%
        WinGetClass, cls, ahk_id %wnd%
        if (cls = "TCPRSChart" || cls = "TfrmFrame")
            continue
        if (NB_HasCheckboxControls(wnd))
            return wnd
    }

    ; Fallback: check main frame
    mainHwnd := WinExist("ahk_class TfrmFrame")
    if (!mainHwnd)
        mainHwnd := WinExist("ahk_exe CPRSChart.exe")
    if (mainHwnd && NB_HasCheckboxControls(mainHwnd))
        return mainHwnd

    return 0
}

NB_HasCheckboxControls(windowHwnd) {
    global NB__hasCheckboxes
    NB__hasCheckboxes := false
    enumCB := RegisterCallback("NB__CheckForCheckboxes", "Fast")
    DllCall("EnumChildWindows", "Ptr", windowHwnd, "Ptr", enumCB, "Ptr", 0)
    return NB__hasCheckboxes
}

NB__CheckForCheckboxes(hwnd, lParam) {
    global NB__hasCheckboxes
    VarSetCapacity(buf, 256, 0)
    DllCall("GetClassName", "Ptr", hwnd, "Str", buf, "Int", 256)
    if (buf = "TORCheckBox" || buf = "TCPRSDialogParentCheckBox" || buf = "TCPRSDialogCheckBox") {
        NB__hasCheckboxes := true
        return 0
    }
    return 1
}


;============================================================================================
; NURSING BOOSTER - NAMED TEMPLATE BUTTONS
;============================================================================================

NB_ApplyNamedTemplate(templateName) {
    global NB_TemplateDir, NB_AppTitle
    dlgHwnd := NB_FindActiveDialogWindow()
    if (!dlgHwnd) {
        ToolTip, Open a template or reminder dialogue in CPRS first
        SetTimer, NB_ClearToolTip, -2000
        return
    }
    templatePath := NB_TemplateDir . "\" . NB_SanitizeFilename(templateName) . ".json"
    if (FileExist(templatePath)) {
        WinActivate, ahk_id %dlgHwnd%
        Sleep, 200
        NB_ApplyTemplate(templatePath)
    } else {
        MsgBox, 64, %NB_AppTitle%, No '%templateName%' template saved yet.`n`nTo create one:`n1. Open the reminder dialogue in CPRS`n2. Manually check all the boxes the way you want them`n3. Select 'Save Template' from the Nursing Booster dropdown`n4. Name it exactly: %templateName%`n`nNext time you select this option it replays your selections.`nYou always review in CPRS before clicking Finish.
    }
}


;============================================================================================
; NURSING BOOSTER - SAVE TEMPLATE (format v7 - flat top-to-bottom)
;
; Captures ALL checkboxes in the scroll box as one flat Y-sorted list.
; Includes section toggles, group items, children, grandchildren  everything.
; No separate topLevelParents or groups  just one ordered list.
;============================================================================================

NB_BtnSaveCurrentState:
    dlgHwnd := NB_FindActiveDialogWindow()
    if (!dlgHwnd) {
        MsgBox, 48, %NB_AppTitle%, Open a template or reminder dialogue in CPRS first.
        return
    }

    InputBox, templateName, Save Template, Template name:`n`nUse a descriptive name like 'Negative Assessment' or 'Skin WNL'.`nNaming it the same as a toolbar option links it to that option.
    if (ErrorLevel || templateName = "")
        return

    ToolTip, Scanning dialog...
    NB_WaitForStableCheckboxCount(dlgHwnd)

    scrollBox := NB_FindVisibleScrollBox(dlgHwnd)
    if (!scrollBox) {
        MsgBox, 48, %NB_AppTitle%, Could not find dialog scroll area.
        return
    }

    ; Enumerate ALL checkboxes in the entire scroll box (flat, Y-sorted)
    allItems := NB_EnumDescendantCheckboxes(scrollBox)
    if (allItems.Length() = 0) {
        MsgBox, 48, %NB_AppTitle%, No checkboxes found in dialog.
        return
    }

    ; Build JSON  flat list
    json := "{"
    json .= "`n  ""name"": " . NB_EscJson(templateName) . ","
    json .= "`n  ""format"": 7,"
    json .= "`n  ""matching"": ""flat-sequential"","
    FormatTime, nowTime,, yyyy-MM-dd HH:mm
    json .= "`n  ""created"": """ . nowTime . ""","
    WinGetTitle, dlgTitle, ahk_id %dlgHwnd%
    json .= "`n  ""source_dialogue"": " . NB_EscJson(dlgTitle) . ","

    totalChecked := 0
    totalControls := allItems.Length()
    json .= "`n  ""checkboxes"": ["
    for ci, cb in allItems {
        if (ci > 1)
            json .= ","
        json .= "`n    {""idx"": " . (ci - 1) . ", ""cls"": " . NB_EscJson(cb.className)
            . ", ""checked"": " . (cb.checked ? "true" : "false")
            . ", ""depth"": " . cb.depth
        if (cb.label != "")
            json .= ", ""label"": " . NB_EscJson(cb.label)
        json .= "}"
        if (cb.checked)
            totalChecked++
    }
    json .= "`n  ]"
    json .= "`n}"

    filePath := NB_TemplateDir . "\" . NB_SanitizeFilename(templateName) . ".json"
    f := FileOpen(filePath, "w", "UTF-8")
    f.Write(json)
    f.Close()

    ; Log using group-based view for readability
    allGroupBoxes := NB_EnumScrollBoxGroupBoxes(scrollBox)
    NB__LogCheckboxStates("SAVE", allGroupBoxes, templateName, dlgTitle, totalChecked, totalControls)

    ToolTip, Saved "%templateName%": %totalChecked%/%totalControls% checkboxes
    SetTimer, NB_ClearToolTip, -3000
return


;============================================================================================
; NURSING BOOSTER - APPLY TEMPLATE (format v7 - flat sequential)
;
; Treats the ENTIRE dialog as one flat top-to-bottom list.
; No separate phases for sections vs groups. Processes item by item:
; section toggle  its children  their grandchildren  next section.
; Re-enumerates the whole scroll box after every parent toggle so
; dynamically created children appear at the correct positions.
;============================================================================================

NB_ApplyTemplate(templatePath) {
    global NB_AppTitle, NB_TemplateDir, NB_ApplySpeed
    dlgHwnd := NB_FindActiveDialogWindow()
    if (!dlgHwnd)
        return

    FileRead, content, %templatePath%
    if (ErrorLevel) {
        MsgBox, 48, %NB_AppTitle%, Failed to read template: %templatePath%
        return
    }

    ; Accept format v7 or v6 (flat). Warn on v6 but allow it.
    isV7 := InStr(content, """format"": 7") || InStr(content, """format"":7")
    isV6 := InStr(content, """format"": 6") || InStr(content, """format"":6")
    if !(isV7 || isV6) {
        MsgBox, 48, %NB_AppTitle%, This template must be re-saved with the updated Nursing Booster (v7).`n`n1. Open the reminder dialog in CPRS and fill it out`n2. Select 'Save Template' to create a new version
        return
    }
    if (isV6 && !isV7) {
        GuiControl, 67:, NB_PanelStatus, WARNING: Loading v6 template - re-save to upgrade to v7
        SetTimer, NB_ClearV6Warning, -5000
    }

    ; Parse flat checkbox list from template
    tplItems := NB_ParseFlatCheckboxes(content)
    if (tplItems.Length() = 0) {
        MsgBox, 48, %NB_AppTitle%, Template has no checkboxes.
        return
    }

    tplCount := tplItems.Length()

    ; Wait for dialog to load
    ToolTip, Waiting for dialog to load...
    NB_WaitForStableCheckboxCount(dlgHwnd)

    scrollBox := NB_FindVisibleScrollBox(dlgHwnd)
    if (!scrollBox) {
        MsgBox, 48, %NB_AppTitle%, Could not find dialog scroll area.
        return
    }

    totalApplied := 0
    totalNotFound := 0

    ; Enumerate ALL checkboxes in the scroll box (flat, Y-sorted)
    liveItems := NB_EnumDescendantCheckboxes(scrollBox)
    needReEnum := false

    ToolTip, Applying %tplCount% items...

    ; Walk the template top-to-bottom, one item at a time.
    ; After toggling any parent, re-enumerate the entire scroll box
    ; so dynamically created children appear at the correct positions.
    tplPos := 1
    while (tplPos <= tplCount)
    {
        ; Re-enumerate if a parent toggle changed the dialog structure
        if (needReEnum) {
            liveItems := NB_EnumDescendantCheckboxes(scrollBox)
            needReEnum := false
        }

        liveCount := liveItems.Length()
        if (tplPos > liveCount) {
            totalNotFound++
            tplPos++
            continue
        }

        tplCb := tplItems[tplPos]
        liveCb := liveItems[tplPos]

        nb_tmpHwnd := liveCb.hwnd
        if (DllCall("IsWindow", "Ptr", nb_tmpHwnd)) {
            ; Fresh state read right before toggle decision
            SendMessage, 0x00F0, 0, 0,, ahk_id %nb_tmpHwnd%
            currentState := ErrorLevel ? true : false
            if (currentState != tplCb.checked) {
                PostMessage, 0x00F5, 0, 0,, ahk_id %nb_tmpHwnd%
                totalApplied++

                ; Parent toggles create/destroy children  must re-enumerate
                if (liveCb.className = "TCPRSDialogParentCheckBox") {
                    Sleep, %NB_ApplySpeed%
                    needReEnum := true
                } else {
                    leafDelay := NB_ApplySpeed // 6
                    if (leafDelay < 20)
                        leafDelay := 20
                    Sleep, %leafDelay%
                }
            }
        }

        tplPos++

        ; Progress tooltip every 20 items
        if (Mod(tplPos, 20) = 0)
            ToolTip, Applying item %tplPos%/%tplCount%...

        ; Dismiss popups periodically
        if (Mod(totalApplied, 15) = 0)
            NB_DismissIntermediatePopups()
    }

    NB_DismissIntermediatePopups()

    ; Log every checkbox state after apply
    WinGetTitle, applyDlgTitle, ahk_id %dlgHwnd%
    allGroupBoxes := NB_EnumScrollBoxGroupBoxes(scrollBox)
    NB__LogCheckboxStates("APPLY", allGroupBoxes, templatePath, applyDlgTitle, totalApplied, totalNotFound)

    ToolTip, Done: %totalApplied% toggled - %totalNotFound% not found. Review before Finish.
    SetTimer, NB_ClearToolTip, -5000

    ; Re-assert AlwaysOnTop on the panel  WinActivate on CPRS dialog strips it
    if (NB_BoosterGuiVisible = 1)
        WinSet, AlwaysOnTop, On, ahk_id %NB_PanelHwnd%
}


;============================================================================================
; NURSING BOOSTER - CHECKBOX STATE LOGGING
;============================================================================================

NB__LogCheckboxStates(action, groupBoxHwnds, templateNameOrPath := "", dialogTitle := "", statA := 0, statB := 0) {
    global NB_LogDir
    FormatTime, nowStamp,, yyyyMMddHHmmss
    FormatTime, nowDisp,, yyyy-MM-dd HH:mm:ss
    logPath := NB_LogDir . "\" . action . "_" . nowStamp . ".txt"
    FileDelete, %logPath%

    groupCount := groupBoxHwnds.Length()

    ; --- Header with summary info ---
    logText := "============================================================`n"
    logText .= "  NURSING BOOSTER " . action . " LOG`n"
    logText .= "============================================================`n"
    logText .= "Timestamp:    " . nowDisp . "`n"
    logText .= "Action:       " . action . "`n"
    logText .= "Template:     " . templateNameOrPath . "`n"
    logText .= "Dialog:       " . dialogTitle . "`n"
    logText .= "User:         " . A_UserName . "`n"
    logText .= "Groups found: " . groupCount . "`n"
    if (action = "SAVE")
        logText .= "Checked/Total: " . statA . "/" . statB . "`n"
    else if (action = "APPLY")
        logText .= "Toggled: " . statA . "  |  Not found: " . statB . "`n"
    logText .= "============================================================`n`n"
    FileAppend, %logText%, %logPath%, UTF-8

    ; --- Per-group checkbox detail ---
    totalCBs := 0
    totalChecked := 0
    for gi, gbHwnd in groupBoxHwnds {
        descendants := NB_EnumDescendantCheckboxes(gbHwnd)
        descCount := descendants.Length()
        groupLine := "--- Group " . gi . "/" . groupCount . " (" . descCount . " checkboxes) ---`n"
        FileAppend, %groupLine%, %logPath%, UTF-8
        for ci, cb in descendants {
            state := cb.checked ? "[X]" : "[ ]"
            cls := cb.className = "TCPRSDialogParentCheckBox" ? "PARENT" : "LEAF  "
            lbl := cb.label != "" ? cb.label : "(unlabeled)"
            cbLine := "  " . state . " depth=" . cb.depth . " " . cls . " " . lbl . "`n"
            FileAppend, %cbLine%, %logPath%, UTF-8
            totalCBs++
            if (cb.checked)
                totalChecked++
        }
        FileAppend, `n, %logPath%, UTF-8
    }

    ; --- Footer summary ---
    footerText := "============================================================`n"
    footerText .= "TOTALS: " . totalChecked . " checked out of " . totalCBs . " checkboxes in " . groupCount . " groups`n"
    footerText .= "============================================================`n"
    FileAppend, %footerText%, %logPath%, UTF-8
}


;============================================================================================
; NURSING BOOSTER - GROUP FINGERPRINTING
;============================================================================================

NB__GroupFingerprint(items) {
    labels := []
    depthCounts := {}
    for k, item in items {
        lbl := item.HasKey("label") ? item.label : ""
        if (lbl != "")
            labels.Push(lbl)
        d := item.HasKey("depth") ? item.depth : 0
        if (!depthCounts.HasKey(d))
            depthCounts[d] := 0
        depthCounts[d] := depthCounts[d] + 1
    }
    ; Sort labels alphabetically (insertion sort)
    if (labels.Length() > 1) {
        Loop, % labels.Length() - 1
        {
            i := A_Index + 1
            key := labels[i]
            j := i - 1
            while (j >= 1 && labels[j] > key) {
                labels[j + 1] := labels[j]
                j--
            }
            labels[j + 1] := key
        }
    }
    ; Sort depth keys
    depthKeys := []
    for k in depthCounts
        depthKeys.Push(k)
    if (depthKeys.Length() > 1) {
        Loop, % depthKeys.Length() - 1
        {
            i := A_Index + 1
            key := depthKeys[i]
            j := i - 1
            while (j >= 1 && depthKeys[j] > key) {
                depthKeys[j + 1] := depthKeys[j]
                j--
            }
            depthKeys[j + 1] := key
        }
    }
    fp := items.Length() . "|"
    for k, lbl in labels
        fp .= lbl . ","
    fp .= "|"
    for k, dk in depthKeys
        fp .= dk . ":" . depthCounts[dk] . ","
    return fp
}


;============================================================================================
; NURSING BOOSTER - CHECKBOX ENUMERATION
;============================================================================================

; Enumerate all TGroupBox direct children of the scrollbox, sorted by screen Y position
NB_EnumScrollBoxGroupBoxes(scrollBoxHwnd) {
    raw := []
    child := DllCall("GetWindow", "Ptr", scrollBoxHwnd, "UInt", 5, "Ptr")  ; GW_CHILD
    while (child) {
        VarSetCapacity(buf, 256, 0)
        DllCall("GetClassName", "Ptr", child, "Str", buf, "Int", 256)
        if (buf = "TGroupBox") {
            VarSetCapacity(rect, 16, 0)
            DllCall("GetWindowRect", "Ptr", child, "Ptr", &rect)
            y := NumGet(rect, 4, "Int")
            raw.Push({hwnd: child, y: y})
        }
        child := DllCall("GetWindow", "Ptr", child, "UInt", 2, "Ptr")  ; GW_HWNDNEXT
    }
    ; Sort by Y position (insertion sort)
    if (raw.Length() > 1) {
        Loop, % raw.Length() - 1
        {
            i := A_Index + 1
            key := raw[i]
            j := i - 1
            while (j >= 1 && raw[j].y > key.y) {
                raw[j + 1] := raw[j]
                j--
            }
            raw[j + 1] := key
        }
    }
    ; Return HWNDs in visual order
    sorted := []
    for k, item in raw
        sorted.Push(item.hwnd)
    return sorted
}

; Enumerate ALL descendant checkboxes within a container
NB_EnumDescendantCheckboxes(containerHwnd) {
    global NB__descCBResults, NB__descContainer
    NB__descCBResults := []
    NB__descContainer := containerHwnd
    enumCB := RegisterCallback("NB__EnumDescCBCallback", "Fast")
    DllCall("EnumChildWindows", "Ptr", containerHwnd, "Ptr", enumCB, "Ptr", 0)

    ; Compute nesting depth for each checkbox
    for k, item in NB__descCBResults {
        depth := 0
        p := DllCall("GetParent", "Ptr", item.hwnd, "Ptr")
        while (p && p != containerHwnd) {
            VarSetCapacity(pBuf, 256, 0)
            DllCall("GetClassName", "Ptr", p, "Str", pBuf, "Int", 256)
            if (pBuf = "TGroupBox")
                depth++
            p := DllCall("GetParent", "Ptr", p, "Ptr")
        }
        item.depth := depth
    }

    ; Resolve parent checkbox labels via sibling TDlgFieldPanel + MSAA
    for k, item in NB__descCBResults {
        if (item.label = "" && item.className = "TCPRSDialogParentCheckBox") {
            item.label := NB_ResolveParentCBLabel(item.hwnd)
        }
    }

    ; Sort by screen Y position (with X tiebreaker)
    results := NB__descCBResults
    if (results.Length() > 1) {
        Loop, % results.Length() - 1
        {
            i := A_Index + 1
            key := results[i]
            j := i - 1
            while (j >= 1 && (results[j].y > key.y || (results[j].y = key.y && results[j].x > key.x))) {
                results[j + 1] := results[j]
                j--
            }
            results[j + 1] := key
        }
    }

    return results
}

NB__EnumDescCBCallback(hwnd, lParam) {
    global NB__descCBResults
    VarSetCapacity(buf, 256, 0)
    DllCall("GetClassName", "Ptr", hwnd, "Str", buf, "Int", 256)
    if !(buf = "TCPRSDialogParentCheckBox" || buf = "TCPRSDialogCheckBox" || buf = "TORCheckBox")
        return 1

    SendMessage, 0x00F0, 0, 0,, ahk_id %hwnd%
    checked := ErrorLevel ? true : false

    ; Get screen position for Y-sorting
    VarSetCapacity(rect, 16, 0)
    DllCall("GetWindowRect", "Ptr", hwnd, "Ptr", &rect)
    y := NumGet(rect, 4, "Int")
    x := NumGet(rect, 0, "Int")

    ; Read label via simple DllCalls only (this is a Fast callback - no COM allowed)
    label := ""
    tLen := DllCall("GetWindowTextLengthW", "Ptr", hwnd, "Int")
    if (tLen > 0) {
        VarSetCapacity(tBuf, (tLen + 1) * 2, 0)
        DllCall("GetWindowTextW", "Ptr", hwnd, "Ptr", &tBuf, "Int", tLen + 1)
        label := Trim(StrGet(&tBuf, "UTF-16"))
    }

    NB__descCBResults.Push({hwnd: hwnd, className: buf, checked: checked, label: label, y: y, x: x})
    return 1
}

; Lightweight count-only enumeration for stability checks
NB_FindAllCheckboxes(dlgHwnd) {
    global NB__findCBResults
    NB__findCBResults := []
    enumCB := RegisterCallback("NB__EnumCBCallback", "Fast")
    DllCall("EnumChildWindows", "Ptr", dlgHwnd, "Ptr", enumCB, "Ptr", 0)
    return NB__findCBResults
}

NB__EnumCBCallback(hwnd, lParam) {
    global NB__findCBResults
    VarSetCapacity(buf, 256, 0)
    DllCall("GetClassName", "Ptr", hwnd, "Str", buf, "Int", 256)
    if !(buf = "TORCheckBox" || buf = "TCPRSDialogParentCheckBox" || buf = "TCPRSDialogCheckBox")
        return 1
    NB__findCBResults.Push({hwnd: hwnd, className: buf})
    return 1
}

; Wait until checkbox count stops changing
NB_WaitForStableCheckboxCount(dlgHwnd) {
    prevCount := 0
    stableRounds := 0
    Loop, 20
    {
        cbs := NB_FindAllCheckboxes(dlgHwnd)
        count := cbs.Length()
        if (count > 0 && count = prevCount) {
            stableRounds++
            if (stableRounds >= 3)
                return count
        } else {
            stableRounds := 0
        }
        prevCount := count
        Sleep, 500
    }
    return prevCount
}


;============================================================================================
; NURSING BOOSTER - DISMISS INTERMEDIATE POPUPS
;============================================================================================

NB_DismissIntermediatePopups() {
    Sleep, 150
    Loop, 3
    {
        found := false
        WinGet, wndList, List, ahk_exe CPRSChart.exe
        Loop, %wndList%
        {
            wnd := wndList%A_Index%
            WinGetClass, cls, ahk_id %wnd%
            if (cls = "TfrmRemDlg" || cls = "TCPRSChart" || cls = "TfrmFrame" || cls = "TfrmTemplateDialog")
                continue
            WinGetPos,,, w, h, ahk_id %wnd%
            if (w > 500 || h > 400)
                continue
            if (NB_HasDangerousButton(wnd))
                continue
            okHwnd := NB_FindOKButton(wnd)
            if (okHwnd) {
                PostMessage, 0x00F5, 0, 0,, ahk_id %okHwnd%
                Sleep, 200
                found := true
            }
        }
        if (!found)
            break
    }
}

NB_HasDangerousButton(windowHwnd) {
    global NB__hasDangerous
    NB__hasDangerous := false
    enumDangerous := RegisterCallback("NB__CheckDangerousCallback", "Fast")
    DllCall("EnumChildWindows", "Ptr", windowHwnd, "Ptr", enumDangerous, "Ptr", 0)
    return NB__hasDangerous
}

NB__CheckDangerousCallback(hwnd, lParam) {
    global NB__hasDangerous
    VarSetCapacity(buf, 256, 0)
    DllCall("GetClassName", "Ptr", hwnd, "Str", buf, "Int", 256)
    if (InStr(buf, "TEdit") || InStr(buf, "TMemo") || InStr(buf, "TRichEdit")) {
        NB__hasDangerous := true
        return 0
    }
    if (InStr(buf, "TButton") || InStr(buf, "TBitBtn")) {
        SendMessage, 0x000E, 0, 0,, ahk_id %hwnd%
        tLen := ErrorLevel
        if (tLen > 0) {
            VarSetCapacity(textBuf, (tLen + 1) * 2, 0)
            SendMessage, 0x000D, tLen + 1, &textBuf,, ahk_id %hwnd%
            textStr := StrGet(&textBuf)
            StringUpper, textUpper, textStr
            if (InStr(textUpper, "FINISH") || InStr(textUpper, "SUBMIT")
                || InStr(textUpper, "SIGN") || InStr(textUpper, "FILE")
                || InStr(textUpper, "COMPLETE") || InStr(textUpper, "SAVE")
                || InStr(textUpper, "DELETE") || InStr(textUpper, "REMOVE")) {
                NB__hasDangerous := true
                return 0
            }
        }
    }
    return 1
}

NB_FindOKButton(windowHwnd) {
    global NB__foundOKHwnd
    NB__foundOKHwnd := 0
    enumOK := RegisterCallback("NB__FindOKCallback", "Fast")
    DllCall("EnumChildWindows", "Ptr", windowHwnd, "Ptr", enumOK, "Ptr", 0)
    return NB__foundOKHwnd
}

NB__FindOKCallback(hwnd, lParam) {
    global NB__foundOKHwnd
    VarSetCapacity(buf, 256, 0)
    DllCall("GetClassName", "Ptr", hwnd, "Str", buf, "Int", 256)
    if !(InStr(buf, "TButton") || InStr(buf, "TBitBtn"))
        return 1
    SendMessage, 0x000E, 0, 0,, ahk_id %hwnd%
    tLen := ErrorLevel
    if (tLen > 0) {
        VarSetCapacity(textBuf, (tLen + 1) * 2, 0)
        SendMessage, 0x000D, tLen + 1, &textBuf,, ahk_id %hwnd%
        textStr := StrGet(&textBuf)
        StringUpper, textUpper, textStr
        if (textUpper = "OK" || textUpper = "&OK" || textUpper = "CONTINUE"
            || textUpper = "&CONTINUE" || textUpper = "YES" || textUpper = "&YES") {
            NB__foundOKHwnd := hwnd
            return 0
        }
    }
    return 1
}


;============================================================================================
; NURSING BOOSTER - LOAD / DELETE TEMPLATE
;============================================================================================

NB_BtnLoadSavedTemplate:
    dlgHwnd := NB_FindActiveDialogWindow()
    if (!dlgHwnd) {
        MsgBox, 48, %NB_AppTitle%, Open a template or reminder dialogue in CPRS first then load a template.
        return
    }
    NB_templates := []
    Loop, Files, %NB_TemplateDir%\*.json
    {
        NB_templates.Push(A_LoopFileFullPath)
    }
    if (NB_templates.Length() = 0) {
        MsgBox, 64, %NB_AppTitle%, No saved templates found.`n`nTo create one:`n1. Open a reminder dialogue in CPRS`n2. Check the boxes the way you want`n3. Select 'Save Template' from the Nursing Booster dropdown
        return
    }

    ; Build a list of template names
    NB_loadList := ""
    for k, path in NB_templates {
        RegExMatch(path, ".*\\(.*)\.json$", match)
        NB_loadList .= (NB_loadList != "" ? "|" : "") . match1
    }

    Gui, 68:Destroy
    Gui, 68:+AlwaysOnTop +ToolWindow
    Gui, 68:Font, s9, Segoe UI
    Gui, 68:Add, Text,, Select a template to apply:
    Gui, 68:Add, ListBox, w300 h200 vNB_LoadSelection, %NB_loadList%
    Gui, 68:Add, Button, y+5 w120 gNB_DoLoadTemplate Default, Apply
    Gui, 68:Add, Button, x+5 w120 gNB_CancelLoad, Cancel
    Gui, 68:Show,, Load Nursing Template
return

NB_DoLoadTemplate:
    Gui, 68:Submit
    if (NB_LoadSelection = "") {
        MsgBox, 48, %NB_AppTitle%, Select a template.
        return
    }
    Gui, 68:Destroy
    templatePath := NB_TemplateDir . "\" . NB_SanitizeFilename(NB_LoadSelection) . ".json"
    if (FileExist(templatePath)) {
        dlgWnd := NB_FindActiveDialogWindow()
        if (dlgWnd) {
            WinActivate, ahk_id %dlgWnd%
            Sleep, 200
            NB_ApplyTemplate(templatePath)
        }
    }
return

NB_CancelLoad:
    Gui, 68:Destroy
return


NB_BtnDeleteTemplate:
    NB_delTemplates := []
    Loop, Files, %NB_TemplateDir%\*.json
    {
        NB_delTemplates.Push(A_LoopFileName)
    }
    if (NB_delTemplates.Length() = 0) {
        MsgBox, 64, %NB_AppTitle%, No saved templates to delete.
        return
    }
    list := ""
    for i, f in NB_delTemplates
        list .= i . ": " . StrReplace(f, ".json", "") . "`n"
    InputBox, deleteIdx, Delete Template, Enter the number of the template to delete:`n`n%list%,, 300, 400,,,, 1
    if (ErrorLevel || deleteIdx = "")
        return
    if deleteIdx is not integer
    {
        MsgBox, 48, %NB_AppTitle%, Enter a number.
        return
    }
    if (deleteIdx < 1 || deleteIdx > NB_delTemplates.Length()) {
        MsgBox, 48, %NB_AppTitle%, Invalid selection.
        return
    }
    delName := StrReplace(NB_delTemplates[deleteIdx], ".json", "")
    MsgBox, 36, %NB_AppTitle%, Delete template "%delName%"?
    IfMsgBox, Yes
    {
        delPath := NB_TemplateDir . "\" . NB_delTemplates[deleteIdx]
        FileDelete, %delPath%
        ToolTip, Template "%delName%" deleted
        SetTimer, NB_ClearToolTip, -2000
    }
return


;============================================================================================
; NURSING BOOSTER - TOP-LEVEL PARENT DISCOVERY
;============================================================================================

NB_FindVisibleScrollBox(dlgHwnd) {
    child := DllCall("GetWindow", "Ptr", dlgHwnd, "UInt", 5, "Ptr")
    while (child) {
        VarSetCapacity(buf, 256, 0)
        DllCall("GetClassName", "Ptr", child, "Str", buf, "Int", 256)
        if (buf = "TScrollBox") {
            style := DllCall("GetWindowLong", "Ptr", child, "Int", -16, "Int")
            if (style & 0x10000000)
                return child
        }
        child := DllCall("GetWindow", "Ptr", child, "UInt", 2, "Ptr")
    }
    return 0
}

NB_EnumTopLevelParents(scrollBoxHwnd) {
    parents := []
    seenDirectParent := false
    child := DllCall("GetWindow", "Ptr", scrollBoxHwnd, "UInt", 5, "Ptr")
    while (child) {
        VarSetCapacity(buf, 256, 0)
        DllCall("GetClassName", "Ptr", child, "Str", buf, "Int", 256)
        if (buf = "TCPRSDialogParentCheckBox") {
            seenDirectParent := true
            SendMessage, 0x00F0, 0, 0,, ahk_id %child%
            checked := ErrorLevel ? true : false
            parents.Push({hwnd: child, checked: checked})
        } else if (buf = "TGroupBox" && seenDirectParent) {
            gbChild := DllCall("GetWindow", "Ptr", child, "UInt", 5, "Ptr")
            while (gbChild) {
                VarSetCapacity(gbBuf, 256, 0)
                DllCall("GetClassName", "Ptr", gbChild, "Str", gbBuf, "Int", 256)
                if (gbBuf = "TCPRSDialogParentCheckBox") {
                    SendMessage, 0x00F0, 0, 0,, ahk_id %gbChild%
                    checked := ErrorLevel ? true : false
                    parents.Push({hwnd: gbChild, checked: checked})
                }
                gbChild := DllCall("GetWindow", "Ptr", gbChild, "UInt", 2, "Ptr")
            }
        }
        child := DllCall("GetWindow", "Ptr", child, "UInt", 2, "Ptr")
    }
    return parents
}


;============================================================================================
; NURSING BOOSTER - TEMPLATE PARSING
;============================================================================================

NB_ParseFlatCheckboxes(jsonContent) {
    items := []

    ; Find the "checkboxes" array (top-level, format v7)
    cPos := InStr(jsonContent, """checkboxes""")
    if (!cPos)
        return items

    arrStart := InStr(jsonContent, "[",, cPos)
    if (!arrStart)
        return items

    ; Find matching ]
    depth := 1
    scanPos := arrStart + 1
    arrEnd := 0
    while (scanPos <= StrLen(jsonContent) && depth > 0) {
        ch := SubStr(jsonContent, scanPos, 1)
        if (ch = "[")
            depth++
        else if (ch = "]")
            depth--
        if (depth = 0)
            arrEnd := scanPos
        scanPos++
    }
    if (!arrEnd)
        return items

    ; Parse each checkbox object
    itemPos := arrStart
    while (itemPos := InStr(jsonContent, "{",, itemPos + 1)) {
        if (itemPos > arrEnd)
            break
        itemEnd := InStr(jsonContent, "}",, itemPos)
        if (!itemEnd)
            break
        itemStr := SubStr(jsonContent, itemPos, itemEnd - itemPos + 1)

        idx := 0
        if (RegExMatch(itemStr, """idx"":\s*(\d+)", idxM))
            idx := idxM1 + 0

        cls := ""
        if (RegExMatch(itemStr, """cls"":\s*""([^""]*)""", clsM))
            cls := clsM1

        checked := (InStr(itemStr, """checked"": true") || InStr(itemStr, """checked"":true"))
            ? true : false

        depthVal := 0
        if (RegExMatch(itemStr, """depth"":\s*(\d+)", depM))
            depthVal := depM1 + 0

        label := ""
        if (RegExMatch(itemStr, """label"":\s*""((?:[^""\\]|\\.)*)""", lblM))
            label := lblM1

        items.Push({idx: idx, cls: cls, checked: checked, label: label, depth: depthVal})
        itemPos := itemEnd
    }

    return items
}

NB_ParseTopLevelParents(jsonContent) {
    states := []
    pos := InStr(jsonContent, """topLevelParents""")
    if (!pos)
        return states
    arrStart := InStr(jsonContent, "[",, pos)
    arrEnd := InStr(jsonContent, "]",, arrStart)
    if (!arrStart || !arrEnd)
        return states
    arrStr := SubStr(jsonContent, arrStart + 1, arrEnd - arrStart - 1)
    searchPos := 1
    while (searchPos <= StrLen(arrStr)) {
        chunk := SubStr(arrStr, searchPos, 6)
        if (SubStr(chunk, 1, 4) = "true") {
            states.Push(true)
            searchPos += 4
        } else if (SubStr(chunk, 1, 5) = "false") {
            states.Push(false)
            searchPos += 5
        } else {
            searchPos++
        }
    }
    return states
}

; Parse groups array from format-3 JSON
NB_ParseGroups(jsonContent) {
    groups := []

    gPos := InStr(jsonContent, """groups""")
    if (!gPos)
        return groups

    gArrStart := InStr(jsonContent, "[",, gPos)
    if (!gArrStart)
        return groups

    ; Find matching ] using depth counting
    depth := 1
    scanPos := gArrStart + 1
    gArrEnd := 0
    while (scanPos <= StrLen(jsonContent) && depth > 0) {
        ch := SubStr(jsonContent, scanPos, 1)
        if (ch = "[")
            depth++
        else if (ch = "]")
            depth--
        if (depth = 0)
            gArrEnd := scanPos
        scanPos++
    }
    if (!gArrEnd)
        return groups

    ; Find each group object
    searchPos := gArrStart
    while (true) {
        cbPos := InStr(jsonContent, """checkboxes""",, searchPos + 1)
        if (!cbPos || cbPos > gArrEnd)
            break

        cbArrStart := InStr(jsonContent, "[",, cbPos)
        if (!cbArrStart || cbArrStart > gArrEnd)
            break

        ; Find matching ]
        cbDepth := 1
        cbScan := cbArrStart + 1
        cbArrEnd := 0
        while (cbScan <= StrLen(jsonContent) && cbDepth > 0) {
            c := SubStr(jsonContent, cbScan, 1)
            if (c = "[")
                cbDepth++
            else if (c = "]")
                cbDepth--
            if (cbDepth = 0)
                cbArrEnd := cbScan
            cbScan++
        }
        if (!cbArrEnd)
            break

        ; Parse checkbox items within this group
        groupItems := []
        itemPos := cbArrStart
        while (itemPos := InStr(jsonContent, "{",, itemPos + 1)) {
            if (itemPos > cbArrEnd)
                break
            itemEnd := InStr(jsonContent, "}",, itemPos)
            if (!itemEnd)
                break
            itemStr := SubStr(jsonContent, itemPos, itemEnd - itemPos + 1)

            idx := 0
            if (RegExMatch(itemStr, """idx"":\s*(\d+)", idxM))
                idx := idxM1 + 0

            cls := ""
            if (RegExMatch(itemStr, """cls"":\s*""([^""]*)""", clsM))
                cls := clsM1

            checked := (InStr(itemStr, """checked"": true") || InStr(itemStr, """checked"":true"))
                ? true : false

            depthVal := 0
            if (RegExMatch(itemStr, """depth"":\s*(\d+)", depM))
                depthVal := depM1 + 0

            label := ""
            if (RegExMatch(itemStr, """label"":\s*""((?:[^""\\]|\\.)*)""", lblM))
                label := lblM1

            groupItems.Push({idx: idx, cls: cls, checked: checked, label: label, depth: depthVal})
            itemPos := itemEnd
        }

        groups.Push(groupItems)
        searchPos := cbArrEnd
    }

    return groups
}


;============================================================================================
; NURSING BOOSTER - DIALOG DUMP (Debug tool)
; Triggered from Nursing Booster dropdown or Ctrl+Shift+D
;============================================================================================

NB_DumpDialogControls:
    dlgHwnd := NB_FindActiveDialogWindow()
    if (!dlgHwnd) {
        MsgBox, 48, %NB_AppTitle%, Open a reminder dialogue in CPRS first.
        return
    }
    FormatTime, nowStamp,, yyyyMMddHHmmss
    dumpPath := NB_LogDir . "\dialog_dump_" . nowStamp . ".txt"
    FileDelete, %dumpPath%
    FormatTime, nowDisp,, yyyy-MM-dd HH:mm:ss
    WinGetTitle, dlgTitle, ahk_id %dlgHwnd%
    WinGetClass, dlgClass, ahk_id %dlgHwnd%
    dumpHeader := "=== CPRS Dialog Control Dump ===`n"
    dumpHeader .= "Time: " . nowDisp . "`n"
    dumpHeader .= "Dialog Title: " . dlgTitle . "`n"
    dumpHeader .= "Dialog Class: " . dlgClass . "`n"
    dumpHeader .= "Dialog HWND: " . dlgHwnd . "`n`n"
    FileAppend, %dumpHeader%, %dumpPath%, UTF-8

    global NB__dumpPath := dumpPath
    global NB__dumpDlgHwnd := dlgHwnd
    global NB__dumpCount := 0
    global NB__dumpCBCount := 0
    global NB__dumpParentCBs := []

    enumDump := RegisterCallback("NB__DumpCallback", "Fast")
    DllCall("EnumChildWindows", "Ptr", dlgHwnd, "Ptr", enumDump, "Ptr", 0)

    ; Post-process: resolve parent checkbox labels via sibling TDlgFieldPanel
    ; NOTE: CPRS renders parent CB labels using non-windowed TLabel (TGraphicControl)
    ; when no screen reader is active. These have no HWND and are invisible to all
    ; Windows APIs (Win32, MSAA, UI Automation). Labels may show as "(not accessible)".
    if (NB__dumpParentCBs.Length() > 0) {
        parentSection := "`n=== Parent Checkboxes ===`n"
        parentSection .= "(Parent CB labels use non-windowed TLabel - may not be readable)`n"
        for i, pcb in NB__dumpParentCBs {
            label := NB_ResolveParentCBLabel(pcb.hwnd)
            if (label = "")
                label := "(not accessible)"
            chk := pcb.checked ? "YES" : "NO"
            parentSection .= "  CHECKED=" . chk . " label='" . label . "'`n"
        }
        FileAppend, %parentSection%, %dumpPath%, UTF-8
    }

    dumpFooter := "`n=== Summary ===`nTotal controls: " . NB__dumpCount . "`nCheckboxes: " . NB__dumpCBCount . "`n"
    FileAppend, %dumpFooter%, %dumpPath%, UTF-8

    MsgBox, 64, %NB_AppTitle%, Dump written to:`n%dumpPath%`n`n%NB__dumpCount% controls and %NB__dumpCBCount% checkboxes.
return

NB__DumpCallback(hwnd, lParam) {
    global NB__dumpPath, NB__dumpDlgHwnd, NB__dumpCount, NB__dumpCBCount, NB__dumpParentCBs
    NB__dumpCount++

    VarSetCapacity(buf, 256, 0)
    DllCall("GetClassName", "Ptr", hwnd, "Str", buf, "Int", 256)
    className := buf

    ; Simple text retrieval only (this is a Fast callback - no COM allowed)
    text := ""
    tLen := DllCall("GetWindowTextLengthW", "Ptr", hwnd, "Int")
    if (tLen > 0) {
        VarSetCapacity(tBuf, (tLen + 1) * 2, 0)
        DllCall("GetWindowTextW", "Ptr", hwnd, "Ptr", &tBuf, "Int", tLen + 1)
        text := Trim(StrGet(&tBuf, "UTF-16"))
    }

    depth := 0
    p := hwnd
    Loop {
        p := DllCall("GetParent", "Ptr", p, "Ptr")
        if (!p || p = NB__dumpDlgHwnd)
            break
        depth++
    }

    parentHwnd := DllCall("GetParent", "Ptr", hwnd, "Ptr")
    parentClass := "none"
    if (parentHwnd) {
        VarSetCapacity(parentBuf, 256, 0)
        DllCall("GetClassName", "Ptr", parentHwnd, "Str", parentBuf, "Int", 256)
        parentClass := parentBuf
    }

    extra := ""
    if (className = "TORCheckBox" || className = "TCPRSDialogParentCheckBox" || className = "TCPRSDialogCheckBox") {
        SendMessage, 0x00F0, 0, 0,, ahk_id %hwnd%
        checked := ErrorLevel
        extra := " CHECKED=" . (checked ? "YES" : "NO")
        NB__dumpCBCount++
        ; Track parent checkboxes for post-processing label lookup
        if (className = "TCPRSDialogParentCheckBox")
            NB__dumpParentCBs.Push({hwnd: hwnd, checked: checked})
    }

    style := DllCall("GetWindowLong", "Ptr", hwnd, "Int", -16, "Int")
    visible := (style & 0x10000000) ? "Y" : "N"

    indent := ""
    Loop, %depth%
        indent .= "  "

    line := indent . className . " hwnd=" . hwnd . " text='" . text . "' vis=" . visible . " parent=" . parentClass . extra . "`n"
    FileAppend, %line%, %NB__dumpPath%, UTF-8
    return 1
}


;============================================================================================
; NURSING BOOSTER - UTILITY FUNCTIONS
;============================================================================================

NB_ClearToolTip:
    ToolTip
return

NB_SanitizeFilename(name) {
    result := RegExReplace(Trim(name), "[<>:""/\\|?*]", "_")
    return result
}

NB_EscJson(str) {
    str := StrReplace(str, "\", "\\")
    str := StrReplace(str, """", "\""")
    str := StrReplace(str, "`n", "\n")
    str := StrReplace(str, "`r", "\r")
    str := StrReplace(str, "`t", "\t")
    return """" . str . """"
}

; Attempt to resolve parent checkbox label. CPRS sets parent CB Caption to ' '
; and renders the text via a non-windowed TLabel (TGraphicControl) inside a
; sibling TDlgFieldPanel. Without a screen reader (JAWS), TLabel has no HWND
; and is invisible to Win32, MSAA, and UI Automation APIs.
; This function tries GetWindowText on the sibling panel and its windowed
; children as a best-effort attempt. Returns "" if unresolvable.
NB_ResolveParentCBLabel(cbHwnd) {
    static junkNames := "|system|application|pane|check box|"
    if !DllCall("IsWindow", "Ptr", cbHwnd, "Int")
        return ""
    cbParent := DllCall("GetParent", "Ptr", cbHwnd, "Ptr")
    if (!cbParent)
        return ""
    ; Get checkbox screen Y position
    VarSetCapacity(cbRect, 16, 0)
    DllCall("GetWindowRect", "Ptr", cbHwnd, "Ptr", &cbRect)
    cbY := NumGet(cbRect, 4, "Int")
    ; Find the nearest sibling TDlgFieldPanel by Y position
    bestPanel := 0
    bestDist := 999999
    child := DllCall("GetWindow", "Ptr", cbParent, "UInt", 5, "Ptr")  ; GW_CHILD
    while (child) {
        VarSetCapacity(clsBuf, 256, 0)
        DllCall("GetClassName", "Ptr", child, "Str", clsBuf, "Int", 256)
        if (clsBuf = "TDlgFieldPanel") {
            VarSetCapacity(pRect, 16, 0)
            DllCall("GetWindowRect", "Ptr", child, "Ptr", &pRect)
            pY := NumGet(pRect, 4, "Int")
            dist := Abs(pY - cbY)
            if (dist < bestDist) {
                bestPanel := child
                bestDist := dist
            }
        }
        child := DllCall("GetWindow", "Ptr", child, "UInt", 2, "Ptr")  ; GW_HWNDNEXT
    }
    if (!bestPanel || bestDist > 100)
        return ""
    ; Try GetWindowText on the panel itself
    text := ""
    tLen := DllCall("GetWindowTextLengthW", "Ptr", bestPanel, "Int")
    if (tLen > 0) {
        VarSetCapacity(tBuf, (tLen + 1) * 2, 0)
        DllCall("GetWindowTextW", "Ptr", bestPanel, "Ptr", &tBuf, "Int", tLen + 1)
        text := Trim(StrGet(&tBuf, "UTF-16"))
    }
    if (text != "" && !InStr(junkNames, "|" . text . "|"))
        return text
    ; Try GetWindowText on windowed children of the panel
    panelChild := DllCall("GetWindow", "Ptr", bestPanel, "UInt", 5, "Ptr")
    while (panelChild) {
        pcLen := DllCall("GetWindowTextLengthW", "Ptr", panelChild, "Int")
        if (pcLen > 0) {
            VarSetCapacity(pcBuf, (pcLen + 1) * 2, 0)
            DllCall("GetWindowTextW", "Ptr", panelChild, "Ptr", &pcBuf, "Int", pcLen + 1)
            text := Trim(StrGet(&pcBuf, "UTF-16"))
            if (text != "" && !InStr(junkNames, "|" . text . "|"))
                return text
        }
        panelChild := DllCall("GetWindow", "Ptr", panelChild, "UInt", 2, "Ptr")
    }
    return ""
}


;============================================================================================
; NURSING BOOSTER - HOTKEYS
;============================================================================================

^+b::
    gosub NB_TogglePanel
return

^+d::
    gosub NB_DumpDialogControls
return


;############################################################################################
;############################################################################################
;###                                                                                      ###
;###              KEY MACRO SYSTEM - Keyboard sequence builder & player                   ###
;###                                                                                      ###
;###  Build macros by manually defining steps (Tab, Space, Down, Up, etc.)                ###
;###  Play them back to fill out CPRS reminder dialogues via keyboard.                    ###
;###  No keyboard hooks or recording. Plain text macro files.                             ###
;###                                                                                      ###
;############################################################################################
;############################################################################################


;============================================================================================
; KEY MACRO BUILDER (Gui 69)
;============================================================================================

NB_OpenMacroBuilder:
    global NB_MacroSteps, NB_MacroBuilderOpen, NB_MacroKeepSteps
    if (NB_MacroBuilderOpen) {
        Gui, 69:Show
        NB_MacroRefreshList()
        return
    }
    ; Only reset steps if not pre-loaded (e.g. from recording)
    if (!NB_MacroKeepSteps)
        NB_MacroSteps := []
    NB_MacroKeepSteps := 0
    NB_MacroBuilderOpen := 1

    Gui, 69:Destroy
    Gui, 69:+AlwaysOnTop +ToolWindow
    Gui, 69:Font, s9, Segoe UI
    Gui, 69:Color, F5F5F5

    Gui, 69:Add, Text, x10 y10 w460 cNavy, KEY MACRO BUILDER - Define keyboard steps to replay in CPRS
    Gui, 69:Add, Text, x10 y30 w460 c666666, Each step sends a key a number of times. Build your sequence then save it.

    ; --- Add Step controls ---
    Gui, 69:Add, GroupBox, x10 y55 w460 h70, Add a Step
    Gui, 69:Add, Text, x20 y75, Key:
    Gui, 69:Add, DropDownList, x50 y72 w110 vNB_MacroKeyChoice altsubmit, Tab|Shift+Tab|Space|Down|Up|Left|Right|Enter|Escape|Home|End
    Gui, 69:Add, Text, x170 y75, Count:
    Gui, 69:Add, Edit, x210 y72 w40 vNB_MacroCountEdit, 1
    Gui, 69:Add, UpDown, Range1-99, 1
    Gui, 69:Add, Text, x260 y75, Delay(ms):
    Gui, 69:Add, Edit, x315 y72 w45 vNB_MacroDelayEdit, 150
    Gui, 69:Add, Button, x370 y71 w90 h24 gNB_MacroAddStep, Add Step

    ; --- Step list ---
    Gui, 69:Add, Text, x10 y132, Steps (played top to bottom  double-click to edit):
    Gui, 69:Add, ListView, x10 y150 w460 h200 vNB_MacroLV gNB_MacroLVAction Grid Multi, #|Key|Count|Delay (ms)
    LV_ModifyCol(1, 30)
    LV_ModifyCol(2, 120)
    LV_ModifyCol(3, 60)
    LV_ModifyCol(4, 80)

    ; --- Action buttons ---
    Gui, 69:Add, Button, x10  y358 w70 h28 gNB_MacroMoveUp, Move Up
    Gui, 69:Add, Button, x85  y358 w70 h28 gNB_MacroMoveDown, Move Down
    Gui, 69:Add, Button, x160 y358 w85 h28 gNB_MacroDeleteStep, Delete Step
    Gui, 69:Add, Button, x250 y358 w70 h28 gNB_MacroClearAll, Clear All
    Gui, 69:Add, Button, x325 y358 w70 h28 gNB_MacroEditStep, Edit Step
    Gui, 69:Add, Text, x10 y388 c999999, (Ctrl+A = select all  |  Ctrl+click or Shift+click = multi-select)

    ; --- Bulk edit selected ---
    Gui, 69:Add, GroupBox, x10 y405 w460 h60, Apply to Selected Steps
    Gui, 69:Add, Text, x20 y425, Delay:
    Gui, 69:Add, Edit, x55 y422 w50 vNB_BulkDelay, 150
    Gui, 69:Add, Button, x110 y421 w70 h24 gNB_BulkSetDelay, Set Delay
    Gui, 69:Add, Text, x190 y425, Count:
    Gui, 69:Add, Edit, x230 y422 w40 vNB_BulkCount, 1
    Gui, 69:Add, UpDown, Range1-99, 1
    Gui, 69:Add, Button, x275 y421 w72 h24 gNB_BulkSetCount, Set Count
    Gui, 69:Add, Text, x355 y425, Key:
    Gui, 69:Add, DropDownList, x382 y421 w85 vNB_BulkKey altsubmit, Tab|Shift+Tab|Space|Down|Up|Left|Right|Enter|Escape|Home|End
    Gui, 69:Add, Button, x355 y443 w112 h18 gNB_BulkSetKey, Set Key

    Gui, 69:Add, Text, x10 y472 w460 h1 0x10  ; horizontal line

    ; --- Save / Load / Play / Close ---
    Gui, 69:Add, Button, x10  y480 w100 h30 gNB_MacroSave, Save Macro
    Gui, 69:Add, Button, x115 y480 w100 h30 gNB_MacroLoad, Load Macro
    Gui, 69:Add, Button, x220 y480 w100 h30 gNB_MacroTestPlay, Test Play
    Gui, 69:Add, Button, x325 y480 w145 h30 gNB_MacroPlayInCPRS Default, Play in CPRS
    Gui, 69:Add, Button, x400 y8 w70 h22 gNB_MacroBuilderClose, Close

    Gui, 69:Show, w480 h520, Key Macro Builder
return

69GuiClose:
NB_MacroBuilderClose:
    Gui, 69:Hide
    NB_MacroBuilderOpen := 0
return


;============================================================================================
; KEY MACRO - ADD / EDIT / REORDER STEPS
;============================================================================================

NB_MacroAddStep:
    Gui, 69:Submit, NoHide
    global NB_MacroSteps

    ; Map dropdown index to key name
    keyNames := ["Tab", "Shift+Tab", "Space", "Down", "Up", "Left", "Right", "Enter", "Escape", "Home", "End"]
    if (NB_MacroKeyChoice < 1 || NB_MacroKeyChoice > keyNames.Length()) {
        MsgBox, 48, %NB_AppTitle%, Select a key first.
        return
    }
    keyName := keyNames[NB_MacroKeyChoice]
    stepCount := NB_MacroCountEdit + 0
    if (stepCount < 1)
        stepCount := 1
    stepDelay := NB_MacroDelayEdit + 0
    if (stepDelay < 0)
        stepDelay := 150

    NB_MacroSteps.Push({key: keyName, count: stepCount, delay: stepDelay})
    NB_MacroRefreshList()
return

NB_MacroDeleteStep:
    Gui, 69:Default
    row := LV_GetNext(0, "Focused")
    if (row < 1)
        return
    global NB_MacroSteps
    NB_MacroSteps.RemoveAt(row)
    NB_MacroRefreshList()
return

NB_MacroMoveUp:
    Gui, 69:Default
    row := LV_GetNext(0, "Focused")
    if (row < 2)
        return
    global NB_MacroSteps
    temp := NB_MacroSteps[row]
    NB_MacroSteps[row] := NB_MacroSteps[row - 1]
    NB_MacroSteps[row - 1] := temp
    NB_MacroRefreshList()
    LV_Modify(row - 1, "Focus Select")
return

NB_MacroMoveDown:
    Gui, 69:Default
    row := LV_GetNext(0, "Focused")
    global NB_MacroSteps
    if (row < 1 || row >= NB_MacroSteps.Length())
        return
    temp := NB_MacroSteps[row]
    NB_MacroSteps[row] := NB_MacroSteps[row + 1]
    NB_MacroSteps[row + 1] := temp
    NB_MacroRefreshList()
    LV_Modify(row + 1, "Focus Select")
return

NB_MacroClearAll:
    global NB_MacroSteps
    MsgBox, 36, %NB_AppTitle%, Clear all steps?
    IfMsgBox, Yes
    {
        NB_MacroSteps := []
        NB_MacroRefreshList()
    }
return

; --- ListView double-click handler ---
NB_MacroLVAction:
    if (A_GuiEvent = "DoubleClick") {
        gosub NB_MacroEditStep
    }
return

; --- Edit Step dialog (Gui 73) ---
NB_MacroEditStep:
    Gui, 69:Default
    global NB_MacroSteps, NB_AppTitle, NB_EditStepRow
    NB_EditStepRow := LV_GetNext(0, "Focused")
    if (NB_EditStepRow < 1) {
        MsgBox, 48, %NB_AppTitle%, Select a step to edit first.
        return
    }
    step := NB_MacroSteps[NB_EditStepRow]
    editKey := step.key
    editCount := step.count
    editDelay := step.delay

    Gui, 73:Destroy
    Gui, 73:+AlwaysOnTop +ToolWindow +Owner69
    Gui, 73:Font, s9, Segoe UI
    Gui, 73:Color, F5F5F5

    nb_editRow := NB_EditStepRow
    Gui, 73:Add, Text, x10 y10, Editing step #%nb_editRow%

    Gui, 73:Add, Text, x10 y38, Key:
    keyList := "Tab|Shift+Tab|Space|Down|Up|Left|Right|Enter|Escape|Home|End"
    Gui, 73:Add, DropDownList, x70 y35 w120 vNB_EditKeyChoice, %keyList%
    ; Select the current key
    GuiControl, 73:ChooseString, NB_EditKeyChoice, %editKey%

    Gui, 73:Add, Text, x10 y68, Count:
    Gui, 73:Add, Edit, x70 y65 w50 vNB_EditCountVal, %editCount%
    Gui, 73:Add, UpDown, Range1-99, %editCount%

    Gui, 73:Add, Text, x10 y98, Delay (ms):
    Gui, 73:Add, Edit, x70 y95 w50 vNB_EditDelayVal, %editDelay%

    Gui, 73:Add, Button, x10 y130 w80 h28 gNB_EditStepSave Default, OK
    Gui, 73:Add, Button, x100 y130 w80 h28 gNB_EditStepCancel, Cancel

    Gui, 73:Show, w200 h168, Edit Step
return

NB_EditStepSave:
    Gui, 73:Submit
    global NB_MacroSteps, NB_EditStepRow
    newKey := NB_EditKeyChoice
    newCount := NB_EditCountVal + 0
    if (newCount < 1)
        newCount := 1
    newDelay := NB_EditDelayVal + 0
    if (newDelay < 0)
        newDelay := 150
    NB_MacroSteps[NB_EditStepRow] := {key: newKey, count: newCount, delay: newDelay}
    Gui, 73:Destroy
    NB_MacroRefreshList()
return

NB_EditStepCancel:
73GuiClose:
73GuiEscape:
    Gui, 73:Destroy
return

; --- Bulk edit: set delay on all selected steps ---
NB_BulkSetDelay:
    Gui, 69:Submit, NoHide
    Gui, 69:Default
    global NB_MacroSteps, NB_AppTitle
    newDelay := NB_BulkDelay + 0
    if (newDelay < 0)
        newDelay := 150
    changed := 0
    row := 0
    Loop {
        row := LV_GetNext(row)
        if (row = 0)
            break
        NB_MacroSteps[row].delay := newDelay
        changed++
    }
    if (changed = 0) {
        MsgBox, 48, %NB_AppTitle%, No steps selected. Select rows first (Ctrl+A for all).
        return
    }
    NB_MacroRefreshList()
    ToolTip, Set delay to %newDelay% ms on %changed% steps
    SetTimer, NB_ClearToolTip, -2000
return

; --- Bulk edit: set count on all selected steps ---
NB_BulkSetCount:
    Gui, 69:Submit, NoHide
    Gui, 69:Default
    global NB_MacroSteps, NB_AppTitle
    newCount := NB_BulkCount + 0
    if (newCount < 1)
        newCount := 1
    changed := 0
    row := 0
    Loop {
        row := LV_GetNext(row)
        if (row = 0)
            break
        NB_MacroSteps[row].count := newCount
        changed++
    }
    if (changed = 0) {
        MsgBox, 48, %NB_AppTitle%, No steps selected. Select rows first (Ctrl+A for all).
        return
    }
    NB_MacroRefreshList()
    ToolTip, Set count to %newCount% on %changed% steps
    SetTimer, NB_ClearToolTip, -2000
return

; --- Bulk edit: set key on all selected steps ---
NB_BulkSetKey:
    Gui, 69:Submit, NoHide
    Gui, 69:Default
    global NB_MacroSteps, NB_AppTitle
    keyNames := ["Tab", "Shift+Tab", "Space", "Down", "Up", "Left", "Right", "Enter", "Escape", "Home", "End"]
    if (NB_BulkKey < 1 || NB_BulkKey > keyNames.Length()) {
        MsgBox, 48, %NB_AppTitle%, Pick a key from the dropdown first.
        return
    }
    newKey := keyNames[NB_BulkKey]
    changed := 0
    row := 0
    Loop {
        row := LV_GetNext(row)
        if (row = 0)
            break
        NB_MacroSteps[row].key := newKey
        changed++
    }
    if (changed = 0) {
        MsgBox, 48, %NB_AppTitle%, No steps selected. Select rows first (Ctrl+A for all).
        return
    }
    NB_MacroRefreshList()
    ToolTip, Set key to %newKey% on %changed% steps
    SetTimer, NB_ClearToolTip, -2000
return

NB_MacroRefreshList() {
    global NB_MacroSteps
    Gui, 69:Default
    LV_Delete()
    for i, step in NB_MacroSteps {
        LV_Add("", i, step.key, step.count, step.delay)
    }
}


;============================================================================================
; KEY MACRO - SAVE / LOAD
;============================================================================================

NB_MacroSave:
    global NB_MacroSteps, NB_MacroDir, NB_AppTitle
    if (NB_MacroSteps.Length() = 0) {
        MsgBox, 48, %NB_AppTitle%, Add some steps first.
        return
    }
    InputBox, macroName, Save Key Macro, Macro name (e.g. "Negative Assessment Keys"):
    if (ErrorLevel || macroName = "")
        return

    savePath := NB_MacroDir . "\" . NB_SanitizeFilename(macroName) . ".keymacro"
    FileDelete, %savePath%

    FormatTime, nowDisp,, yyyy-MM-dd HH:mm
    header := "; Nursing Booster Key Macro`n"
    header .= "; Name: " . macroName . "`n"
    header .= "; Created: " . nowDisp . "`n"
    header .= "; User: " . A_UserName . "`n"
    header .= "; Steps: " . NB_MacroSteps.Length() . "`n"
    header .= ";`n"
    header .= "; Format: KEY,COUNT,DELAY_MS`n"
    header .= "; Keys: Tab, Shift+Tab, Space, Down, Up, Left, Right, Enter, Escape, Home, End`n"
    header .= "; Edit this file in Notepad if you want to tweak it.`n"
    header .= ";`n"
    FileAppend, %header%, %savePath%, UTF-8

    for i, step in NB_MacroSteps {
        line := step.key . "," . step.count . "," . step.delay . "`n"
        FileAppend, %line%, %savePath%, UTF-8
    }

    stepCount := NB_MacroSteps.Length()
    ToolTip, Saved macro "%macroName%" with %stepCount% steps
    SetTimer, NB_ClearToolTip, -3000
return


NB_MacroLoad:
    global NB_MacroSteps, NB_MacroDir, NB_AppTitle

    ; List available macros
    macroFiles := []
    Loop, Files, %NB_MacroDir%\*.keymacro
    {
        macroFiles.Push(A_LoopFileName)
    }
    if (macroFiles.Length() = 0) {
        MsgBox, 64, %NB_AppTitle%, No saved key macros found.`n`nUse "Build Key Macro" to create one`nor place .keymacro files in:`n%NB_MacroDir%
        return
    }

    macroList := ""
    for k, f in macroFiles {
        name := StrReplace(f, ".keymacro", "")
        macroList .= (macroList != "" ? "|" : "") . name
    }

    Gui, 70:Destroy
    Gui, 70:+AlwaysOnTop +ToolWindow
    Gui, 70:Font, s9, Segoe UI
    Gui, 70:Add, Text,, Select a macro to load:
    Gui, 70:Add, ListBox, w300 h180 vNB_MacroLoadSelection, %macroList%
    Gui, 70:Add, Button, y+5 w90 gNB_DoLoadMacro Default, Load
    Gui, 70:Add, Button, x+5 w90 gNB_DoDeleteMacro, Delete
    Gui, 70:Add, Button, x+5 w90 gNB_CancelLoadMacro, Cancel
    Gui, 70:Show,, Load Key Macro
return

NB_DoLoadMacro:
    Gui, 70:Submit
    global NB_MacroSteps, NB_MacroDir
    if (NB_MacroLoadSelection = "") {
        MsgBox, 48, %NB_AppTitle%, Select a macro.
        return
    }
    Gui, 70:Destroy

    loadPath := NB_MacroDir . "\" . NB_SanitizeFilename(NB_MacroLoadSelection) . ".keymacro"
    NB_MacroSteps := NB_ParseMacroFile(loadPath)
    NB_MacroRefreshList()

    stepCount := NB_MacroSteps.Length()
    ToolTip, Loaded "%NB_MacroLoadSelection%" - %stepCount% steps
    SetTimer, NB_ClearToolTip, -2000
return

NB_DoDeleteMacro:
    Gui, 70:Submit, NoHide
    global NB_MacroDir
    if (NB_MacroLoadSelection = "")
        return
    MsgBox, 36, %NB_AppTitle%, Delete macro "%NB_MacroLoadSelection%"?
    IfMsgBox, Yes
    {
        delPath := NB_MacroDir . "\" . NB_SanitizeFilename(NB_MacroLoadSelection) . ".keymacro"
        FileDelete, %delPath%
        Gui, 70:Destroy
        ToolTip, Macro deleted
        SetTimer, NB_ClearToolTip, -2000
    }
return

NB_CancelLoadMacro:
    Gui, 70:Destroy
return


NB_ParseMacroFile(filePath) {
    steps := []
    FileRead, content, %filePath%
    if (ErrorLevel)
        return steps

    Loop, Parse, content, `n, `r
    {
        line := Trim(A_LoopField)
        if (line = "" || SubStr(line, 1, 1) = ";")
            continue

        ; Parse KEY,COUNT,DELAY
        parts := StrSplit(line, ",")
        if (parts.Length() < 2)
            continue

        keyName := Trim(parts[1])
        stepCount := Trim(parts[2]) + 0
        stepDelay := parts.Length() >= 3 ? Trim(parts[3]) + 0 : 150

        if (stepCount < 1)
            stepCount := 1
        if (stepDelay < 0)
            stepDelay := 150

        ; Validate key name
        validKeys := "Tab,Shift+Tab,Space,Down,Up,Left,Right,Enter,Escape,Home,End"
        if (!InStr(validKeys, keyName))
            continue

        steps.Push({key: keyName, count: stepCount, delay: stepDelay})
    }
    return steps
}


;============================================================================================
; KEY MACRO - PLAYBACK
;============================================================================================

NB_MacroTestPlay:
    ; Play into whatever window is active (for testing outside CPRS)
    global NB_MacroSteps, NB_AppTitle
    if (NB_MacroSteps.Length() = 0) {
        MsgBox, 48, %NB_AppTitle%, No steps to play. Add some steps first.
        return
    }
    Gui, 69:Submit, NoHide
    nb_stepCount := NB_MacroSteps.Length()
    MsgBox, 49, %NB_AppTitle%, Test Play will send keystrokes to the ACTIVE window in 3 seconds.`n`nClick the target window after pressing OK.`n`nSteps: %nb_stepCount%`n`nPress Cancel to abort.
    IfMsgBox, Cancel
        return
    Sleep, 3000
    ; v5: Capture the active window so macro stops if it closes
    WinGet, nb_testTargetHwnd, ID, A
    NB_ExecuteMacro(NB_MacroSteps, 150, nb_testTargetHwnd)
return


NB_MacroPlayInCPRS:
    global NB_MacroSteps, NB_AppTitle
    if (NB_MacroSteps.Length() = 0) {
        MsgBox, 48, %NB_AppTitle%, No steps to play. Add or load steps first.
        return
    }

    ; Find and activate CPRS reminder dialog
    dlgHwnd := NB_FindActiveDialogWindow()
    if (!dlgHwnd) {
        MsgBox, 48, %NB_AppTitle%, Open a reminder dialogue in CPRS first.
        return
    }

    Gui, 69:Submit, NoHide
    stepCount := NB_MacroSteps.Length()
    MsgBox, 49, %NB_AppTitle%, Play %stepCount% steps into the CPRS dialog?`n`nThe dialog will be activated and keystrokes sent.`nYou can review the result before clicking Finish.`n`nPress Cancel to abort.
    IfMsgBox, Cancel
        return

    WinActivate, ahk_id %dlgHwnd%
    Sleep, 500
    NB_ExecuteMacro(NB_MacroSteps, 150, dlgHwnd)

    ToolTip, Key macro complete - review the dialog before submitting
    SetTimer, NB_ClearToolTip, -4000
return


NB_PlayMacroSelect:
    ; Quick play: pick a saved macro and play it directly into CPRS
    global NB_MacroDir, NB_AppTitle

    macroFiles := []
    Loop, Files, %NB_MacroDir%\*.keymacro
    {
        macroFiles.Push(A_LoopFileName)
    }
    if (macroFiles.Length() = 0) {
        MsgBox, 64, %NB_AppTitle%, No saved key macros found.`nUse "Build Key Macro" to create one.
        return
    }

    dlgHwnd := NB_FindActiveDialogWindow()
    if (!dlgHwnd) {
        MsgBox, 48, %NB_AppTitle%, Open a reminder dialogue in CPRS first.
        return
    }

    macroList := ""
    for k, f in macroFiles {
        name := StrReplace(f, ".keymacro", "")
        macroList .= (macroList != "" ? "|" : "") . name
    }

    Gui, 71:Destroy
    Gui, 71:+AlwaysOnTop +ToolWindow
    Gui, 71:Font, s9, Segoe UI
    Gui, 71:Add, Text,, Select a macro to play in CPRS:
    Gui, 71:Add, ListBox, w300 h180 vNB_PlayMacroSelection, %macroList%
    Gui, 71:Add, Button, y+5 w140 gNB_DoPlayMacro Default, Play in CPRS
    Gui, 71:Add, Button, x+5 w100 gNB_CancelPlayMacro, Cancel
    Gui, 71:Show,, Play Key Macro
return

NB_DoPlayMacro:
    Gui, 71:Submit
    global NB_MacroDir, NB_AppTitle
    if (NB_PlayMacroSelection = "") {
        MsgBox, 48, %NB_AppTitle%, Select a macro.
        return
    }
    Gui, 71:Destroy

    loadPath := NB_MacroDir . "\" . NB_SanitizeFilename(NB_PlayMacroSelection) . ".keymacro"
    playSteps := NB_ParseMacroFile(loadPath)

    if (playSteps.Length() = 0) {
        MsgBox, 48, %NB_AppTitle%, Macro has no valid steps.
        return
    }

    dlgHwnd := NB_FindActiveDialogWindow()
    if (!dlgHwnd) {
        MsgBox, 48, %NB_AppTitle%, CPRS dialog no longer found.
        return
    }

    stepCount := playSteps.Length()
    MsgBox, 49, %NB_AppTitle%, Play "%NB_PlayMacroSelection%" (%stepCount% steps) into CPRS?`n`nReview the result before clicking Finish.
    IfMsgBox, Cancel
        return

    WinActivate, ahk_id %dlgHwnd%
    Sleep, 500
    NB_ExecuteMacro(playSteps, 150, dlgHwnd)

    ; Log it
    NB_LogMacroPlay(NB_PlayMacroSelection, playSteps)

    ToolTip, Key macro "%NB_PlayMacroSelection%" complete - review before submitting
    SetTimer, NB_ClearToolTip, -4000
return

NB_CancelPlayMacro:
    Gui, 71:Destroy
return


;============================================================================================
; KEY MACRO - EXECUTION ENGINE
;============================================================================================

NB_ExecuteMacro(steps, globalDelay := 150, targetHwnd := 0) {
    global NB_AppTitle
    totalSteps := steps.Length()
    aborted := 0
    for i, step in steps {
        ; Check for Escape abort between steps (physical OR logical key state)
        if (GetKeyState("Escape", "P") || GetKeyState("Escape")) {
            aborted := 1
            break
        }

        ; v5 FIX: If the target window closed (e.g. user pressed Esc in CPRS
        ; and CPRS consumed it to close the dialog), abort immediately so we
        ; don't keep sending keystrokes to whatever window is now active.
        if (targetHwnd && !DllCall("IsWindow", "Ptr", targetHwnd)) {
            aborted := 1
            break
        }

        keyName := step.key
        stepCount := step.count
        stepDelay := step.delay > 0 ? step.delay : globalDelay

        ; Map key names to AHK send syntax
        if (keyName = "Tab")
            sendKey := "{Tab}"
        else if (keyName = "Shift+Tab")
            sendKey := "+{Tab}"
        else if (keyName = "Space")
            sendKey := "{Space}"
        else if (keyName = "Down")
            sendKey := "{Down}"
        else if (keyName = "Up")
            sendKey := "{Up}"
        else if (keyName = "Left")
            sendKey := "{Left}"
        else if (keyName = "Right")
            sendKey := "{Right}"
        else if (keyName = "Enter")
            sendKey := "{Enter}"
        else if (keyName = "Escape")
            sendKey := "{Escape}"
        else if (keyName = "Home")
            sendKey := "{Home}"
        else if (keyName = "End")
            sendKey := "{End}"
        else
            continue

        ToolTip, Playing step %i%/%totalSteps%: %keyName% x%stepCount%  |  Esc to abort

        ; Send the key the specified number of times
        Loop, %stepCount%
        {
            if (GetKeyState("Escape", "P") || GetKeyState("Escape")) {
                aborted := 1
                break
            }
            ; v5 FIX: Also check target window inside the count loop
            if (targetHwnd && !DllCall("IsWindow", "Ptr", targetHwnd)) {
                aborted := 1
                break
            }
            Send, %sendKey%
            Sleep, %stepDelay%
        }
        if (aborted)
            break
    }
    ToolTip
    if (aborted) {
        ToolTip, Playback aborted at step %i%/%totalSteps%
        SetTimer, NB_ClearToolTip, -3000
    }
}


;============================================================================================
; KEY MACRO - LOGGING
;============================================================================================

NB_LogMacroPlay(macroName, steps) {
    global NB_LogDir
    FormatTime, nowStamp,, yyyyMMddHHmmss
    FormatTime, nowDisp,, yyyy-MM-dd HH:mm:ss
    logPath := NB_LogDir . "\KEYMACRO_" . nowStamp . ".txt"

    stepCount := steps.Length()
    logText := "============================================================`n"
    logText .= "  NURSING BOOSTER KEY MACRO PLAY LOG`n"
    logText .= "============================================================`n"
    logText .= "Timestamp: " . nowDisp . "`n"
    logText .= "Macro:     " . macroName . "`n"
    logText .= "User:      " . A_UserName . "`n"
    logText .= "Steps:     " . stepCount . "`n"
    logText .= "============================================================`n`n"
    FileAppend, %logText%, %logPath%, UTF-8

    totalKeys := 0
    for i, step in steps {
        line := "Step " . i . ": " . step.key . " x" . step.count . " (delay " . step.delay . "ms)`n"
        FileAppend, %line%, %logPath%, UTF-8
        totalKeys += step.count
    }

    footer := "`nTotal keystrokes sent: " . totalKeys . "`n"
    FileAppend, %footer%, %logPath%, UTF-8
}


;############################################################################################
;############################################################################################
;###                                                                                      ###
;###              KEY MACRO RECORDER - Navigation key capture                              ###
;###                                                                                      ###
;###  Records ONLY: Tab, Space, Down, Up, Left, Right, Enter, Escape, Home, End           ###
;###  Does NOT capture letters, numbers, passwords, or any typed text.                    ###
;###  User-initiated, visually obvious, auto-timeout.                                     ###
;###                                                                                      ###
;############################################################################################
;############################################################################################


;============================================================================================
; RECORDING - START / STOP
;============================================================================================

NB_StartRecording:
    global NB_Recording, NB_RecordedSteps, NB_RecordLastKey, NB_RecordLastTime, NB_AppTitle

    if (NB_Recording) {
        ; Already recording - stop instead
        gosub NB_StopRecording
        return
    }

    MsgBox, 49, %NB_AppTitle% - Record Macro, MACRO RECORDER`n`nThis will capture ONLY navigation keys:`nTab  Shift+Tab  Space  Arrow keys  Enter  Home  End`n`nNO letters, numbers, passwords, or typed text are captured.`n`nClick OK, then navigate the CPRS dialog normally.`nPress Escape, Ctrl+Shift+R, or click Stop to finish recording.
    IfMsgBox, Cancel
        return

    NB_RecordedSteps := []
    NB_RecordLastKey := ""
    NB_RecordLastTime := 0
    NB_Recording := 1

    ; Show the recording banner (Gui 72)
    Gui, 72:Destroy
    Gui, 72:Color, CC0000
    Gui, 72:Font, s14 cWhite Bold, Segoe UI
    Gui, 72:Add, Text, x10 y8 w330 h30 Center BackgroundTrans, RECORDING  -  Nav Keys Only
    Gui, 72:Font, s9 cWhite, Segoe UI
    Gui, 72:Add, Text, x10 y40 w330 h18 Center BackgroundTrans vNB_RecStatus, Steps: 0  |  Press Escape or Ctrl+Shift+R to stop
    Gui, 72:Add, Button, x115 y62 w120 h26 gNB_StopRecording cBlack, Stop Recording
    Gui, 72:+AlwaysOnTop -Caption +ToolWindow +Border
    Gui, 72:Show, x200 y0 w350 h94 NoActivate, NB_RecordingBanner

    ; Register passthrough hotkeys for navigation keys only
    ; ~ prefix means the key still goes through to the active app
    Hotkey, ~Tab, NB_RecKey_Tab, On
    Hotkey, ~+Tab, NB_RecKey_ShiftTab, On
    Hotkey, ~Space, NB_RecKey_Space, On
    Hotkey, ~Down, NB_RecKey_Down, On
    Hotkey, ~Up, NB_RecKey_Up, On
    Hotkey, ~Left, NB_RecKey_Left, On
    Hotkey, ~Right, NB_RecKey_Right, On
    Hotkey, ~Enter, NB_RecKey_Enter, On
    Hotkey, ~Home, NB_RecKey_Home, On
    Hotkey, ~End, NB_RecKey_End, On
    ; Escape stops recording (not captured as a step)
    Hotkey, Escape, NB_StopRecording, On

    ; Auto-timeout: stop recording after 120 seconds of no activity
    SetTimer, NB_RecordTimeout, 120000

    ToolTip, Recording started - navigate the dialog normally
    SetTimer, NB_ClearToolTip, -2000
return


NB_StopRecording:
    global NB_Recording, NB_RecordedSteps, NB_AppTitle

    if (!NB_Recording)
        return

    NB_Recording := 0

    ; Unregister the hotkeys
    Hotkey, ~Tab, NB_RecKey_Tab, Off
    Hotkey, ~+Tab, NB_RecKey_ShiftTab, Off
    Hotkey, ~Space, NB_RecKey_Space, Off
    Hotkey, ~Down, NB_RecKey_Down, Off
    Hotkey, ~Up, NB_RecKey_Up, Off
    Hotkey, ~Left, NB_RecKey_Left, Off
    Hotkey, ~Right, NB_RecKey_Right, Off
    Hotkey, ~Enter, NB_RecKey_Enter, Off
    Hotkey, ~Home, NB_RecKey_Home, Off
    Hotkey, ~End, NB_RecKey_End, Off
    Hotkey, Escape, NB_StopRecording, Off

    SetTimer, NB_RecordTimeout, Off

    ; Hide the recording banner
    Gui, 72:Destroy

    stepCount := NB_RecordedSteps.Length()
    if (stepCount = 0) {
        MsgBox, 64, %NB_AppTitle%, No navigation keys were captured.
        return
    }

    ; Consolidate consecutive same-key presses into single steps with count > 1
    consolidated := NB_ConsolidateSteps(NB_RecordedSteps)
    conCount := consolidated.Length()

    MsgBox, 35, %NB_AppTitle%, Recording complete: %stepCount% key presses consolidated to %conCount% steps.`n`nYes = Load into Macro Builder (edit before saving)`nNo = Save directly as a macro file`nCancel = Discard
    IfMsgBox, Yes
    {
        ; Load into the builder  set flag so builder doesn't reset steps
        global NB_MacroSteps, NB_MacroKeepSteps
        NB_MacroSteps := consolidated
        NB_MacroKeepSteps := 1
        gosub NB_OpenMacroBuilder
        NB_MacroRefreshList()
        return
    }
    IfMsgBox, No
    {
        ; Save directly
        global NB_MacroDir
        InputBox, macroName, Save Recorded Macro, Name for this macro:
        if (ErrorLevel || macroName = "")
            return

        savePath := NB_MacroDir . "\" . NB_SanitizeFilename(macroName) . ".keymacro"
        FileDelete, %savePath%

        FormatTime, nowDisp,, yyyy-MM-dd HH:mm
        header := "; Nursing Booster Key Macro (RECORDED)`n"
        header .= "; Name: " . macroName . "`n"
        header .= "; Created: " . nowDisp . "`n"
        header .= "; User: " . A_UserName . "`n"
        header .= "; Raw presses: " . stepCount . "  |  Consolidated steps: " . conCount . "`n"
        header .= ";`n"
        header .= "; Format: KEY,COUNT,DELAY_MS`n"
        header .= "; You can edit this file in Notepad to tweak it.`n"
        header .= ";`n"
        FileAppend, %header%, %savePath%, UTF-8

        for i, step in consolidated {
            line := step.key . "," . step.count . "," . step.delay . "`n"
            FileAppend, %line%, %savePath%, UTF-8
        }
        conStepCount := consolidated.Length()
        ToolTip, Saved "%macroName%" with %conStepCount% steps
        SetTimer, NB_ClearToolTip, -3000
        return
    }
    IfMsgBox, Cancel
    {
        ToolTip, Recording discarded
        SetTimer, NB_ClearToolTip, -2000
        return
    }
return


NB_RecordTimeout:
    ; Auto-stop after timeout period with no keys
    SetTimer, NB_RecordTimeout, Off
    if (NB_Recording) {
        ToolTip, Recording auto-stopped (timeout)
        SetTimer, NB_ClearToolTip, -3000
        gosub NB_StopRecording
    }
return


;============================================================================================
; RECORDING - KEY CAPTURE HANDLERS
; Each handler appends the key to the recorded steps and resets the timeout.
; The ~ prefix on the hotkey means the key passes through normally.
;============================================================================================

NB_RecKey_Tab:
    NB_RecordKeyPress("Tab")
return

NB_RecKey_ShiftTab:
    NB_RecordKeyPress("Shift+Tab")
return

NB_RecKey_Space:
    NB_RecordKeyPress("Space")
return

NB_RecKey_Down:
    NB_RecordKeyPress("Down")
return

NB_RecKey_Up:
    NB_RecordKeyPress("Up")
return

NB_RecKey_Left:
    NB_RecordKeyPress("Left")
return

NB_RecKey_Right:
    NB_RecordKeyPress("Right")
return

NB_RecKey_Enter:
    NB_RecordKeyPress("Enter")
return

NB_RecKey_Home:
    NB_RecordKeyPress("Home")
return

NB_RecKey_End:
    NB_RecordKeyPress("End")
return


NB_RecordKeyPress(keyName) {
    global NB_Recording, NB_RecordedSteps, NB_RecordLastKey, NB_RecordLastTime

    if (!NB_Recording)
        return

    ; Record the key with timestamp for delay calculation
    now := A_TickCount
    if (NB_RecordLastTime > 0)
        elapsed := now - NB_RecordLastTime
    else
        elapsed := 150  ; default for first key

    ; Cap delay at 5 seconds (anything longer is probably a pause, not intentional)
    if (elapsed > 5000)
        elapsed := 500

    NB_RecordedSteps.Push({key: keyName, delay: elapsed})
    NB_RecordLastKey := keyName
    NB_RecordLastTime := now

    ; Update the recording banner
    stepCount := NB_RecordedSteps.Length()
    GuiControl, 72:, NB_RecStatus, Steps: %stepCount%  |  Last: %keyName%  |  Esc to stop

    ; Reset the auto-timeout
    SetTimer, NB_RecordTimeout, 120000
}


;============================================================================================
; RECORDING - CONSOLIDATE CONSECUTIVE SAME-KEY PRESSES
; e.g. Tab,Tab,Tab -> Tab x3
;============================================================================================

NB_ConsolidateSteps(rawSteps) {
    consolidated := []
    if (rawSteps.Length() = 0)
        return consolidated

    currentKey := rawSteps[1].key
    currentCount := 1
    ; Use the average delay for consolidated steps
    totalDelay := rawSteps[1].delay
    delayCount := 1

    i := 2
    while (i <= rawSteps.Length()) {
        step := rawSteps[i]
        if (step.key = currentKey) {
            currentCount++
            totalDelay += step.delay
            delayCount++
        } else {
            avgDelay := Round(totalDelay / delayCount)
            if (avgDelay < 50)
                avgDelay := 50
            consolidated.Push({key: currentKey, count: currentCount, delay: avgDelay})
            currentKey := step.key
            currentCount := 1
            totalDelay := step.delay
            delayCount := 1
        }
        i++
    }
    ; Push the last group
    avgDelay := Round(totalDelay / delayCount)
    if (avgDelay < 50)
        avgDelay := 50
    consolidated.Push({key: currentKey, count: currentCount, delay: avgDelay})

    return consolidated
}


;============================================================================================
; RECORDING - HOTKEY TO STOP (Ctrl+Shift+R)
;============================================================================================

^+r::
    if (NB_Recording) {
        gosub NB_StopRecording
    }
return


;############################################################################################
;################### END NURSING BOOSTER ####################################################
;############################################################################################
;############################################################################################
;############################################################################################
;################### CP FLOWSHEETS BOOSTER ###################################################
;############################################################################################
;############################################################################################
;
; Automates the "Add Data" screen in CP Flowsheets (CPFlowsheets.exe).
; Supports checkboxes, radio buttons, and dropdowns (ComboBoxes).
; Text fields are excluded for now.
;
; Uses generic Win32 style-bit detection so it works regardless of whether
; CP Flowsheets is built with Delphi, .NET WinForms, or MFC.
;
; SAFETY: Never clicks Submit/Save/File/Sign buttons.
; The user always reviews and submits manually.
;
; PREFIX: CF_ for all functions, variables, and labels.
;############################################################################################


;============================================================================================
; CF - WINDOW DETECTION
;============================================================================================

CF_FindCPFlowsheetsWindow() {
    ; Find the main CP Flowsheets window
    SetTitleMatchMode, 2
    hwnd := WinExist("ahk_exe CPFlowsheets.exe")
    if (hwnd)
        return hwnd
    return 0
}

CF_FindAddDataWindow() {
    ; Strategy 1: Look for a window with "Add Data" in its title
    SetTitleMatchMode, 2
    hwnd := WinExist("Add Data ahk_exe CPFlowsheets.exe")
    if (hwnd)
        return hwnd

    ; Strategy 2: Look for any CP Flowsheets window that has form controls
    ; (checkboxes, radios, or combos)
    mainHwnd := CF_FindCPFlowsheetsWindow()
    if (!mainHwnd)
        return 0

    ; Check the main window itself
    if (CF_HasFormControls(mainHwnd))
        return mainHwnd

    ; Check child/owned windows
    WinGet, wndList, List, ahk_exe CPFlowsheets.exe
    Loop, %wndList%
    {
        wnd := wndList%A_Index%
        if (CF_HasFormControls(wnd))
            return wnd
    }
    return 0
}

CF_HasFormControls(windowHwnd) {
    global CF__hasFormControls
    CF__hasFormControls := false
    enumCB := RegisterCallback("CF__CheckForFormControls", "Fast")
    DllCall("EnumChildWindows", "Ptr", windowHwnd, "Ptr", enumCB, "Ptr", 0)
    return CF__hasFormControls
}

CF__CheckForFormControls(hwnd, lParam) {
    global CF__hasFormControls
    VarSetCapacity(buf, 512, 0)
    DllCall("GetClassName", "Ptr", hwnd, "Str", buf, "Int", 256)
    className := buf

    ; Get window style
    style := DllCall("GetWindowLong", "Ptr", hwnd, "Int", -16, "UInt")
    buttonStyle := style & 0x0F

    ; Check for checkbox styles (BS_CHECKBOX=0x02, BS_AUTOCHECKBOX=0x03)
    if (buttonStyle = 0x02 || buttonStyle = 0x03) {
        CF__hasFormControls := true
        return 0
    }
    ; Check for radio button styles (BS_RADIOBUTTON=0x04, BS_AUTORADIOBUTTON=0x09)
    if (buttonStyle = 0x04 || buttonStyle = 0x09) {
        CF__hasFormControls := true
        return 0
    }
    ; Check for Delphi-specific class names
    if (InStr(className, "TCheckBox") || InStr(className, "TRadioButton")
        || InStr(className, "TComboBox") || className = "ComboBox"
        || InStr(className, "TCheckListBox")) {
        CF__hasFormControls := true
        return 0
    }
    ; Check for .NET WinForms class names
    if (InStr(className, "WindowsForms") && (InStr(className, "CheckBox")
        || InStr(className, "RadioButton") || InStr(className, "ComboBox"))) {
        CF__hasFormControls := true
        return 0
    }
    return 1
}


;============================================================================================
; CF - CONTROL TYPE CLASSIFICATION
;
; Uses Win32 style bits to classify controls. This works for Delphi, .NET, MFC, etc.
; BS_CHECKBOX      = 0x02
; BS_AUTOCHECKBOX  = 0x03
; BS_RADIOBUTTON   = 0x04
; BS_AUTORADIOBUTTON = 0x09
; BS_GROUPBOX      = 0x07
;============================================================================================

CF_ClassifyControl(hwnd) {
    ; Returns: "checkbox", "radio", "combo", "groupbox", "label", or ""
    VarSetCapacity(buf, 512, 0)
    DllCall("GetClassName", "Ptr", hwnd, "Str", buf, "Int", 256)
    className := buf

    ; ComboBox detection (class name based)
    if (className = "ComboBox" || InStr(className, "TComboBox")
        || (InStr(className, "WindowsForms") && InStr(className, "ComboBox"))) {
        return "combo"
    }

    ; Delphi TCheckListBox  a listbox with per-item checkboxes
    if (InStr(className, "TCheckListBox"))
        return "checklist"

    ; Delphi-specific class name detection
    if (InStr(className, "TCheckBox"))
        return "checkbox"
    if (InStr(className, "TRadioButton"))
        return "radio"

    ; .NET WinForms class name detection
    if (InStr(className, "WindowsForms") && InStr(className, "CheckBox"))
        return "checkbox"
    if (InStr(className, "WindowsForms") && InStr(className, "RadioButton"))
        return "radio"

    ; CPRS-specific classes (in case CP Flowsheets shares any)
    if (className = "TORCheckBox" || className = "TCPRSDialogCheckBox")
        return "checkbox"
    if (className = "TCPRSDialogParentCheckBox")
        return "checkbox"

    ; Generic Win32 Button style classification
    style := DllCall("GetWindowLong", "Ptr", hwnd, "Int", -16, "UInt")
    buttonStyle := style & 0x0F

    if (buttonStyle = 0x02 || buttonStyle = 0x03)  ; BS_CHECKBOX / BS_AUTOCHECKBOX
        return "checkbox"
    if (buttonStyle = 0x04 || buttonStyle = 0x09)  ; BS_RADIOBUTTON / BS_AUTORADIOBUTTON
        return "radio"
    if (buttonStyle = 0x07)  ; BS_GROUPBOX
        return "groupbox"

    ; Label detection
    if (className = "Static" || InStr(className, "TLabel") || InStr(className, "TStaticText"))
        return "label"

    return ""
}


;============================================================================================
; CF - SPY / DISCOVERY TOOL
;
; Dumps the full control hierarchy of the CP Flowsheets window.
; Run this once to discover what control classes the app uses.
;============================================================================================

CF_SpyDumpControls:
    global CF_TemplateDir, CF_AppTitle

    targetHwnd := CF_FindCPFlowsheetsWindow()
    if (!targetHwnd) {
        ; Fallback: try the active window (user might have it focused)
        targetHwnd := WinExist("A")
        if (!targetHwnd) {
            MsgBox, 48, %CF_AppTitle%, CP Flowsheets not detected. Open CP Flowsheets first.`n`nAlternatively focus the target window and try again.
            return
        }
    }

    ToolTip, Scanning CP Flowsheets controls...

    WinGetTitle, winTitle, ahk_id %targetHwnd%
    WinGetClass, winClass, ahk_id %targetHwnd%

    ; Enumerate all child controls
    global CF__spyFile, CF__spyTargetHwnd, CF__spyCount, CF__spyCBCount, CF__spyRadioCount, CF__spyComboCount

    FormatTime, nowStamp,, yyyyMMdd_HHmmss
    dumpPath := CF_TemplateDir . "\cpfs_spy_" . nowStamp . ".txt"

    CF__spyFile := FileOpen(dumpPath, "w", "UTF-8")
    CF__spyFile.Write("=== CP Flowsheets Control Dump ===`n")
    FormatTime, nowTime,, yyyy-MM-dd HH:mm:ss
    CF__spyFile.Write("Time: " . nowTime . "`n")
    CF__spyFile.Write("Window Title: " . winTitle . "`n")
    CF__spyFile.Write("Window Class: " . winClass . "`n")
    CF__spyFile.Write("Window HWND: " . targetHwnd . "`n`n")

    CF__spyTargetHwnd := targetHwnd
    CF__spyCount := 0
    CF__spyCBCount := 0
    CF__spyRadioCount := 0
    CF__spyComboCount := 0

    enumSpy := RegisterCallback("CF__SpyCallback", "Fast")
    DllCall("EnumChildWindows", "Ptr", targetHwnd, "Ptr", enumSpy, "Ptr", 0)

    CF__spyFile.Write("`n=== Summary ===`n")
    CF__spyFile.Write("Total controls: " . CF__spyCount . "`n")
    CF__spyFile.Write("Checkboxes: " . CF__spyCBCount . "`n")
    CF__spyFile.Write("Radio buttons: " . CF__spyRadioCount . "`n")
    CF__spyFile.Write("ComboBoxes: " . CF__spyComboCount . "`n")
    CF__spyFile.Close()

    ToolTip, Spy dump: %CF__spyCount% controls (%CF__spyCBCount% CB / %CF__spyRadioCount% Radio / %CF__spyComboCount% Combo)`nSaved to: %dumpPath%
    SetTimer, CF_ClearToolTip, -5000

    MsgBox, 64, %CF_AppTitle%, Control dump complete!`n`n%CF__spyCount% total controls found:`n- %CF__spyCBCount% checkboxes`n- %CF__spyRadioCount% radio buttons`n- %CF__spyComboCount% dropdowns`n`nSaved to:`n%dumpPath%
return

CF__SpyCallback(hwnd, lParam) {
    global CF__spyFile, CF__spyTargetHwnd, CF__spyCount, CF__spyCBCount, CF__spyRadioCount, CF__spyComboCount
    CF__spyCount++

    VarSetCapacity(buf, 512, 0)
    DllCall("GetClassName", "Ptr", hwnd, "Str", buf, "Int", 256)
    className := buf

    ; Get window text
    text := ""
    SendMessage, 0x000E, 0, 0,, ahk_id %hwnd%   ; WM_GETTEXTLENGTH
    tLen := ErrorLevel
    if (tLen > 0 && tLen < 1024) {
        VarSetCapacity(tBuf, (tLen + 1) * 2, 0)
        SendMessage, 0x000D, tLen + 1, &tBuf,, ahk_id %hwnd%   ; WM_GETTEXT
        text := StrGet(&tBuf)
    }

    ; Get style
    style := DllCall("GetWindowLong", "Ptr", hwnd, "Int", -16, "UInt")
    buttonStyle := style & 0x0F

    ; Depth calculation
    depth := 0
    p := hwnd
    Loop
    {
        p := DllCall("GetParent", "Ptr", p, "Ptr")
        if (!p || p = CF__spyTargetHwnd)
            break
        depth++
    }

    ; Get parent class
    parentHwnd := DllCall("GetParent", "Ptr", hwnd, "Ptr")
    VarSetCapacity(pBuf, 512, 0)
    if (parentHwnd)
        DllCall("GetClassName", "Ptr", parentHwnd, "Str", pBuf, "Int", 256)
    parentClass := parentHwnd ? pBuf : "none"

    ; Classify
    controlType := CF_ClassifyControl(hwnd)
    extra := ""
    if (controlType = "checkbox") {
        SendMessage, 0x00F0, 0, 0,, ahk_id %hwnd%   ; BM_GETCHECK
        checked := ErrorLevel
        extra := " [CHECKBOX] CHECKED=" . (checked ? "YES" : "NO")
        CF__spyCBCount++
    }
    else if (controlType = "radio") {
        SendMessage, 0x00F0, 0, 0,, ahk_id %hwnd%   ; BM_GETCHECK
        checked := ErrorLevel
        extra := " [RADIO] SELECTED=" . (checked ? "YES" : "NO")
        CF__spyRadioCount++
    }
    else if (controlType = "combo") {
        SendMessage, 0x0147, 0, 0,, ahk_id %hwnd%   ; CB_GETCURSEL
        selIdx := ErrorLevel
        extra := " [COMBOBOX] SELECTED_IDX=" . selIdx
        CF__spyComboCount++
    }
    else if (controlType = "checklist") {
        ; Enumerate items in the TCheckListBox
        SendMessage, 0x018B, 0, 0,, ahk_id %hwnd%   ; LB_GETCOUNT
        clItemCount := ErrorLevel
        extra := " [CHECKLISTBOX] ITEMS=" . clItemCount
        CF__spyCBCount += clItemCount
    }
    else if (controlType = "groupbox") {
        extra := " [GROUPBOX]"
    }

    ; Visibility
    visible := (style & 0x10000000) ? "Y" : "N"

    ; Build indent
    indent := ""
    Loop, %depth%
        indent .= "  "

    ; Get rect
    VarSetCapacity(rect, 16, 0)
    DllCall("GetWindowRect", "Ptr", hwnd, "Ptr", &rect)
    rx := NumGet(rect, 0, "Int")
    ry := NumGet(rect, 4, "Int")
    rw := NumGet(rect, 8, "Int") - rx
    rh := NumGet(rect, 12, "Int") - ry

    CF__spyFile.Write(indent . className . " hwnd=" . hwnd . " text='" . text . "' style=0x" . Format("{:08X}", style) . " vis=" . visible . " pos=" . rx . "," . ry . " size=" . rw . "x" . rh . " parent=" . parentClass . extra . "`n")
    return 1
}


;============================================================================================
; CF - ENUMERATE FORM CONTROLS (checkboxes, radios, combos)
;
; Returns an array of objects with:
;   .hwnd, .type ("checkbox"/"radio"/"combo"), .className, .label, .checked/.selected/.value
;   .y (screen Y for sorting/matching), .x, .parentHwnd, .parentLabel
;============================================================================================

CF_EnumFormControls(windowHwnd) {
    global CF__enumResults, CF__enumTargetHwnd, CF__checkListHwndStr
    CF__enumResults := []
    CF__enumTargetHwnd := windowHwnd

    ; Pass 1: Enumerate standard controls (checkboxes, radios, combos)
    enumCB := RegisterCallback("CF__EnumFormCallback", "Fast")
    DllCall("EnumChildWindows", "Ptr", windowHwnd, "Ptr", enumCB, "Ptr", 0)

    ; Pass 2: Find TCheckListBox controls (separate pass  no array methods in callbacks)
    CF__checkListHwndStr := ""
    enumCL := RegisterCallback("CF__FindCheckListCallback", "Fast")
    DllCall("EnumChildWindows", "Ptr", windowHwnd, "Ptr", enumCL, "Ptr", 0)

    ; Expand each TCheckListBox into individual items (safe  outside callbacks)
    if (CF__checkListHwndStr != "") {
        Loop, Parse, CF__checkListHwndStr, |
        {
            if (A_LoopField != "")
                CF_EnumCheckListBoxItems(A_LoopField + 0)
        }
    }

    ; Sort by Y position (insertion sort for stable ordering)
    results := CF__enumResults
    if (results.Length() > 1) {
        Loop, % results.Length() - 1
        {
            i := A_Index + 1
            key := results[i]
            j := i - 1
            while (j >= 1 && (results[j].y > key.y || (results[j].y = key.y && results[j].x > key.x))) {
                results[j + 1] := results[j]
                j--
            }
            results[j + 1] := key
        }
    }

    return results
}

CF__EnumFormCallback(hwnd, lParam) {
    global CF__enumResults, CF__enumTargetHwnd

    ; Skip invisible controls (WS_VISIBLE = 0x10000000)
    cfStyle := DllCall("GetWindowLong", "Ptr", hwnd, "Int", -16, "UInt")
    if !(cfStyle & 0x10000000)
        return 1

    controlType := CF_ClassifyControl(hwnd)
    if (controlType != "checkbox" && controlType != "radio" && controlType != "combo")
        return 1

    VarSetCapacity(buf, 512, 0)
    DllCall("GetClassName", "Ptr", hwnd, "Str", buf, "Int", 256)
    className := buf

    ; Get screen position
    VarSetCapacity(rect, 16, 0)
    DllCall("GetWindowRect", "Ptr", hwnd, "Ptr", &rect)
    y := NumGet(rect, 4, "Int")
    x := NumGet(rect, 0, "Int")

    ; Get label text
    label := ""
    SendMessage, 0x000E, 0, 0,, ahk_id %hwnd%   ; WM_GETTEXTLENGTH
    tLen := ErrorLevel
    if (tLen > 0 && tLen < 1024) {
        VarSetCapacity(tBuf, (tLen + 1) * 2, 0)
        SendMessage, 0x000D, tLen + 1, &tBuf,, ahk_id %hwnd%   ; WM_GETTEXT
        label := Trim(StrGet(&tBuf))
    }

    ; If label is empty or just a space, try to find adjacent label control
    if (label = "" || label = " ") {
        label := CF_FindAdjacentLabel(hwnd, CF__enumTargetHwnd)
    }

    ; Get parent for radio button grouping
    parentHwnd := DllCall("GetParent", "Ptr", hwnd, "Ptr")
    parentLabel := ""
    if (parentHwnd) {
        VarSetCapacity(pBuf, 512, 0)
        DllCall("GetClassName", "Ptr", parentHwnd, "Str", pBuf, "Int", 256)
        parentClass := pBuf
        ; If parent is a groupbox, get its text as group label
        if (InStr(parentClass, "GroupBox") || InStr(parentClass, "TGroupBox")
            || (DllCall("GetWindowLong", "Ptr", parentHwnd, "Int", -16, "UInt") & 0x0F) = 0x07) {
            SendMessage, 0x000E, 0, 0,, ahk_id %parentHwnd%
            pLen := ErrorLevel
            if (pLen > 0 && pLen < 256) {
                VarSetCapacity(plBuf, (pLen + 1) * 2, 0)
                SendMessage, 0x000D, pLen + 1, &plBuf,, ahk_id %parentHwnd%
                parentLabel := Trim(StrGet(&plBuf))
            }
        }
    }

    ; Get state
    checked := false
    selected := false
    value := ""
    valueIdx := -1

    if (controlType = "checkbox") {
        SendMessage, 0x00F0, 0, 0,, ahk_id %hwnd%   ; BM_GETCHECK
        checked := ErrorLevel ? true : false
    }
    else if (controlType = "radio") {
        SendMessage, 0x00F0, 0, 0,, ahk_id %hwnd%   ; BM_GETCHECK
        selected := ErrorLevel ? true : false
    }
    else if (controlType = "combo") {
        SendMessage, 0x0147, 0, 0,, ahk_id %hwnd%   ; CB_GETCURSEL
        valueIdx := ErrorLevel
        if (valueIdx != 0xFFFFFFFF && valueIdx >= 0) {
            ; Get the text of the selected item
            SendMessage, 0x0149, valueIdx, 0,, ahk_id %hwnd%  ; CB_GETLBTEXTLEN
            cbLen := ErrorLevel
            if (cbLen > 0 && cbLen < 1024) {
                VarSetCapacity(cbBuf, (cbLen + 2) * 2, 0)
                SendMessage, 0x0148, valueIdx, &cbBuf,, ahk_id %hwnd%  ; CB_GETLBTEXT
                value := StrGet(&cbBuf)
            }
        }
    }

    entry := {hwnd: hwnd, type: controlType, className: className, label: label
        , checked: checked, selected: selected, value: value, valueIdx: valueIdx
        , y: y, x: x, parentHwnd: parentHwnd, parentLabel: parentLabel}
    CF__enumResults.Push(entry)
    return 1
}


;============================================================================================
; CF - FIND CHECKLIST CALLBACK
;
; Second-pass callback that only looks for TCheckListBox controls.
; Uses string concatenation (not array methods) because Fast callbacks
; cannot safely call .Push() or other object methods.
;============================================================================================

CF__FindCheckListCallback(hwnd, lParam) {
    global CF__checkListHwndStr

    ; Skip invisible controls
    cfStyle := DllCall("GetWindowLong", "Ptr", hwnd, "Int", -16, "UInt")
    if !(cfStyle & 0x10000000)
        return 1

    ; Get class name
    VarSetCapacity(clBuf, 512, 0)
    DllCall("GetClassName", "Ptr", hwnd, "Str", clBuf, "Int", 256)
    clName := clBuf

    ; Only interested in TCheckListBox
    if (clName = "TCheckListBox") {
        CF__checkListHwndStr .= hwnd . "|"
    }

    return 1
}


;============================================================================================
; CF - FIND ADJACENT LABEL
;
; When a checkbox/radio has no text, look for a Static/TLabel sibling
; positioned immediately to its right on the same Y row.
;============================================================================================

CF_FindAdjacentLabel(controlHwnd, dialogHwnd) {
    global CF__adjLabel, CF__adjControlRect, CF__adjControlHwnd

    ; Get the control's rect
    VarSetCapacity(rect, 16, 0)
    DllCall("GetWindowRect", "Ptr", controlHwnd, "Ptr", &rect)
    CF__adjControlRect := {left: NumGet(rect, 0, "Int"), top: NumGet(rect, 4, "Int")
        , right: NumGet(rect, 8, "Int"), bottom: NumGet(rect, 12, "Int")}
    CF__adjControlHwnd := controlHwnd
    CF__adjLabel := ""

    parentHwnd := DllCall("GetParent", "Ptr", controlHwnd, "Ptr")
    if (!parentHwnd)
        parentHwnd := dialogHwnd

    enumAdj := RegisterCallback("CF__AdjLabelCallback", "Fast")
    DllCall("EnumChildWindows", "Ptr", parentHwnd, "Ptr", enumAdj, "Ptr", 0)
    return CF__adjLabel
}

CF__AdjLabelCallback(hwnd, lParam) {
    global CF__adjLabel, CF__adjControlRect, CF__adjControlHwnd

    if (hwnd = CF__adjControlHwnd)
        return 1

    VarSetCapacity(buf, 512, 0)
    DllCall("GetClassName", "Ptr", hwnd, "Str", buf, "Int", 256)
    className := buf

    ; Only look at label-type controls
    if !(className = "Static" || InStr(className, "TLabel") || InStr(className, "TStaticText")
        || InStr(className, "TVA508StaticText") || InStr(className, "TCPRSDialogStaticLabel"))
        return 1

    ; Check position: must be on the same row (within 10px Y) and to the right
    VarSetCapacity(rect, 16, 0)
    DllCall("GetWindowRect", "Ptr", hwnd, "Ptr", &rect)
    labelTop := NumGet(rect, 4, "Int")
    labelLeft := NumGet(rect, 0, "Int")

    yDiff := Abs(labelTop - CF__adjControlRect.top)
    if (yDiff > 10)
        return 1
    if (labelLeft < CF__adjControlRect.right)
        return 1

    ; Get text
    SendMessage, 0x000E, 0, 0,, ahk_id %hwnd%
    tLen := ErrorLevel
    if (tLen > 0 && tLen < 256) {
        VarSetCapacity(tBuf, (tLen + 1) * 2, 0)
        SendMessage, 0x000D, tLen + 1, &tBuf,, ahk_id %hwnd%
        text := Trim(StrGet(&tBuf))
        if (text != "" && text != " ") {
            CF__adjLabel := text
            return 0  ; Stop searching
        }
    }
    return 1
}


;============================================================================================
; CF - TCHECKLISTBOX SUPPORT
;
; Delphi TCheckListBox is a single listbox control that draws per-item checkboxes.
; Items are NOT child windows  they live inside the listbox.
; We use LB_ messages to enumerate items and ReadProcessMemory to read check state
; from Delphi's internal TCheckListBoxDataWrapper (FState at offset +4 from item data pointer).
;============================================================================================

CF_EnumCheckListBoxItems(listBoxHwnd) {
    global CF__enumResults

    ; Get item count
    SendMessage, 0x018B, 0, 0,, ahk_id %listBoxHwnd%   ; LB_GETCOUNT
    itemCount := ErrorLevel
    if (itemCount <= 0 || itemCount > 500)
        return

    ; Get screen position of the listbox itself
    VarSetCapacity(lbRect, 16, 0)
    DllCall("GetWindowRect", "Ptr", listBoxHwnd, "Ptr", &lbRect)
    lbY := NumGet(lbRect, 4, "Int")
    lbX := NumGet(lbRect, 0, "Int")

    ; Open the process for memory reading (needed for check state)
    WinGet, pid, PID, ahk_id %listBoxHwnd%
    hProc := DllCall("OpenProcess", "UInt", 0x0010, "Int", 0, "UInt", pid, "Ptr")  ; PROCESS_VM_READ

    Loop, %itemCount%
    {
        idx := A_Index - 1

        ; Get item text via LB_GETTEXT
        ; First get text length
        SendMessage, 0x018A, idx, 0,, ahk_id %listBoxHwnd%   ; LB_GETTEXTLEN
        tLen := ErrorLevel
        itemText := ""
        if (tLen > 0 && tLen < 1024) {
            VarSetCapacity(tBuf, (tLen + 2) * 2, 0)
            SendMessage, 0x0189, idx, &tBuf,, ahk_id %listBoxHwnd%   ; LB_GETTEXT
            itemText := StrGet(&tBuf)
        }

        ; Get item rect for Y position
        VarSetCapacity(itemRect, 16, 0)
        NumPut(idx, itemRect, 0, "Int")  ; LB_GETITEMRECT needs index in RECT
        SendMessage, 0x0198, idx, &itemRect,, ahk_id %listBoxHwnd%   ; LB_GETITEMRECT
        ; itemRect is in client coords  convert to screen
        VarSetCapacity(pt, 8, 0)
        NumPut(NumGet(itemRect, 0, "Int"), pt, 0, "Int")
        NumPut(NumGet(itemRect, 4, "Int"), pt, 4, "Int")
        DllCall("ClientToScreen", "Ptr", listBoxHwnd, "Ptr", &pt)
        itemY := NumGet(pt, 4, "Int")

        ; Read check state from Delphi internals via LB_GETITEMDATA + ReadProcessMemory
        ; TCheckListBoxDataWrapper layout (32-bit Delphi):
        ;   Offset 0: VMT pointer (4 bytes)
        ;   Offset 4: FData (LongInt, 4 bytes)
        ;   Offset 8: FState (TCheckBoxState: 0=unchecked, 1=checked, 2=grayed)
        itemChecked := false
        SendMessage, 0x0199, idx, 0,, ahk_id %listBoxHwnd%   ; LB_GETITEMDATA
        dataPtr := ErrorLevel
        if (hProc && dataPtr && dataPtr != 0xFFFFFFFF && dataPtr != -1) {
            VarSetCapacity(stateVal, 4, 0)
            bytesRead := 0
            DllCall("ReadProcessMemory", "Ptr", hProc, "Ptr", dataPtr + 8
                , "Ptr", &stateVal, "UInt", 4, "Ptr*", bytesRead)
            if (bytesRead > 0) {
                state := NumGet(stateVal, 0, "Int")
                itemChecked := (state = 1) ? true : false  ; cbChecked=1
            }
        }

        entry := {hwnd: listBoxHwnd, type: "checklist", className: "TCheckListBox"
            , label: itemText, checked: itemChecked, selected: false, value: ""
            , valueIdx: -1, y: itemY, x: lbX, parentHwnd: 0, parentLabel: ""
            , checklistIdx: idx}
        CF__enumResults.Push(entry)
    }

    if (hProc)
        DllCall("CloseHandle", "Ptr", hProc)
}

CF_ReadCheckListItemState(listBoxHwnd, itemIdx) {
    ; Read the check state of a single TCheckListBox item
    ; Returns true if checked, false otherwise
    WinGet, pid, PID, ahk_id %listBoxHwnd%
    hProc := DllCall("OpenProcess", "UInt", 0x0010, "Int", 0, "UInt", pid, "Ptr")
    if (!hProc)
        return false

    SendMessage, 0x0199, itemIdx, 0,, ahk_id %listBoxHwnd%   ; LB_GETITEMDATA
    dataPtr := ErrorLevel
    result := false
    if (dataPtr && dataPtr != 0xFFFFFFFF && dataPtr != -1) {
        ; FState is at offset +8: past VMT pointer (4) and FData (4)
        VarSetCapacity(stateVal, 4, 0)
        bytesRead := 0
        DllCall("ReadProcessMemory", "Ptr", hProc, "Ptr", dataPtr + 8
            , "Ptr", &stateVal, "UInt", 4, "Ptr*", bytesRead)
        if (bytesRead > 0) {
            state := NumGet(stateVal, 0, "Int")
            result := (state = 1) ? true : false
        }
    }
    DllCall("CloseHandle", "Ptr", hProc)
    return result
}


;============================================================================================
; CF - SAVE TEMPLATE
;============================================================================================

CF_BtnSaveTemplate:
    global CF_TemplateDir, CF_AppTitle

    targetHwnd := CF_FindAddDataWindow()
    if (!targetHwnd) {
        targetHwnd := CF_FindCPFlowsheetsWindow()
    }
    if (!targetHwnd) {
        MsgBox, 48, %CF_AppTitle%, CP Flowsheets not detected.`nOpen CP Flowsheets and navigate to the Add Data screen first.
        return
    }

    InputBox, cfTemplateName, %CF_AppTitle% - Save Template, Template name:`n`nUse a descriptive name like 'ICU Default' or 'Vitals Baseline'.
    if (ErrorLevel || cfTemplateName = "")
        return

    ToolTip, Scanning CP Flowsheets controls...

    controls := CF_EnumFormControls(targetHwnd)
    if (controls.Length() = 0) {
        MsgBox, 48, %CF_AppTitle%, No checkboxes, radio buttons, or dropdowns found in this window.`n`nTry running CPFS Spy to see what controls are available.
        return
    }

    ; Build JSON
    WinGetTitle, cfWinTitle, ahk_id %targetHwnd%
    FormatTime, cfNowTime,, yyyy-MM-dd HH:mm
    json := "{"
    json .= "`n  ""name"": " . CF_EscJson(cfTemplateName) . ","
    json .= "`n  ""format"": 1,"
    json .= "`n  ""app"": ""CPFlowsheets"","
    json .= "`n  ""created"": """ . cfNowTime . ""","
    json .= "`n  ""window_title"": " . CF_EscJson(cfWinTitle) . ","
    json .= "`n  ""controls"": ["

    cbCount := 0
    radioCount := 0
    comboCount := 0

    for ci, ctrl in controls {
        if (ci > 1)
            json .= ","

        json .= "`n    {""type"": """ . ctrl.type . """"
        json .= ", ""label"": " . CF_EscJson(ctrl.label)
        json .= ", ""cls"": " . CF_EscJson(ctrl.className)
        json .= ", ""idx"": " . (ci - 1)
        json .= ", ""y"": " . ctrl.y

        if (ctrl.type = "checkbox" || ctrl.type = "checklist") {
            json .= ", ""checked"": " . (ctrl.checked ? "true" : "false")
            if (ctrl.type = "checklist")
                json .= ", ""checklistIdx"": " . ctrl.checklistIdx
            cbCount++
        }
        else if (ctrl.type = "radio") {
            json .= ", ""selected"": " . (ctrl.selected ? "true" : "false")
            if (ctrl.parentLabel != "")
                json .= ", ""group_label"": " . CF_EscJson(ctrl.parentLabel)
            radioCount++
        }
        else if (ctrl.type = "combo") {
            json .= ", ""value"": " . CF_EscJson(ctrl.value)
            json .= ", ""valueIdx"": " . ctrl.valueIdx
            comboCount++
        }

        json .= "}"
    }

    json .= "`n  ]"
    json .= "`n}"

    filePath := CF_TemplateDir . "\" . CF_SanitizeFilename(cfTemplateName) . ".json"
    f := FileOpen(filePath, "w", "UTF-8")
    f.Write(json)
    f.Close()

    totalControls := controls.Length()
    ToolTip, Saved "%cfTemplateName%": %totalControls% controls (%cbCount% CB / %radioCount% Radio / %comboCount% Combo)
    SetTimer, CF_ClearToolTip, -3000
return


;============================================================================================
; CF - LOAD / APPLY TEMPLATE
;============================================================================================

CF_BtnLoadTemplate:
    global CF_TemplateDir, CF_AppTitle

    targetHwnd := CF_FindAddDataWindow()
    if (!targetHwnd)
        targetHwnd := CF_FindCPFlowsheetsWindow()
    if (!targetHwnd) {
        MsgBox, 48, %CF_AppTitle%, CP Flowsheets not detected.`nOpen CP Flowsheets first.
        return
    }

    ; Build template list
    cfLoadList := ""
    cfLoadPaths := []
    Loop, Files, %CF_TemplateDir%\*.json
    {
        SplitPath, A_LoopFileFullPath,,,,nameNoExt
        cfLoadList .= nameNoExt . "|"
        cfLoadPaths.Push(A_LoopFileFullPath)
    }

    if (cfLoadPaths.Length() = 0) {
        MsgBox, 64, %CF_AppTitle%, No saved CP Flowsheets templates found.`n`nTo create one:`n1. Open the Add Data screen in CP Flowsheets`n2. Set up your checkboxes, radios, and dropdowns`n3. Click 'CPFS Save'
        return
    }

    ; Show picker GUI (using Gui 69 to avoid conflicts)
    Gui, 69:Destroy
    Gui, 69:+AlwaysOnTop
    Gui, 69:Font, s9, Segoe UI
    Gui, 69:Add, Text,, Select a CP Flowsheets template to apply:
    Gui, 69:Add, ListBox, w300 h200 vCF_LoadSelection, %cfLoadList%
    Gui, 69:Add, Button, y+5 w120 Default gCF_DoLoadTemplate, Apply
    Gui, 69:Add, Button, x+5 w120 gCF_CancelLoad, Cancel
    Gui, 69:Show,, %CF_AppTitle% - Load Template
return

CF_DoLoadTemplate:
    Gui, 69:Submit
    Gui, 69:Destroy
    if (CF_LoadSelection = "") {
        MsgBox, 48, %CF_AppTitle%, Select a template first.
        return
    }
    templatePath := CF_TemplateDir . "\" . CF_SanitizeFilename(CF_LoadSelection) . ".json"
    if (FileExist(templatePath)) {
        CF_ApplyTemplate(templatePath)
    }
return

CF_CancelLoad:
    Gui, 69:Destroy
return

CF_ApplyTemplate(templatePath) {
    global CF_AppTitle

    targetHwnd := CF_FindAddDataWindow()
    if (!targetHwnd)
        targetHwnd := CF_FindCPFlowsheetsWindow()
    if (!targetHwnd) {
        MsgBox, 48, %CF_AppTitle%, CP Flowsheets window not found.
        return
    }

    FileRead, content, %templatePath%
    if (ErrorLevel) {
        MsgBox, 48, %CF_AppTitle%, Failed to read template: %templatePath%
        return
    }

    ; Parse controls from JSON
    templateControls := CF_ParseControls(content)
    if (templateControls.Length() = 0) {
        MsgBox, 48, %CF_AppTitle%, Template has no controls.
        return
    }

    ToolTip, Scanning live controls...
    WinActivate, ahk_id %targetHwnd%
    Sleep, 300

    liveControls := CF_EnumFormControls(targetHwnd)
    if (liveControls.Length() = 0) {
        MsgBox, 48, %CF_AppTitle%, No controls found in the current window.
        return
    }

    ; Match template controls to live controls by label + Y-position
    ; Use "claimed" tracking so duplicate labels (Yes/No) match by position order
    totalApplied := 0
    totalNotFound := 0
    cfClaimed := {}  ; track which live indices are already matched
    cfAutoSaveCancelled := false

    cfTotalTpl := templateControls.Length()
    for ti, tplCtrl in templateControls {
        ; Check Esc to cancel auto-save throughout the apply process
        if (CF_AutoSave && GetKeyState("Escape", "P")) {
            cfAutoSaveCancelled := true
            ToolTip, AutoSave cancelled - still applying template
            SetTimer, CF_ClearToolTip, -2000
        }
        ; Extract all template control properties to plain variables (AHK v1 safe)
        cfTplType := tplCtrl.type
        cfTplLabel := tplCtrl.label
        cfTplChecked := tplCtrl.checked
        cfTplSelected := tplCtrl.selected
        cfTplValue := tplCtrl.value
        cfTplValueIdx := tplCtrl.valueIdx
        cfTplY := tplCtrl.y
        cfTplGroupLabel := tplCtrl.group_label

        ToolTip, Applying control %ti%/%cfTotalTpl%: %cfTplLabel%

        ; Find best matching live control (that hasn't been claimed yet)
        bestLiveIdx := 0
        bestScore := 0
        bestYDist := 999999

        for li, liveCtrl in liveControls {
            ; Skip already-claimed controls
            if (cfClaimed[li])
                continue

            ; Extract live control properties to plain variables
            cfLiveType := liveCtrl.type
            cfLiveLabel := liveCtrl.label
            cfLiveY := liveCtrl.y
            cfLiveParentLabel := liveCtrl.parentLabel

            ; Must be same type (checklist matches checklist)
            if (cfLiveType != cfTplType)
                continue

            score := 0

            ; Label match (highest priority)
            if (cfTplLabel != "" && cfLiveLabel = cfTplLabel) {
                score := 100
            }
            else if (cfTplLabel != "" && cfLiveLabel != "" && InStr(cfLiveLabel, cfTplLabel)) {
                score := 70
            }
            else if (cfTplLabel != "" && cfLiveLabel != "" && InStr(cfTplLabel, cfLiveLabel)) {
                score := 60
            }

            ; Y-position proximity bonus (if labels don't match, use position)
            if (score = 0 && cfTplLabel = "" && cfLiveLabel = "") {
                yDiff := Abs(cfLiveY - cfTplY)
                if (yDiff < 20)
                    score := 50
                else if (yDiff < 50)
                    score := 30
            }

            ; For radios, also check group label
            if (cfTplType = "radio" && cfTplGroupLabel != "" && cfLiveParentLabel = cfTplGroupLabel) {
                score += 20
            }

            ; When scores tie, prefer the one closest in Y position
            yDist := Abs(cfLiveY - cfTplY)
            if (score > bestScore || (score = bestScore && score > 0 && yDist < bestYDist)) {
                bestScore := score
                bestLiveIdx := li
                bestYDist := yDist
            }
        }

        if (bestLiveIdx = 0 || bestScore < 30) {
            totalNotFound++
            continue
        }

        ; Claim this live control so it can't be matched again
        cfClaimed[bestLiveIdx] := true

        cfMatchHwnd := liveControls[bestLiveIdx].hwnd

        ; Scroll the control into view before interacting
        CF_ScrollIntoView(cfMatchHwnd)

        ; Apply the state change
        if (cfTplType = "checkbox") {
            ; Check current state
            SendMessage, 0x00F0, 0, 0,, ahk_id %cfMatchHwnd%   ; BM_GETCHECK
            currentChecked := ErrorLevel ? true : false
            if (currentChecked != cfTplChecked) {
                PostMessage, 0x00F5, 0, 0,, ahk_id %cfMatchHwnd%   ; BM_CLICK
                totalApplied++
                Sleep, 50
            }
        }
        else if (cfTplType = "checklist") {
            ; TCheckListBox item: toggle by selecting + Space
            cfCLIdx := liveControls[bestLiveIdx].checklistIdx
            currentCLChecked := CF_ReadCheckListItemState(cfMatchHwnd, cfCLIdx)
            if (currentCLChecked != cfTplChecked) {
                ; Focus the listbox and select the item
                DllCall("SetFocus", "Ptr", cfMatchHwnd)
                Sleep, 30
                SendMessage, 0x0186, cfCLIdx, 0,, ahk_id %cfMatchHwnd%   ; LB_SETCURSEL
                Sleep, 30
                ; Click on the checkbox area of the item
                VarSetCapacity(itmRect, 16, 0)
                SendMessage, 0x0198, cfCLIdx, &itmRect,, ahk_id %cfMatchHwnd%  ; LB_GETITEMRECT
                itmY := NumGet(itmRect, 4, "Int") + 5  ; middle of item vertically
                ; Click at x=8 (checkbox area) within client coords
                clickLParam := (itmY << 16) | 8
                PostMessage, 0x0201, 0x0001, clickLParam,, ahk_id %cfMatchHwnd%  ; WM_LBUTTONDOWN
                Sleep, 30
                PostMessage, 0x0202, 0, clickLParam,, ahk_id %cfMatchHwnd%  ; WM_LBUTTONUP
                totalApplied++
                Sleep, 50
            }
        }
        else if (cfTplType = "radio") {
            if (cfTplSelected) {
                SendMessage, 0x00F0, 0, 0,, ahk_id %cfMatchHwnd%   ; BM_GETCHECK
                currentSelected := ErrorLevel ? true : false
                if (!currentSelected) {
                    PostMessage, 0x00F5, 0, 0,, ahk_id %cfMatchHwnd%   ; BM_CLICK
                    totalApplied++
                    Sleep, 50
                }
            }
        }
        else if (cfTplType = "combo") {
            if (cfTplValueIdx >= 0) {
                SendMessage, 0x014E, cfTplValueIdx, 0,, ahk_id %cfMatchHwnd%   ; CB_SETCURSEL
                cfComboParent := DllCall("GetParent", "Ptr", cfMatchHwnd, "Ptr")
                ctrlId := DllCall("GetDlgCtrlID", "Ptr", cfMatchHwnd, "Int")
                wParam := (0x0001 << 16) | ctrlId
                PostMessage, 0x0111, wParam, cfMatchHwnd,, ahk_id %cfComboParent%  ; WM_COMMAND
                totalApplied++
                Sleep, 50
            }
        }
    }

    CF_DismissIntermediatePopups()

    if (CF_AutoSave && totalApplied > 0) {
        ; Check if Esc was pressed at any point during apply, or right now
        if (cfAutoSaveCancelled || GetKeyState("Escape", "P")) {
            ToolTip, AutoSave cancelled - %totalApplied% applied`, review and save manually
            SetTimer, CF_ClearToolTip, -3000
            return
        }
        ; Find and click the Save button
        CF_ClickSaveButton(targetHwnd)
        ToolTip, %totalApplied% applied and saved
        SetTimer, CF_ClearToolTip, -3000
    } else if (CF_AutoSave && totalApplied = 0) {
        ToolTip, No controls applied - nothing to save
        SetTimer, CF_ClearToolTip, -3000
    } else {
        ToolTip, Done: %totalApplied% applied`, %totalNotFound% not matched - review before submitting
        SetTimer, CF_ClearToolTip, -5000
    }

    ; Re-assert AlwaysOnTop on the panel  WinActivate on CPFS dialog strips it
    if (NB_BoosterGuiVisible = 1)
        WinSet, AlwaysOnTop, On, ahk_id %NB_PanelHwnd%
}


;============================================================================================
; CF - DELETE TEMPLATE
;============================================================================================

CF_BtnDeleteTemplate:
    global CF_TemplateDir, CF_AppTitle

    cfDelList := ""
    cfDelPaths := []
    Loop, Files, %CF_TemplateDir%\*.json
    {
        SplitPath, A_LoopFileFullPath,,,,nameNoExt
        cfDelList .= A_Index . ": " . nameNoExt . "`n"
        cfDelPaths.Push(A_LoopFileFullPath)
    }

    if (cfDelPaths.Length() = 0) {
        MsgBox, 64, %CF_AppTitle%, No CP Flowsheets templates to delete.
        return
    }

    InputBox, cfDelChoice, %CF_AppTitle% - Delete Template, Enter the number of the template to delete:`n`n%cfDelList%,, 350, 300
    if (ErrorLevel || cfDelChoice = "")
        return

    cfDelIdx := cfDelChoice + 0
    if (cfDelIdx < 1 || cfDelIdx > cfDelPaths.Length()) {
        MsgBox, 48, %CF_AppTitle%, Invalid selection.
        return
    }

    SplitPath, % cfDelPaths[cfDelIdx],,,,cfDelName
    MsgBox, 36, %CF_AppTitle%, Delete template "%cfDelName%"?
    IfMsgBox, Yes
    {
        FileDelete, % cfDelPaths[cfDelIdx]
        ToolTip, Template "%cfDelName%" deleted
        SetTimer, CF_ClearToolTip, -2000
    }
return


;============================================================================================
; CF - PARSE TEMPLATE JSON
;============================================================================================

CF_ParseControls(jsonContent) {
    controls := []

    ; Find the "controls" array
    cPos := InStr(jsonContent, """controls""")
    if (!cPos)
        return controls

    ; Find opening [
    arrStart := InStr(jsonContent, "[",, cPos)
    if (!arrStart)
        return controls

    ; Find matching ] using depth counting
    depth := 1
    scanPos := arrStart + 1
    arrEnd := 0
    while (scanPos <= StrLen(jsonContent) && depth > 0) {
        ch := SubStr(jsonContent, scanPos, 1)
        if (ch = "[")
            depth++
        else if (ch = "]")
            depth--
        if (depth = 0)
            arrEnd := scanPos
        scanPos++
    }
    if (!arrEnd)
        return controls

    ; Find each control object
    itemPos := arrStart
    while (true) {
        itemPos := InStr(jsonContent, "{",, itemPos + 1)
        if (!itemPos || itemPos > arrEnd)
            break
        itemEnd := InStr(jsonContent, "}",, itemPos)
        if (!itemEnd)
            break
        itemStr := SubStr(jsonContent, itemPos, itemEnd - itemPos + 1)

        ; Parse fields
        ctrlType := ""
        if (RegExMatch(itemStr, """type"":\s*""([^""]*)""", m))
            ctrlType := m1

        label := ""
        if (RegExMatch(itemStr, """label"":\s*""((?:[^""\\]|\\.)*)""", m))
            label := m1

        checked := InStr(itemStr, """checked"": true") || InStr(itemStr, """checked"":true") ? true : false
        selected := InStr(itemStr, """selected"": true") || InStr(itemStr, """selected"":true") ? true : false

        value := ""
        if (RegExMatch(itemStr, """value"":\s*""((?:[^""\\]|\\.)*)""", m))
            value := m1

        valueIdx := -1
        if (RegExMatch(itemStr, """valueIdx"":\s*(-?\d+)", m))
            valueIdx := m1 + 0

        yPos := 0
        if (RegExMatch(itemStr, """y"":\s*(-?\d+)", m))
            yPos := m1 + 0

        group_label := ""
        if (RegExMatch(itemStr, """group_label"":\s*""((?:[^""\\]|\\.)*)""", m))
            group_label := m1

        checklistIdx := -1
        if (RegExMatch(itemStr, """checklistIdx"":\s*(-?\d+)", m))
            checklistIdx := m1 + 0

        entry := {type: ctrlType, label: label, checked: checked, selected: selected
            , value: value, valueIdx: valueIdx, y: yPos, group_label: group_label
            , checklistIdx: checklistIdx}
        controls.Push(entry)

        itemPos := itemEnd
    }

    return controls
}


;============================================================================================
; CF - SAFETY: DISMISS INTERMEDIATE POPUPS
;============================================================================================

CF_DismissIntermediatePopups() {
    Sleep, 150
    Loop, 3
    {
        found := false
        WinGet, wndList, List, ahk_exe CPFlowsheets.exe
        Loop, %wndList%
        {
            wnd := wndList%A_Index%
            WinGetClass, cls, ahk_id %wnd%

            ; Skip the main window
            WinGetPos,,, w, h, ahk_id %wnd%
            if (w > 500 || h > 400)
                continue

            ; Check for dangerous buttons
            if (CF_HasDangerousButton(wnd))
                continue

            ; Find and click OK button
            okHwnd := CF_FindOKButton(wnd)
            if (okHwnd) {
                PostMessage, 0x00F5, 0, 0,, ahk_id %okHwnd%  ; BM_CLICK
                Sleep, 200
                found := true
            }
        }
        if (!found)
            break
    }
}

CF_HasDangerousButton(windowHwnd) {
    global CF__hasDangerous
    CF__hasDangerous := false
    enumDang := RegisterCallback("CF__CheckDangerousCallback", "Fast")
    DllCall("EnumChildWindows", "Ptr", windowHwnd, "Ptr", enumDang, "Ptr", 0)
    return CF__hasDangerous
}

CF__CheckDangerousCallback(hwnd, lParam) {
    global CF__hasDangerous
    VarSetCapacity(buf, 512, 0)
    DllCall("GetClassName", "Ptr", hwnd, "Str", buf, "Int", 256)
    className := buf

    ; Text input fields = data entry form, not an OK popup
    if (InStr(className, "TEdit") || InStr(className, "TMemo") || InStr(className, "TRichEdit")
        || InStr(className, "Edit") || InStr(className, "RichEdit")) {
        CF__hasDangerous := true
        return 0
    }

    ; Check button text for dangerous labels
    if (InStr(className, "Button") || InStr(className, "TButton") || InStr(className, "TBitBtn")) {
        SendMessage, 0x000E, 0, 0,, ahk_id %hwnd%
        tLen := ErrorLevel
        if (tLen > 0 && tLen < 256) {
            VarSetCapacity(tBuf, (tLen + 1) * 2, 0)
            SendMessage, 0x000D, tLen + 1, &tBuf,, ahk_id %hwnd%
            StringUpper, textUpper, % StrGet(&tBuf)
            if (InStr(textUpper, "FINISH") || InStr(textUpper, "SUBMIT")
                || InStr(textUpper, "SIGN") || InStr(textUpper, "FILE")
                || InStr(textUpper, "COMPLETE") || InStr(textUpper, "SAVE")
                || InStr(textUpper, "DELETE") || InStr(textUpper, "REMOVE")) {
                CF__hasDangerous := true
                return 0
            }
        }
    }
    return 1
}

CF_FindOKButton(windowHwnd) {
    global CF__foundOKHwnd
    CF__foundOKHwnd := 0
    enumOK := RegisterCallback("CF__FindOKCallback", "Fast")
    DllCall("EnumChildWindows", "Ptr", windowHwnd, "Ptr", enumOK, "Ptr", 0)
    return CF__foundOKHwnd
}

CF__FindOKCallback(hwnd, lParam) {
    global CF__foundOKHwnd
    VarSetCapacity(buf, 512, 0)
    DllCall("GetClassName", "Ptr", hwnd, "Str", buf, "Int", 256)
    className := buf

    if !(InStr(className, "Button") || InStr(className, "TButton") || InStr(className, "TBitBtn"))
        return 1

    SendMessage, 0x000E, 0, 0,, ahk_id %hwnd%
    tLen := ErrorLevel
    if (tLen > 0 && tLen < 256) {
        VarSetCapacity(tBuf, (tLen + 1) * 2, 0)
        SendMessage, 0x000D, tLen + 1, &tBuf,, ahk_id %hwnd%
        StringUpper, textUpper, % StrGet(&tBuf)
        if (textUpper = "OK" || textUpper = "&OK" || textUpper = "CONTINUE"
            || textUpper = "&CONTINUE" || textUpper = "YES" || textUpper = "&YES") {
            CF__foundOKHwnd := hwnd
            return 0
        }
    }
    return 1
}


;============================================================================================
; CF - FIND AND CLICK SAVE BUTTON
;
; Finds the "Save" TButton in CP Flowsheets and clicks it.
; Used by AutoSave feature after template apply.
;============================================================================================

CF_ClickSaveButton(windowHwnd) {
    global CF_AppTitle, CF__foundSaveHwnd
    CF__foundSaveHwnd := 0
    enumSave := RegisterCallback("CF__FindSaveCallback", "Fast")
    DllCall("EnumChildWindows", "Ptr", windowHwnd, "Ptr", enumSave, "Ptr", 0)

    if (CF__foundSaveHwnd) {
        PostMessage, 0x00F5, 0, 0,, ahk_id %CF__foundSaveHwnd%   ; BM_CLICK
        ToolTip, AutoSave: Save clicked
        SetTimer, CF_ClearToolTip, -2000
    } else {
        ToolTip, AutoSave: Save button not found - save manually
        SetTimer, CF_ClearToolTip, -3000
    }
}

CF__FindSaveCallback(hwnd, lParam) {
    global CF__foundSaveHwnd

    ; Skip invisible
    cfStyle := DllCall("GetWindowLong", "Ptr", hwnd, "Int", -16, "UInt")
    if !(cfStyle & 0x10000000)
        return 1

    VarSetCapacity(buf, 512, 0)
    DllCall("GetClassName", "Ptr", hwnd, "Str", buf, "Int", 256)
    className := buf

    if !(InStr(className, "Button") || InStr(className, "TButton"))
        return 1

    ; Get button text
    VarSetCapacity(tBuf, 256, 0)
    DllCall("GetWindowText", "Ptr", hwnd, "Str", tBuf, "Int", 128)
    btnText := tBuf

    if (btnText = "Save" || btnText = "&Save") {
        CF__foundSaveHwnd := hwnd
        return 0
    }
    return 1
}


;============================================================================================
; CF - SCROLL INTO VIEW
;
; Scrolls the parent TScrollBox so the target control is visible.
; Walks up the parent chain to find a TScrollBox, then scrolls it.
;============================================================================================

CF_ScrollIntoView(controlHwnd) {
    ; Find the parent TScrollBox
    scrollBoxHwnd := 0
    parent := controlHwnd
    Loop, 10
    {
        parent := DllCall("GetParent", "Ptr", parent, "Ptr")
        if (!parent)
            break
        VarSetCapacity(pBuf, 512, 0)
        DllCall("GetClassName", "Ptr", parent, "Str", pBuf, "Int", 256)
        pClass := pBuf
        if (pClass = "TScrollBox") {
            scrollBoxHwnd := parent
            break
        }
    }
    if (!scrollBoxHwnd)
        return

    ; Get scroll box client rect (visible area)
    VarSetCapacity(sbRect, 16, 0)
    DllCall("GetWindowRect", "Ptr", scrollBoxHwnd, "Ptr", &sbRect)
    sbTop := NumGet(sbRect, 4, "Int")
    sbBottom := NumGet(sbRect, 12, "Int")

    ; Get control screen rect
    VarSetCapacity(ctrlRect, 16, 0)
    DllCall("GetWindowRect", "Ptr", controlHwnd, "Ptr", &ctrlRect)
    ctrlTop := NumGet(ctrlRect, 4, "Int")
    ctrlBottom := NumGet(ctrlRect, 12, "Int")

    ; If already visible, no scroll needed
    if (ctrlTop >= sbTop && ctrlBottom <= sbBottom)
        return

    ; Calculate how much to scroll
    if (ctrlBottom > sbBottom) {
        scrollAmount := ctrlBottom - sbBottom + 30
    } else {
        scrollAmount := ctrlTop - sbTop - 30
    }

    ; Get current scroll position
    VarSetCapacity(si, 28, 0)
    NumPut(28, si, 0, "UInt")
    NumPut(0x17, si, 4, "UInt")   ; SIF_ALL
    DllCall("GetScrollInfo", "Ptr", scrollBoxHwnd, "Int", 1, "Ptr", &si)  ; SB_VERT=1
    currentPos := NumGet(si, 20, "Int")

    ; Set new position
    newPos := currentPos + scrollAmount
    NumPut(newPos, si, 20, "Int")
    NumPut(0x04, si, 4, "UInt")   ; SIF_POS
    DllCall("SetScrollInfo", "Ptr", scrollBoxHwnd, "Int", 1, "Ptr", &si, "Int", 1)

    ; Notify the scrollbox to scroll
    wParam := (newPos << 16) | 4  ; SB_THUMBPOSITION=4
    PostMessage, 0x0115, wParam, 0,, ahk_id %scrollBoxHwnd%  ; WM_VSCROLL
    Sleep, 80
}


;============================================================================================
; CF - UTILITY FUNCTIONS
;============================================================================================

CF_EscJson(str) {
    str := StrReplace(str, "\", "\\")
    str := StrReplace(str, """", "\""")
    str := StrReplace(str, "`n", "\n")
    str := StrReplace(str, "`r", "\r")
    str := StrReplace(str, "`t", "\t")
    return """" . str . """"
}

CF_SanitizeFilename(name) {
    name := Trim(name)
    name := RegExReplace(name, "[<>:""/\\|?*]", "_")
    return name
}

CF_ClearToolTip:
    ToolTip
return


;============================================================================================
; CF - HOTKEY: Ctrl+Shift+F - Spy dump CP Flowsheets
;============================================================================================

^+f::
    gosub CF_SpyDumpControls
return


;############################################################################################
;################### END CP FLOWSHEETS BOOSTER ###############################################
;############################################################################################
